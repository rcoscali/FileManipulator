

/*-------------------------------Identification-------------------------------*/
/**                           Sardane EasyDoc 02.1                           **/
#ifndef LINT
#define __WATINCLUDE__ "bigfile1.cpp"
#ifdef __TIMESTAMP__
#define WhatStampGIVMiseEnFormeEpj_pc "@(#)SARDANE $Revision:   3.132  $	GIVMiseEnFormeEpj.pc	""("__TIMESTAMP__"-"__DATE__" "__TIME__")"
#endif	/* __TIMESTAMP__ */
char *WhatIdentGIVMiseEnFormeEpj_pc (void)
{
    char *WhatGIVMiseEnFormeEpj_pc = WhatStampGIVMiseEnFormeEpj_pc;
    return (WhatGIVMiseEnFormeEpj_pc);
}
#endif	/* LINT */
/*---------------------------Fin de l'identification--------------------------*/

/*----------------------------------Includes----------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <sys/time.h>
#include <memory.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <iconv.h>

/* HAL, 13/11/2008 : modif pour Linux	*/
/* Ce qui suit concernant "oci.h" a été lu sur "Oracle MetaLink" (Doc ID: NOTE:90169.1)		*/
/* Le fichier "oci.h" se trouve sous "$ORACLE_HOME/rdbms/public"				*/
/* The following 3 lines avoid inclusion of oci.h during precompilation				*/
/* oci.h is needed only during compilation to resolve calls generated by the precompiler	*/
#ifndef ORA_PROC
#include <oci.h>
#endif

EXEC SQL begin declare section;
#include "GIVTypes.h"
EXEC SQL end declare section;


#include "GWCIdenObjetPub.h"
#include "GHTgestion_compteurs.h"
#include "GWTTrace.h"

#include "GYBconstantes.h"
EXEC SQL begin declare section;
#include "GYBstruct_C.h"
EXEC SQL end declare section;
#include "GIVConstantesBloc.h"
#include "GYBinterface_SGBDR.h"

EXEC SQL begin declare section;
EXEC SQL include "GYBstruct_Pro_C.h";
#include "GYBindicatrices.h"
EXEC SQL include "GYBgestion_pro_c.h";
EXEC SQL end declare section;

#include "GBERetourFournisseur.h"
#include "GBZConstantes.h"
#include "GXWDonnees.h"

#include "GWCStructTLV.h"

#include "GIXConstantes.h"
#include "GIXVariables.h"
#include "GWZTypeChamp.h"

#include "GIVConstantes.h"
#include "GIVVariables.h"
#include "GIMTraiteAdr.h"
#include "GIVBouclerEpj.h"
#include "GIVMiseEnFormeMvtCDBloc.h"
#include "GHHCoherence.h"
#include "GIVBlocsDoubles.h"
#include "GIVLectureTabIAPROFBloc.h"
#include "GDQQualification.h"

#define SQLCA_STORAGE_CLASS extern
EXEC SQL include sqlca;
#define ORACA_STORAGE_CLASS extern
EXEC SQL include oraca;

/*-----------------------------Constantes internes----------------------------*/
#define givRecreerCD "CRE"
#define givcR00000000 "00000000"
#define givcR000000 "000000"
#define givcTypNoyau  'P'
#define givcTypModule 'M'
#define givcNogrou "0000000"
#define givtcMoteur "MONGO"
#define GIV_GRO_DEFAUT "0"

#define GIV_CHAR_BLANC   ' '
#define givcIndInitPre   1      /* index de l'octet parution prenom */
#define givcIndParuAdr   2      /* index de l'octet parution adresse */
#define givcIndParuNoParu 3      /* index de l'octet parution numéro */
#define givcParuAdr      '0'    /* valeur parution adresse normale   */
#define givcParuSSAdr    '1'    /* valeur parution sans adresse      */
#define givcParuSSNo     '2'    /* valeur parution sans numéro dans la voie */
#define givcParuIPre    '1'    /* valeur parution initiale     */
#define givcParuSSNoParu '3'    /* valeur parution sans numéro de parution */
#define givcParuSante      '0'    /* valeur parution santé par defaut */
#define givcParuMed    'm'    /* valeur parution santé pour médecin */
#define givcParuCab     'c'    /* valeur parution santé pour cabinet */
#define givcSuppCham     '3'    /* valeur support chamois */

#define givcLocFictive  "99999" /* code loc d'une localité ficitve */
#define givcLocIndf  "00000" /* code loc d'une localité indéfinie */
#define givcDepPays  "500" /* code loc d'une localité ficitve */
#define givcDepFictif "952"
#define givTrad "&amp;" /* traduction caractère & */
#define givtcMaxAud "MA" /* maxi audience */
#define givtcNatureAn8Part "GPB" /* nature parution rubrique */

				/* Pour les sauts de lignes */
#define SEPARE_LIGNE                        0x0D
#define LINE_FEED                           0x0A


#define GIV_TAILLE_MAX_EPJ 5000
#define MAX_PARENT 1000         /* par bloc nombre max de partenaires d'un parent */
#define MAX_AN9     200		/* Nombre maxi d'AN9 pour une inscription */
#define MAX_CRC     100		/* Nombre maxi de CRC pour une inscription */
#define MAX_LIST    60000       /* par bloc nombre max d'associations rub/denom/obj/geo */
#define MAX_LIST_CRC 4000         /* par fichier contenu nombre max de CRC */
#define MAX_LIST_CONT 2500         /* par bloc contenu nombre max de contenu d'établissement */
#define giv_LG_REQUETE 512
#define giv_DIV_PAR_DIX 16

#define giv_LG_CLOB 65500-1 /* taile de lecture d'un clob en varchar */
#define giv_LG_BUFFTEST 4000000 /* taille max de bloc complet pour le moteur */

#define giv_DEP_MONACO "006"
#define giv_LOC_MONACO "16200"

#define giv_DFT 99
#define giv_ARR 0
#define giv_LOC 1
#define giv_DEPT 2
#define giv_REG 3
#define giv_EXTL 4
#define giv_ZU 5
#define giv_ZV 6
#define giv_UV 7

/* données-contenus */
#define giv_ENR "ENR" /* enrichies */
#define giv_ADD "ADD" /* additionnelles */
#define giv_ADG "ADG" /* additionnelles GC-EN */
#define giv_REL "REL" /* réseaux-relais-colis */
#define giv_ANN "ANN" /* annonceur */
#define giv_EPJ "EPJ" /* établissement */
#define giv_ANO "ANO" /* établissement annoté */
#define giv_HPN "HPN" /* infos horaires payanets normalisées */
#define giv_HGN "HGN" /* infos horaires gratuites normalisées */
#define giv_PHO "PHO" /* photos */
#define giv_CAL "CAL" /* calendrier */
#define giv_PRT "PRT" /* partenaire */

/* source de données additionnelles */
#define giv_GCEN "GC-EN" /* additionnelles GC-EN */

/* origine des partenaires */
#define giv_ACCO "ACCO"
#define giv_RESA "RESA"
#define giv_EXPD "EXPD"
#define giv_B2B "B2B"
#define giv_CHRO "CHRO"
#define giv_PJDC "PJDC"
#define giv_cPJDC 'c'
#define giv_orPJDC 'o'
#define giv_svPJDC 's'
#define giv_prPJDC 'p'
#define giv_sPJDC "LP"
#define giv_ssPJDC "CR"
#define giv_sRKPJDC "3R"
#define giv_cCHRO 'c'
#define giv_sCHRO "LC"
#define giv_ssCHRO "CH"
#define giv_cLEUR 'l'

#define giv_INIT_ARR 98

#define giv_RUB 0
#define giv_DNOM 1
#define giv_OBJ 2

#define givTitreDoc "Dr "

/* Requete de lecture du texte correspondant l'AN9 */
#define GIVRequeteLectureRJRUPR \
"select lasan9 \
 from rjrupr \
 where codan9 = :codeAn9"


/* Requete de lecture du theme correspondant l'AN9 */
#define GIVRequeteLectureThemeED \
"select theme \
 from GYTtabThemeED \
 where codan9 = :codeAn9"

/* Requete de lecture du type d'URL */
#define GIV_RQ_SELECT_TYPE_URL \
"select unique tpdurl,liburl from GYTtabPemicURL  \
where (numobj = :numobj \
and typobj = :typobj \
and tpdsob = :tpdsob1 \
)"

/* Requete de lecture des données de l'établissement de niveau inscription */
#define GIV_RQ_SELECT_ETAB_MC \
"select siret, url, tefet, tefen, siege, cj, libcj, libape, datcrent from  GYTTabPeEtab  \
where etab = :etab"

#define GIV_RQ_SELECT_SIREN \
"select to_char(count(etab),'FM00000') from GYTTabPeEtab where substr(siret,1,9) = substr(:siren,1,9)"

/* Requete de lecture des données de l'établissement */
#define GIV_RQ_SELECT_ETAB \
"select denom, nomdirig, parut_insee, siret_rs, siret_rscompl, siret_enseigne, siret_sigle, opp_photo from GYTTabPeEtab \
where etab = :etab"

/* Requete de lecture des dénominations secondaires de l'établissement */
#define GIV_RQ_SELECT_DENOM_ETAB \
"select origine,denom from GYTTabDenomsEtab \
where etab = :etab"

/* Requete de lecture des photos de l'établissement */
#define GIV_RQ_SELECT_PHOTOS_ETAB \
"select x.photo, x.legende, x.cteutil, x.origine, x.metadata.getClobVal() from GYTTabPhotosEtab x \
where etab = :etab"

/* Requete de lecture des objets pub de l'établissement */
#define GIV_RQ_SELECT_PUB_ETAB \
"select epjobj,tpdsob,stobj,numobj,(TO_CHAR (datact,'FXYYYYMMDD')) from GYTTabEpjMic  \
where etab = :etab and upper(tpdsob) = tpdsob and tpdsob||stobj != 'FAPK' \
union select a.epjobj,a.tpdsob,a.stobj,a.numobj,(TO_CHAR (datact,'FXYYYYMMDD')) from GYTTabEpjMic a, GYTtabProduitGPPParut b  \
where a.etab = :etab and upper(a.tpdsob) = a.tpdsob and a.tpdsob||a.stobj = 'FAPK' \
and b.numobj = a.epjobj and nls_upper(b.tpdsob) = nls_upper(a.tpdsob) \
and	((b.datedeb is null) or (to_char(b.datedeb,'YYYYMMDD') <= to_char(current_date,'YYYYMMDD'))) \
and	((b.datefin is null) or (to_char(current_date,'YYYYMMDD') <= to_char(b.datefin,'YYYYMMDD'))) \
union select '',tpdsob,stobj,'','' from View_EPJProduitsFictifs \
where etab = :etab"

/* Requete de lecture du calendrier de partenaire */
#define GIV_RQ_SELECT_CALEND_PART \
"select XMLSERIALIZE(Document XMLTYPE(x.complement.extract('/complement/complement_pjdocclicrdv/calendrier').getClobVal()) AS CLOB INDENT SIZE = 0) \
 from GYTTabPartEtab x \
 where x.origine = :origine and x.refext = :refext \
 and existsNode(x.complement,'/complement/complement_pjdocclicrdv/calendrier') = 1"

/* Requete de lecture des photos de partenaire */
#define GIV_RQ_SELECT_PHOTO_PART \
"select XMLSERIALIZE(Document XMLTYPE(x.photos.extract('/photos/photo').getClobVal()) AS CLOB INDENT SIZE = 0) \
 from GYTTabPartEtab x \
 where x.origine = :origine and x.refext = :refext \
 and existsNode(x.photos,'/photos/photo') = 1"

/* Requete de lecture des données de l'établissement */
#define GIV_RQ_SELECT_PEETAB \
"select \
etab,siret,ape, \
denom,compln, \
coddep,codloc,libloc, \
codvoi,typvoi,libvoi,novoie,cplnov, \
longitude,latitude,precision \
from GYTtabPeEtab \
where (etab = :etab)"

/* Requete de lecture des URL d'un établissement Grand Compte */
#define GIV_RQ_SELECT_PUB_GCPT \
"select liburl from GYTTabURLGCpt  \
where etab = :etab"

/* Requete de lecture des anciens établissements */
#define GIV_RQ_SELECT_OLD_ETAB \
"select etarepri,typrepri,(TO_CHAR (datelien,'FXYYYYMMDD')) dat from GYTTabLiensEtab \
where etab = :etab order by dat"

/* Requete de lecture des liens vers site de SEO */
#define GIV_SLC_LVS_SEO_ETAB "\
      select idstat,partseo,urlseo,ancre,follow,ordre \
      from gyttablvsseoetab \
      where etab = :pcOraEtab"

/* Requete de lecture des liens vers les produits à l'epj */
#define GIV_SLC_LIENS_PROD_ETAB "\
      select tpdsob,stobj,epjobj,cle,valeur \
      from gyttabprodliensetab \
      where etab = :pcOraEtab"

/* Requete de lecture de Ref Embauche */
#define GIV_RQ_SELECT_EMBAUCHE \
"select refext from  GYTTabEmbauche  \
where numcli = :numcli"

#define GIV_RQ_SELECT_BONPLAN_PUB \
"select etab,(TO_CHAR (date_fin,'FXYYYYMMDD')),TO_CHAR(nb_bp,'FM99999'),tpdsob,decode(tpdsob,'E+',1,'EB',2,'C+',3,'CB','4','G+',5,'GB',6,7),numcli from  GYTTabBonPlan  \
where etab = :etab \
union select b.etab,(TO_CHAR (b.date_fin,'FXYYYYMMDD')),TO_CHAR(b.nb_bp,'FM99999'),b.tpdsob,decode(b.tpdsob,'E+',1,'EB',2,'C+',3,'CB','4','G+',5,'GB',6,7),numcli from GYTTabEpjMic a, GYTTabBonPlan b \
where a.etab = :etab and b.numcli = substr(a.numobj,5,8) and b.numprod = substr(a.numobj,13,4) and b.tpdsob = a.tpdsob \
order by 002 desc,003 desc,005,006"

#define GIV_RQ_SELECT_IMAG \
"select to_char(nbimag),to_char(imagcat),imagmenu from GYTTabPvImag  \
where numobj = :numobj"

#define GIV_RQ_SELECT_STAT \
"select estatan from  GYTTabEStatAn \
where numcli = :numcli"

/* Requete de lecture de EvIlo */
#define GIV_RQ_SELECT_EVILO \
"select evt, prg from  GYTTabEvIlo  \
where etab = :etab"

/* Requete de lecture du type de Siret Pages Pro */
#define GIV_RQ_SELECT_SIRET \
"select siret from GYTtabPagesPro  \
where (siret = :siret)"


/* libellé de localité de rattachement */
#define GIV_RQ_SELECT_LIB_LJLORN \
"select distinct a.liblae \
from GYTtabPelrep a, LJLORN b\
 where (a.depart = b.cdsdep and a.numloc = b.numloc \
 and (a.arrond = '00' or a.arrond = '99')) \
 and (b.cddprn = :depart and b.nulorn = :numloc)"

/* localités par département */
#define GIV_RQ_SELECT_LOC_DEP \
"select numloc \
from GYTtabPelrep where depart = :depart and numloc != '99999'"

/* GIV_RQ_SELECT_ZU : texte SQL de la requete de recherche Zone Urbaine */

#define GIV_RQ_SELECT_ZU \
"select deppole,locpole \
from GYTtabPelzu\
 where depart = :depart and localite = :numloc"

#define GIV_RQ_SELECT_ZU_POLE \
"select deppole,locpole \
from GYTtabPelzu\
 where depart = :depart and localite = :numloc\
 and depart = deppole and localite = locpole"

#define GIV_RQ_SELECT_ZU_LF \
"select deppole,locpole \
from GYTtabPelzu\
 where depart = :depart and localite = :numloc"

/* GIV_RQ_SELECT_LOCFUS : texte SQL de la requete de recherche de localité fusionnée */

#define GIV_RQ_SELECT_LOCFUS \
"select depfus,locfus \
from GYTtabPelFusion \
 where depart = :depart and localite = :numloc"

#define GIV_RQ_SELECT_REGION \
"select cdsreg \
from ljdept\
 where cdsdep = :depart"

#define GIV_RQ_SELECT_NEW_REGION \
"select cdsreg, cdrgol \
from ljdept\
 where cdsdep = :depart"

#define GIV_RQ_SELECT_CRC \
"select codecrc,libelcrc,navigateur \
from donneescrc\
 where depart = :depart and numloc = :numloc and numnat = :numnat \
 and codan9 = :codan9"

#define GIV_RQ_SELECT_ANC_BLOC "\
select substr(blocid,1,length(blocid)-1)||'C000'||substr(blocid,length(blocid),1) \
        from VueTabMvtsBloc_%s_%s_%s\
        where (depart = %s) and (numnat = :numnat) and (numlo = :numlo) and (numls = :numls) and (substr(blocid,1,4) != 'C000') and blocid is not null"

/* acces GYTtabIeBlocCRC_dest */

#define GIV_DEL_IEBLOC_CRC "\
        delete from GYTtabieBlocEpjCRC_%s\
        where (blocid = :cBlocid)"

#define GIV_INS_IEBLOC_CRC "\
        insert into GYTtabIeBlocEpjCRC_%s\
        (blocid,etab,crc,type,codan8,origine,version)\
        values (:acBlocid,\
                :acEtab,\
                :acCrc,\
                nvl(:acType,'X'),\
                :acCodan8,\
                :acTpdsob,\
                :version)"

/* acces GYTtabIeBloc_dest */

#define GIV_DEL_IEBLOC "\
        delete from GYTtabIeBlocEpj_%s\
        where (depart = :cDepart) and (blocid = :cBlocid)"

#define GIV_CRE_IS "\
        insert into GYTtabIeBlocEpj_%s\
        (depart,numnat,numlo,numls,blocid,etab,nogrou,noselo,nosels,datemodbloc,version)\
        values (:acDepart,\
                :acNumnat,\
                :acNumlo,\
                :acNumls,\
                :acBlocid,\
                :acEtab:indicatrice_acEtab, \
                :acNogrou:indicatrice_acNogrou,\
                :acNoselo:indicatrice_acNoselo,\
                :acNosels:indicatrice_acNosels,\
                (TO_DATE (:acDatemodbloc,'FXYYYYMMDD')),\
                :version)"

#define GIV_CRE_IG "\
        insert into GYTtabIeBlocEpj_%s\
        (depart,numnat,numlo,numls,blocid,etab,nogrou,noselo,nosels,datemodbloc,version)\
        values (:acDepart,\
                :acNumnat,\
                :acNumlo,\
                :acNumls,\
                :acBlocid,\
                :acEtab:indicatrice_acEtab, \
                :acNogrou:indicatrice_acNogrou,\
                :acNoselo:indicatrice_acNoselo,\
                :acNosels:indicatrice_acNosels,\
                (TO_DATE (:acDatemodbloc,'FXYYYYMMDD')),\
                :version)"

#define GIV_SLC_CLOB_DONENR "\
      select XMLSERIALIZE(Document XMLTYPE(x.donenr.extract('/donneesEnrichissement/prestationsDonneesEnrichies').getClobVal()) AS CLOB INDENT SIZE = 0) \
      from gyttabpeetab x \
      where x.etab = :pcOraEtab and existsNode(x.donenr,'/donneesEnrichissement/prestationsDonneesEnrichies') = 1"

#define GIV_SLC_CLOB_DONREL "\
      select x.res_relais.getClobVal() \
      from gyttabpeetab x \
      where x.etab = :pcOraEtab and existsNode(x.res_relais,'/lstde') = 1"

#define GIV_SLC_CLOB_DONADD_GCEN "\
select x.info.getClobVal() \
      from gyttabdonaddetab x \
      where x.etab = :pcOraEtab and x.source = :pcOraSce \
      and existsNode(x.info,'/listeEnseigneEpj/enseigneEpj/libelleEnseigne') = 1"

#define GIV_SLC_CLOB_DONADD "\
      select x.info.getClobVal() \
      from gyttabdonaddetab x \
      where x.etab = :pcOraEtab and x.source = :pcOraSce"

#define GIV_SLC_CLOB_ANNONC "\
      select x.contenu.getClobVal() \
      from gyttabcontenusannonceur x \
      where x.numobj = :pcObjet and x.type = :pcType"

#define GIV_SLC_TYP_CONT_ETAB "\
      select distinct type,theme \
      from gyttabcontenusetab \
      where etab = :pcOraEtab"

#define GIV_SLC_CONT_PROF_ETAB "\
      select distinct 'V','DV',codan8,'' from gyttabprofetab where etab = :pcOraEtab and origine = '5' \
      union select distinct 'N',a.type,a.codan8,nvl(to_char(b.datefraho,'FXYYYYMMDD'),'19000101') from gyttabdhnetab a, gyttabprofetab b \
       where a.etab = :pcOraEtab and b.etab = a.etab and b.origine = '5' and a.codan8 = b.codan8 \
      union select distinct 'N',a.type,'',nvl(to_char(b.datefraho,'FXYYYYMMDD'),'19000101') from gyttabdhnetab a, gyttabpeetab b \
       where a.etab = :pcOraEtab and b.etab = a.etab and a.type = 'DE' \
      union select distinct 'S',a.type,a.codan8,nvl(to_char(b.datefraho,'FXYYYYMMDD'),'19000101') from gyttabdhsetab a, gyttabprofetab b \
       where a.etab = :pcOraEtab and b.etab = a.etab and b.origine = '5' and a.codan8 = b.codan8 \
      union select distinct 'S',a.type,'',nvl(to_char(b.datefraho,'FXYYYYMMDD'),'19000101') from gyttabdhsetab a, gyttabpeetab b \
       where a.etab = :pcOraEtab and b.etab = a.etab and a.type = 'DE' \
      order by 001,004 desc,002 desc,003"

#define GIV_SLC_CLOB_ETAB "\
      select y.contenu.getClobVal() \
      from gyttabcontenusetab y \
      where y.etab = :pcOraEtab and y.type = :pcType and nvl(:pcTheme,y.theme) = y.theme"

#define GIV_SLC_CLOB_ANNOT "\
      select z.contenu.getClobVal() \
      from gyttabcontenusetab z \
      where z.etab = :pcOraEtab and z.type = :pcType and z.source = :pcOraSce"

#define GIV_SLC_CLOB_DHNA "\
      select xx.contenu.getClobVal() \
      from gyttabdhnannonceur xx \
      where xx.type = :pcType and xx.numobj = :pcObjet"

#define GIV_SLC_CLOB_DHNE "\
      select x.contenu.getClobVal() \
      from gyttabdhnetab x \
      where x.etab = :pcOraEtab and x.type = :pcOraType and \
      ((x.type = 'DV' and x.codan8 = :pcAn8:sInd) or \
       (x.type = 'DE'))"

#define GIV_SLC_CLOB_PART "\
      select x.complement.getClobVal(), x.photos.getClobVal() \
      from gyttabpartetab x \
      where x.origine = :origine and x.refext = :refext"

#define GIV_SLC_MOT_CLE "\
      select b.idmotcle,b.codan8,b.terme \
      from gyttabgppmotscles a, gyttabmotsclescri b \
      where a.numobj = :obj and b.idmotcle = a.idmotcle \
      and b.codan8 is not null"

#define GIV_RQ_SELECT_BUC "\
 select distinct numcli from gyttabieinsc_888 \
 where etab = :etab and (numls >= :min) and (numls <= :max) and numcli is not null order by numcli"

/* requêtes SEO */

#define GIV_RQ_SELECT_SRV_SEO \
"select info,avis from GYTTabSEOService \
where etab = :etab %s"

#define GIV_VERS_SEO "\
      select min(decode(double,'REF',1,'RFV',2,'DBL',3,4)||blocid) \
      from GYTtabIeBloc_%s\
      where ((numnat = :cNumnat) \
        and (numlo = :cNumlo) and (numls = :cNumls))"

#define GIV_RQ_SELECT_DNOM_PRINC "\
 select nvl(min(substr(a.inparu,3,1)||decode(a.indprf,'0',1,0)||decode(substr(a.inparu,1,1),'o',1,'s',2,'c',3,'p',4,5)||decode(c.tpdsob,'SC',decode(c.stobj,'PB',8,1),'FI',2,'VI',3,'IN',4,' T',5,'NV',6,'NT',7,8)||decode(a.numls,'0000',1,0)||nvl(a.nogrou||a.noselo||a.nosels,'ZZZZZZZ0000000')||a.numnat||a.numlo||a.numls),'9999ZZZZZZZ0000000ZZZZZZZZZZZZZZZZZZ') from VueTabIeInsc_%s_%s_%s a,VueTabIamic_%s_%s_%s c \
 where \
 a.indmic = '1' \
 and c.numnat = a.numnat and c.numlo = a.numlo and c.numls = a.numls \
 and a.etab = :etab \
 union \
 select nvl(min(substr(a.inparu,3,1)||decode(a.indprf,'0',1,0)||decode(substr(a.inparu,1,1),'o',1,'s',2,'c',3,'p',4,5)||'9'||decode(a.numls,'0000',1,0)||nvl(a.nogrou||a.noselo||a.nosels,'ZZZZZZZ0000000')||a.numnat||a.numlo||a.numls),'9999ZZZZZZZ0000000ZZZZZZZZZZZZZZZZZZ') from VueTabIeInsc_%s_%s_%s a \
 where \
 a.indmic = '0' \
 and a.etab = :etab \
 order by 001 \
"

/* oppositions et black-listes */
#define GIV_RQ_SELECT_OPP_PART \
"select opposition from GYTTabPartOpp \
 where origine = :origine and refext = :refext"

#define GIV_RQ_SELECT_OPP_URLGR \
"select codan8 from GYTTabURLGrOpp \
 where etab = :etab and codan8 = :codan8"

#define GIV_RQ_SELECT_PROF_URLGR \
"select codan8 from GYTTabURLGrProf \
 where codan8 = :codan8"

#define GIV_RQ_SELECT_BL_CRC_LR \
"select codan8 from GYTTabBListCRCLR \
 where etab = :etab and codan8 = :codan8 \
  and tpdsob = :tpdsob and contenu = :contenu"

#define GIV_RQ_SELECT_BL_CRC_FD \
"select tpdsob from GYTTabBListCRCFD \
 where (etab = :etab and contenu = :contenu) \
 or (tpdsob = :tpdsob)"

#define GIV_RQ_SELECT_BL_EPJ_FD \
"select etab from GYTTabBListEPJFD \
 where (etab = :etab)"

#define GIV_RQ_SELECT_BL_EPJ_PROF \
"select codan8 from GYTTabBListEPJProf \
 where etab = :etab and codan8 = :codan8"

/* conflits */
#define GIV_RQ_SELECT_PRIO_PROF_CRC \
"select codan8 from GYTTabCRCProfPrio \
 where codan8 = :codan8 and contenu = :contenu"

/* extra-localité proxi */
#define GIV_RQ_SELECT_EXTRA_LOC_IS "\
 select b.codan8 from VueTabIeInsc_%s_%s_%s a,VueTabIaProf_%s_%s_%s b \
 where b.codan8 = :codan8 \
 and a.numnat = b.numnat and a.numlo = b.numlo and a.numls = b.numls \
 and a.etab = :etab \
 and decode(a.depact,null,decode(a.coddep,null,a.deppar,a.coddep),a.depact) = a.deppar \
 and decode(a.locact,null,decode(a.codloc,null,a.locpar,a.codloc),a.locact) = decode(a.locpar,'99999',decode(a.locact,null,a.codloc,a.locact),a.locpar) \
 union \
 select b.codan8 from VueTabIeInsc_%s_%s_%s a,GYTtabProfEtab b \
 where b.etab = :etab \
 and b.codan8 = :codan8 \
 and (b.origine = '4' or b.origine = '6') \
 and a.etab = b.etab \
 and a.numls = '0000' \
 and decode(a.depact,null,decode(a.coddep,null,a.deppar,a.coddep),a.depact) = a.deppar \
 and decode(a.locact,null,decode(a.codloc,null,a.locpar,a.codloc),a.locact) = decode(a.locpar,'99999',decode(a.locact,null,a.codloc,a.locact),a.locpar) \
"
#define GIV_RQ_SELECT_EXTRA_LOC_INTER_IS "\
 select a.numnat,a.numlo,a.numls \
 from VueTabIeInsc_%s_%s_%s a,VueTabIaProf_%s_%s_%s b \
 where b.codan8 = :codan8 \
 and a.numnat = b.numnat and a.numlo = b.numlo and a.numls = b.numls \
 and a.etab = :etab \
 union \
 select a.numnat,a.numlo,a.numls \
 from VueTabIeInsc_%s_%s_%s a,GYTtabProfEtab b \
 where b.etab = :etab \
 and b.codan8 = :codan8 \
 and (b.origine = '4' or b.origine = '6') \
 and a.etab = b.etab \
 and a.numls = '0000' \
"

#define GIV_RQ_SELECT_EXTRA_LOC_IO "\
(select b.codan8 from VueTabIeInsc_%s_%s_%s a, VueTabIaProf_%s_%s_%s b \
 where a.etab = :etab and a.numls != '0000' \
 and (decode(a.depact,null,decode(a.coddep,null,a.deppar,a.coddep),a.depact) != a.deppar \
 or decode(a.locact,null,decode(a.codloc,null,a.locpar,a.codloc),a.locact) != decode(a.locpar,'99999',decode(a.locact,null,a.codloc,a.locact),a.locpar)) \
 and b.numnat = a.numnat and b.numlo = a.numlo and b.numls = a.numls \
 and not exists ( \
       (select h.codan8 from VueTabIaProf_%s_%s_%s h \
        where h.numnat = :numnat and h.numlo = :numlo and h.numls = :numls \
        union select k.codan8 from gyttabProfEtab k \
        where k.etab = :etab and (k.origine = '4' or k.origine = '6')) \
        minus \
       (select g.codan8 from VueTabIaProf_%s_%s_%s g \
        where g.numnat = b.numnat and g.numlo = b.numlo and g.numls = b.numls) ) ) \
 minus (select i.codan8 from VueTabIaProf_%s_%s_%s i \
        where i.numnat = :numnat and i.numlo = :numlo and i.numls = :numls \
 union  select j.codan8 from GYTtabProfEtab j \
        where j.etab = :etab and (j.origine = '4' or j.origine = '6')) \
"
#define GIVRequeteSyno \
"select codan8,synonymes from GyttabDenomSynonyme \
where denom = :denom"

/*-------------------------------Types internes-------------------------------*/
typedef struct
{
  char rub[8+1];               /* rubrique an9 */
  char rubinit[6+1];           /* rubrique an8 */
  char orig;                   /* origine */
  char nature[3+1];            /* nature */
  char thm[1+1];               /* thème */
  int4 iRgDnom;                 /* dénomination */
  char tcRgDnom[4+1];          /* dénomination */
  char dep[3+1];               /* département */
  char loc[5+1];               /* localité */
  char arr[2+1];               /* arrondissement */
  char reg[2+1];               /* région */
  int4  iRangTri;               /* indice de tri (rubrique) */
  int4  iDbl;                   /* indice de bloc double */
  int4  iRgLigne;               /* indice de ligne dans le bloc de référence */
  int4  iRgObj;                 /* indice d'objet publicitaire dans le bloc de référence */
  int4  iNbGeoTri;              /* nombre de rangs géographiques significatifs par rubrique (iRgGeoTri par iRangTri) */
  int4  iRgGeoTri;              /* rang géograhique par rubrique (dep et loc par iRangTri) */
  int4  iRgTriDbl;              /* indice de rubriques ayant même géographie par liste (même taille de blocs géo/rub) (iRangTri commun) */
  int4  iRgTriDblBis;           /* indice de rubriques ayant même géographie listes parution et installation confondues */
  int4  iGeo;                   /* indicateurs par géographie */
  int4  iGeoReg;
  int4  iGeoDept;
  int4  iGeoLoc;
  int4  iGeoArr;
  int4  iLF;
  int4  iZU;
  char cParuloc;               /* parution rubrique locale sur UV */
}givrEltListT;

typedef struct
{
  char reg[2+1];               /*                                   */
  char dep[3+1];               /*                                   */
  char loc[5+1];               /*                                   */
  int4  nbarr;
  int4  iParuInst;
}givrRefArrT;


/* codes géographiques */
typedef struct
{
  /* nombre total */
  int4 iNbrTot;
  /* nombre de codes */
  int4 iNbr;
  /* nombre de valeurs du critère de tri */
  int4 iNbrTri;
  /* élément */
  givrEltListT trEltList[MAX_LIST];
  int4 trEltRangList[MAX_LIST];
}givrRangListT;
/* liste des codes d'installation */
givrRangListT givrListInst;
/* liste des codes de parution */
givrRangListT givrListParu;
/* codes dep/loc/arr */
givrRefArrT givtrRefArr[6] = {{"11","075","05600",20,-1},{"82","069","12300",9,-1},{"93","013","05500",16,-1},{"11","075","99999",20,-1},{"82","069","99999",9,-1},{"93","013","99999",16,-1}};

/* objets publicitaires */
typedef struct
{
  int4  iRangTri;               /* indice de tri */
  int4  iOrdTri;                /* ordre dans l'indice de tri */
  int4  iRgLigne;               /* indice de ligne dans le bloc de référence */
  int4  iRgObj;                 /* indice de l'objet dans le bloc de référence */
}givrEltListObjT;

typedef struct
{
  /* nombre total */
  int4 iNbrTot;
  /* nombre de codes */
  int4 iNbr;
  /* nombre de valeurs du critère de tri */
  int4 iNbrTri;
  /* élément */
  givrEltListObjT trEltListObj[MAX_LIST];
  int4 trEltRangListObj[MAX_LIST];
}givrRangListObjT;
/* liste des objets */
givrRangListObjT givrListObj;

/* priorité des contenus */
typedef struct
{
  /* nombre de crc */
  int4 iNbr;
  /* élément */
  GYBrPrioCRCT trEltList[MAX_LIST_CRC];
  int4 trEltRangList[MAX_LIST_CRC];
}givrRangListCRCT;
int4 giviConflitCRC;
int4 giviNbCRC;
/* liste des CRC */
givrRangListCRCT givrListCRC;
/* type des contenus */
typedef struct
{
	char tcEtab[GYBIeinscLgEtab2]; /* etab */
  char tcType[GYBIamicLgTpdsob+1]; /* type */
  char tcThm[GYBIamicLgTpdsob]; /* theme */
}givrTypeContEtabT;
/* type des contenus prof */
typedef struct
{
	char tcEtab[GYBIeinscLgEtab2]; /* etab */
  char tcAn8[GYBIaprofLgCodan8 + 1]; /* an8 */
  char tcType[3]; /* type */
  char cIndic; /* présence de contenu */
}givrContProfEtabT;
/* liste des contenus par epj */
int4 giviNbContEtab;
givrTypeContEtabT givrListContEtab[MAX_LIST_CONT];
/* liste des contenus par epj et an8 */
int4 giviNbProfEtab;
givrContProfEtabT givrListProfEtab[MAX_LIST_CONT];

/* description dans PartEtab */
GYBrIapartT givtrPart[MAX_PARENT];
GYBstrIapartCleNavT givtcCleNav[MAX_PARENT];
int4 giviNbParentPart;
int4	giviRefPJDC;
int4 giviNbIapartPJDC;
int4 giviNbTupleIapart;


/*------------------------------Données exportées-----------------------------*/
extern char cDate[GYBIeBlocLgDateModBloc + 1];

/*------------------------------Données internes------------------------------*/
static int4 giviNumFic;
int4 giviEnrich = (int4)GIXCodeKO;
int4 giviCodRetEcr = (int4)GIXCodeOK;
nat2		usLgchamp	= 0;	/* longueur du champ a encoder */
nat2		usSaveLg	= 0;	/* longueur d'un sous ensemble TLV */
nat2		usSaveLgEns	= 0;	/* longueur d'un ensemble TLV */
nat2		usLgTotale	= 0;
nat2		usSaveLgTot	= 0;	/* longueur totale du mouvement CD hors compteur de longueur*/
/* GYBrParam_erreurT	vErreurSQL; */
char			cCodope[GYBMouvementsLgCodope+1];
char			cNumlot[GYBMouvementsLgNumlot+1];
char			cNummvt[GYBMouvementsLgNummvt+1];
char			cNumnat[GYBMouvementsLgNumnat+1];
/* buffer pour cryptage éventuel du nouveau numéro national */
char givcNumnat[128];
char			cNumlo[GYBMouvementsLgNumlo+1];
char			cNumls[GYBMouvementsLgNumls+1];
GYBstrBlocBlocidT       cBlocidPrec;   /* numero de bloc de parution précédent */
int1			cDrapeauEns;	/* Indicateur de presence d'au moins un ensemble */
int1			cDrapeauEnsDe;	/* Indicateur de presence d'au moins un ensemble de */
char			nogrou_sav[7+1]; /* num groupement à garder */
int4			indic_nbclones = 0; /* indicateur nb clones */
int4			resultat = 0;
int4			boolen = 0;  /* indicateur bloc non vide */
char			nom_bloc[50+1];                        /* Nom du bloc de parution                */
char			nom_bloc_ref[50+1];                        /* Référecne Nom du bloc de parution                */
int4                     num_bloc = 1;                        /* Numero bloc de parution */
int4                     iMaxBlocEcritAvant;
int4                     iMaxBlocEcritAvantIG;
static int4 GIVAnnulerBlocCGenTest; /* Annuler le bloc courant à cause d'un echec CGenTest */

EXEC SQL begin declare section;

typedef struct
{
	char tcPart[5];  /* partenaire */
  char tcProd [3];		/* produit fictif associé */
} givPartT;

typedef struct {
       char parution[5+1];                     /* dénomination_nt                    */
       char denomination[170+1];                /* dénomination_nt                    */
       int4 iRgDnom;
       char tcRgDnom[4+1];
       int4 iRgPrinc;                /* dénomination principale */
       char prenom[60+1];                      /* prénom                             */
       char initiale[20+1];                      /* initiale du prénom                             */
       char complement_denomination[120+1];     /* complément dénomination_nt         */
       char civilite[5+1];                     /* civilité                           */
       char sigle[40+1];                       /* sigle                              */
       char mots_determinants[60+1];           /* mots déterminants                  */
      char protection[1+1];                        /* protecion */
      char support[1+1];                        /* support */
      char datefinparu[10+1];                   /* date de fin de parution */
      char mention[1+1];                        /* mention */
      GYBstrIeinscIntlAnnotT tcIntlAnnot;     /* annotation intitulé */
} INTITULE;


typedef struct {
       char rpart[29+1];                    /* partenaire */
       char prod[2+1];                      /* type de produit fictif associé */
       char parent[25+1];
       char idmed[50+1];
       char isdoc[6+1];
       char typepart[1+1];
       char codan9[8+1];                    /* code rubrique AN9 */
       char clenav[50+1];                    /* clé de navigation */
       int4 iForPJDC;
       int4 iRgParent;
       int4 iNbParent;
       } Tab_part;


typedef struct {
  char etab[9+1];/* etab  */
  char etab_dc[9+1];/* etab  */
  char siret[14+1];/* siret */
  char naf[5+1];/* naf */
  Tab_part trpart[1000];/* partenaires */
  int4 iNbPart;
  int4 iBLEPJProf; /* black-listage */
  char opphoto;
  char parinsee;
} A_CLASSER;
typedef struct {
       char val_codan9[8+1];                    /* code rubrique AN9 */
       char val_codan8[6+1];                    /* code rubrique AN8 */
       char orig;                               /* origine */
       char nature [3+1];
       char paru;                               /* parution pour UV */
       char dnex;                               /* inversion pour denom + prenom pour denom exacte */
       } Tab_an9;


typedef struct {
  int4 iNban9;
       Tab_an9 Tan9[MAX_AN9];
       char mogmoi[500+1];                      /* _nt                                   */
       char mpg[30+1];
       char mendom[250+1];                      /* mention de domiciliation */
       char depact[3+1];               /*   dept activité                                */
       char locact[5+1];               /*   loc activité                                */
  char arract[2+1];               /* arrondissement d'activiteé */
} RUBRIQUES;

typedef struct {
  char acCodCrc[16+1];                    /* code crc */
  char acLibCrc[50+1];                    /* code crc */
  char acNavCrc[10+1];                    /* code crc */
  int4  iLu;                               /* indicateur de lecture */
} Tab_crc;


typedef struct {
       Tab_crc trCrc[MAX_CRC];
       int4 iNbCrc;
       } CRC;


typedef struct {
       char longitude[10+1];                /*_nt                                   */
       char latitude[10+1];                /*_nt                                   */
       char precision[2+1];                 /*                                   */
       char precMappy[30+1];                  /*                                   */
       } GEOLOC;

typedef struct {
       char parution[4+1];               /*                                   */
       int4 irangadr;
       char numero_voie[4+1];               /*                                   */
       char complt_num_voie[1+1];           /*                                   */
       char lib_complt_num_voie[30+1];       /*                                   */
       char code_voie[6+1];                 /*                                   */
       char lib_code_voie[50+1];             /*nt                                   */
       char type_voie[4+1];                 /*                                   */
       char libel_voie[100+1];                /*                                   */
       char adrnr[120+1];                     /*                                   */
       char lieue_ae[120+1];                  /*                                   */
       char arrondissement[2+1];            /*                                   */
       char code_postal[5+1];               /*                                   */
       char code_cedex[5+1];                /*                                   */
       char lib_cedex[50+1];                /*                                   */
       char boite[6+1];                     /*                                   */
       char ipays[2+1];                     /*                                   */
       char ensemble_batiment[120+1];         /*                                   */
       char instal[8+1];                      /*
                                             */
       char libinstal[50+1];                 /*
 */
       char libinstact[50+1];                 /*
                                             */
       GEOLOC geoloc;                       /*                                   */
       GEOLOC centreloc;                       /*                                   */
       } ADRESSE;


typedef struct {
       char numero_com[4+1];         /*                                   */
       char  designation_ligne[100+1];         /*                                   */
       char numero[50+1];                    /*nt                                   */
       char numero_parution[128+1];           /*                                   */
       char code_produit[5+1];              /*                                   */
       char code_produit_etd[5+1];              /*                                   */
       char equiptel[3+1];                  /*                                   */
       char servtel[3+1];                   /*                                   */
       char tarifart[3+1];                  /*                                   */
       char operateur[4+1];                 /*                                   */
       char tarif_exact[100+1];               /*nt                                   */
       char email[2000+1];                     /*                                   */
       char mnemonique[60+1];                /*                                   */
       char url[500+1];              /* url */
       int4  typurl;
       char numrg[16+1];              /* RG */
       char indrg[3+1];              /* RG */                                         char lamarque[60+1];              /*marque */
       char laqualite[50+1];              /* qualité */
       char cteutil[10+1];         /* compte utilisateur */
       char nomsupplement[170+1];         /* nom supplémentaire */
       char msknum[1+1];         /* masque numéro */
       char mskmel[1+1];         /* masque mel */
       char datcu[10+1];         /* date CU */
       char catnum[1+1];           /* catégorie de numéro */
                                    } MOYEN_DE_COMMUNICATION;


typedef struct {
       char statut[50+1];               /*                                   */
       char val_num[50+1];               /*                                   */
       char val_lo[4+1];               /*                                   */
       char val_ls[4+1];               /*                                   */
       char val_lols[4+1];               /*                                   */
       char val_lslo[4+1];               /*                                   */
       char trace_bloc[27+1];
       char val_grp[10+1];               /*                                   */
       char val_seq[20+1];               /*                                   */
  char val_seqLO[20+1];
  char val_seqLS[20+1];
       char val_tri1[22+1];               /*                                   */
       char val_tri2[22+1];               /*                                   */
  char cCoddep [3+1];
  char cCodloc [5+1];
  char cLocFus [5+1];
  char cArrond [2+1];
  char cReg    [2+1];
  char cAncReg    [2+1];
  char cDeppar [3+1];
  char cLocpar [5+1];
  char cArrpar [2+1];
       ADRESSE adresse;               /*                                   */
       MOYEN_DE_COMMUNICATION moyen_de_com;  /*                                   */
       } INSCRIPTION;

typedef struct {
       char id[50+1];               /*                                   */
       char type[3+1];               /*                                   */
       char stype[3+1];               /*                                   */
       } NOYAU;


typedef struct {
       char id[50+1];               /*                                   */
       char type[3+1];               /*                                   */
       char stype[3+1];               /*                                   */
       } MODULE;


typedef struct {
       char id[50+1];               /*                                   */
       char type[3+1];               /*                                   */
       char stype[3+1];               /*                                   */
       char sstype[3+1];               /*                                   */
       int4 iCont;
       int4 iRgObj;
       char tcRgObj[4+1];
       char tcdatact[GYBPemicLgDatmod + 1];   /* date dernière activation (DDMMYYYY) */
       char  valeur[GYBLgLienValeur * 2];
       int4 iCVI;
       char stypcvi[3+1];               /*                                   */
       char stypint[3+1];               /*                                   */
       } MICRO;


  typedef struct {
       NOYAU noyau[30+1];
       MODULE module[30+1];
       MICRO micro[100+1];
       int4 nb_micro;
       char libUrlSite[GYBIeinscLgLibUrl2 * 4];
       char libUrlGCpt[GYBIeinscLgLibUrl2];
       } OBJETS_PUB;


typedef struct {
       char numero_bloc_parution [100+1];     /*                                   */
       char numero_bloc_parution_ref [100+1];     /*                                   */
       char numero_client [16+1];            /*                                   */
       INTITULE intitule;            /*                                   */
       A_CLASSER a_classer;          /*                                   */
       RUBRIQUES rubriques;          /*                                   */
       INSCRIPTION inscription[1];     /*                                   */
       OBJETS_PUB  objets_pub;         /*                                   */
       CRC         crc;
       } VALUE;


  typedef struct {
      char marque[100+1];               /*                                   */
      } Tab_marque;


  typedef struct {
       char designation_ligne[100+1];             /*                                   */
       } Tab_designation_ligne;

  typedef struct {
       char module[300+1];             /*                                   */
       } Tab_module;
  typedef struct {
      char stype[1+1];               /*                                   */
  } Tab_sug_produit;

typedef struct {
  char prestation[30+1];               /*                                   */
} Tab_sug_prestation;

typedef struct {
  char service[30+1];               /*                                   */
} Tab_sug_service;

typedef struct {
  int4 iIndice;
  int4 iRang;
  int4 iGeoLoc;
  int4 iDblGeoLoc;             /* géographie tenant compte des doubles */
  int4 iSource;
  char cNature;
  char cIndPart;
  char cPubPrinc;
  char indicateur_selection[20+1];
  char parution_id [100+1];
  char parution_id_ref [100+1];
  VALUE value;
  char parution[30];
  char resume[30];
  char denomination[170+1];
  char qualite[30];
  Tab_marque Tmarque[100];
  char mots_esplus[3+1];
  char mots_web[3+1];
  Tab_sug_produit Tsug_produit[1];
  Tab_sug_prestation Tsug_prestation[1];
  Tab_sug_service Tsug_service[1];

}GYBrDOCUMENT;

EXEC SQL end declare section;

/*---------------------------------------- Fonctions internes -----------------------------------------------------------*/
int4 giv_ecrit_partie_3_geo (char **buf_pos_in, GYBrDOCUMENT *docClone, int4 iInit, int4 iRangTri, int4 iTypeLoc, int4 iValLoc, char *pcBalise);

/* Tableau pour la sauvegarde des n documents associés à un groupement */
GYBrDOCUMENT doc2[GIV_TAILLE_MAX_EPJ];
/* Tableau pour concaténation des DL des clones */
char  buf_concat[50000];
/* taille fichier de sortie XML en blocs de parution */
static int4 giviNbBlocs;
/* flag fermeture du fichier */
static int4 giviClose = (int4)GIXCodeKO;

/* Buffer pour ecriture dans le fichier XML */
/* La plus grosse ecriture a lieu par la fonction 'givBlocsClones' , attention risque debordement ! */
char GIVBuffXML[800000];
/* Buffer intermédiaire pour traduction */
char GIVBuffInter[800000];
/* Buffer intermédiaire pour analyse clob */
char GIVBuffClob[800000];
/* Buffer complet pour appel API de Cas de Tests */
char GIVBuffTest[giv_LG_BUFFTEST];
/* fichier des etablissements perdus */
FILE *GIVfDescFicETB;
/* fichier des conflits de contenus */
FILE *GIVfDescFicCFLT;
/* fichier des Photos de PVI */
FILE *GIVfDescFicPhotos;

/* clob pour lecture de données en XMLType */
static OCIClobLocator   * givprClob = NULL;
static OCIClobLocator   * givprDbl1Clob = NULL;
static OCIClobLocator   * givprDbl2Clob = NULL;

static int4 nb_noyau;
static int4 nb_module;
static int4 nb_micro;
static int4 nb_an9;
static int4 nb_marque;
/* static int4 nb_designation_ligne = 0; */
static int4 nb_inscription = 0;

static int4 num_id = 0;                        /* Numero identifiant parution */

static int4 obtention_iden = 0;			/* Flag pour traitement unique */
char    givcCheminBloc[128] = "";               /* Pathname des fichiers utilises */
char    givcRepertoire[128] = "";               /* Répertoire des fichiers utilises */

static char remplace_espace[5+1];              /* Le premier car. va remplacer l'espace selon Reg_Sel_19 */

 static char memo_chaine_pjparutionid[100+1];        /* Memorisation de la chaine identifiant parution */

 static int4 pos_paru_id;                        /* Position pour écriture parution id */
char    givtcRepSgiPro[128] = "";           /* Pathname des fichiers SGIPRO */
char    givtcRepMpg[128] = "";           /* Pathname des fichiers du flux MPG */
char    givtcRegCECI[4] = "";        /* anciennes/nouvelles régions du CECI */
char    givtcLocArrInst[60] = "";           /* Localités à parution sur arrondiseement d'installation */
char    givtcPrioCont[GWT_LG_MAX_LIGNE+1] = "";             /* liste des contenus prioritaires */
char    givtcExceptCont[GWT_LG_MAX_LIGNE+1] = "";             /* liste des exceptions sur les contenus */
char    givtcObjCont[GWT_LG_MAX_LIGNE+1] = "";             /* liste des objets contenu */
char    givtcFourPart[GWT_LG_MAX_LIGNE+1] = "";             /* liste des partenaires à éliminer */
char    givtcContenu[4] = "";             /* validation des objets contenu */
char    givtcRapED[5] = "";               /* rapprochement ED */
char    givcTriPub[2];
char    givtcAnMes[512] = "";             /* liste des objets contenu */
char    givtcSupCplDen[4] = "";             /* qualite dans complement de denom */
char    givtcInvDenPn[4] = "";             /* inversion ordre denom prenom */
char    givtcGeneIeBlocCRC[4] = "";        /* accès à la table GYTtabIeBLocCRC */
char    givtcGeneAffCRC[4] = "";        /* affichage de la table GYTtabIeBLocCRC */
char    givtcPartInsc[4] = "";        /* affichage partenaire au niveau inscription */
char    givtcClause[GWT_LG_MAX_LIGNE];
char    givtcVersDoc[GWT_LG_MAX_LIGNE]; /* version commune configurée des documents */
char    givtcParuInscEpj[4] = "";        /* affichage des parutions par inscription et par epj */
char    givtcContText[4] = "";        /* affichage balises contenu et text */
/* origine de partenaire */
int4 giviPart;
static char   givtcOriPart[4 + 1] = "";
static char   givtcAn9Part[GYBPaprofLgCodan9 + 1] = givcR00000000;
static char   givtcAn8Part[GYBPaprofLgCodan8 + 1] = "";

/* Declaration et reservation du document necessaire a la creation d'un bloc XML */
static GYBrDOCUMENT doc;

/* Correspondance entre les chiffres et les caractères de codage */
/* du numéro de client dans le champ LO */
static const nat1 givtcCLIENTLO[] = {
/*        0     1     2     3     4     5     6     7     8     9  A B C D E F*/
/* 0 */ 0x41, 0x3B, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A,0,0,0,0,0,0,
/* 1 */ 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54,0,0,0,0,0,0,
/* 2 */ 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64,0,0,0,0,0,0,
/* 3 */ 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,0,0,0,0,0,0,
/* 4 */ 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,0,0,0,0,0,0,
/* 5 */ 0x79, 0x7A, 0xC4, 0xCB, 0xCF, 0xD6, 0xDC, 0xE4, 0xEB, 0xEF,0,0,0,0,0,0,
/* 6 */ 0xF6, 0xFC, 0xFF, 0xC2, 0xCA, 0xCE, 0xD4, 0xDB, 0xE2, 0xEA,0,0,0,0,0,0,
/* 7 */ 0xEE, 0xF4, 0xFB, 0xE0, 0xE9, 0xE8, 0xF9, 0xE7, 0xB5, 0x7E,0,0,0,0,0,0,
/* 8 */ 0x5E, 0xA8, 0xB0, 0xB2, 0x2B, 0x2D, 0x23, 0x3D, 0x2C, 0x2F,0,0,0,0,0,0,
/* 9 */ 0x40, 0x7B, 0x7D, 0x28, 0x29, 0xA7, 0xA3, 0x3F, 0x21, 0x3A,0,0,0,0,0,0,
/* A */    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
/* B */    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
/* C */    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
/* D */    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
/* E */    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
/* F */    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
                                };
/* ASCII numérique */
#define giv_Min 0x30
#define giv_Max 0x39

int1 cTabRefClone[] = {1,3,2,5,4
};

#define giv_open "open"
#define giv_write "write"
#define giv_close "close"

#define givNbCVI 9
#define givNbFixeCVI 4
static char	* givTabCVI[givNbCVI] = {
	" T","NT","NV","NS"," P","KT","KV","KS","NM"
};
#define givNbPart 8
static givPartT givTabPart[givNbPart] = {
	{"RESA","0C"},
	{"EXPD","0E"},
	{"LAFO","0L"},
	{"ACCO","0A"},
	{"CRDV","0R"},
	{"LEAD","0F"},
	{"CHRO","0O"},
	{"PJDC","0D"}
};

/* commentaire XML */
char cComm_xml0[] = "<!-- ";
char cComm_xml1[] = " -->";

/*-----------------------------Fonctions internes-----------------------------*/

/* HAL, 13/11/2008 pour Linux : ajout des déclarations des fonctions qui sont utilisées avant leur déclaration */
static int4 giv_sortie (char **, FILE *);
static int4 giv_sortie_ISO (char **, FILE *);
static int4 giv_fichier_sortie (char **, FILE **);
static int4 giv_fermeture_fichier_sortie (char **, char *);
static int4 giv_ecrit_noeud_simple (char *, char *);
static int4 giv_ecrit_noeud_attr(char *, char *, char *);
static int4 giv_ecrit_fin_noeud (char **, char *);
static int4 givAnalyseContenu (char **, GYBrDOCUMENT *, int4);
static int4 givEcritContenu (char *, char **, GYBrDOCUMENT *, int4, int4*);
static int4 givEcritContenuED (char **, GYBrDOCUMENT *, int4);
static int4 givEcritContenuEDEtab (char *, char **, GYBrDOCUMENT *, int4);
static int4 givEcritDonAdd (char *, char **, GYBrDOCUMENT *, int4);
static int4 givEcritDonRelais (char **, GYBrDOCUMENT *, int4, int4);
static int4 givEcritDonEnr (char **, GYBrDOCUMENT *, int4);
static int4 givEcritSgiPro (char **, GYBrDOCUMENT *, int4, int4, int4, char*, int4);
static int4 givEcritSgiProED (char *, char *, char **, char *, GYBrDOCUMENT *, char *, char *, char *, int4 *);
static int4 givEcritSgiProPart (char **, GYBrDOCUMENT *, char *, char *, char *, char *, int4 *);
static int4 givEcritSgiProPartEtab (char **, GYBrDOCUMENT *,int4 , char *, char *, char *, char *, int4 *);
static int4 givEcritSgiProBOC (char **, GYBrDOCUMENT *, int4, char *, char *, char *);
static int4 givEcritImages (char **, GYBrDOCUMENT *, int4);
static int4 givEcritDonAnnonceur (char **, GYBrDOCUMENT *, int4, int4, int4, char*, int4);
static int4 givEcritDonEtab (char *, char*, char **, char *, GYBrDOCUMENT *, char *, char *, char *, int4 *);
static int4 givAffCRCEtab (char **);
static int4 givDelIeBlocCRC (char *);
static int4 givInsIeBlocCRC (void);
static int4 givMutualiserDonPartenaires (char **, GYBrDOCUMENT *, int4);
static int4 givEcritPart (char **, GYBrDOCUMENT *, int4);
static int4 giv_ecrit_balise (char *, char *, char *);
static int4 giv_ecrit_balise_epj (char **, char *, char *);
static int4 giv_ecrit_balise_iso (char *, char *, char *);
static int4 giv_ecrit_objet_pub (char **, GYBrDOCUMENT *, int4, int4, char *);
static int4 giv_ecrit_element (char *, char *, char *);
static int4 givAnalyseCRC (char *, int4, GYBrDOCUMENT *, char *, char*, char*);
static int4 givAnalyseObjetXML (char *, GYBrDOCUMENT *, char *, char **);
static int4 givEcritDonHoraires (char **, GYBrDOCUMENT *, int4);

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givTradChar                                                    */
/*                                                                            */
/* But       : remplacer un caractère dans le buffer de sortie                */
/*                                                                            */
/* Entree(s) : le buffer                                                      */
/*                                                                            */
/* Sortie(s) : le même buffer                                                 */
/*                                                                            */
/*----------------------------------------------------------------------------*/

void givTradChar(int4 *lg)
{

  char *pt_fin_liste;
  char *pt_debut_element;
  char *pt_fin_element;
  char *pt_ecriture;
  int4 lg_element;
  size_t lgInter, lg_in;
  iconv_t iConv;
  char * buf_in;
  char * buf_out;

  /* Effacement du buffer */
  /* Buffer intermédiaire */
  memcpy(GIVBuffInter, GIVBuffXML, strlen(GIVBuffXML));
  GIVBuffInter[strlen(GIVBuffXML)] = '\0';
  GWTTrace (GWT_NIV_FONCT, ("Lgs: %d,%d,%d\n",*lg,strlen(GIVBuffXML),strlen(GIVBuffInter)));
  /* Effacement du buffer */
  GIVBuffXML[0] = '\0';

  pt_fin_liste = GIVBuffInter + *lg;
  pt_ecriture = GIVBuffXML;
  for (pt_debut_element = GIVBuffInter; pt_debut_element < pt_fin_liste; )
  {
    pt_fin_element=strchr(pt_debut_element, '&');
    if (pt_fin_element == 0)
    {
      pt_fin_element = pt_fin_liste;
    }
    lg_element = pt_fin_element-pt_debut_element;
    /* traduction */
    if ((GIVBuffInter != pt_debut_element) || (GIVBuffInter == pt_fin_element))
    {
      GWTTrace (GWT_NIV_FONCT, ("Traduction & \n"));
      GWTTrace (GWT_NIV_FONCT, ("Lg Traduction totale &: %d\n",*lg));
      GWTTrace (GWT_NIV_FONCT, ("Lg Traduction &: %d\n",lg_element));
      strcpy(pt_ecriture, givTrad);
      pt_ecriture += strlen(givTrad);
    }

    /* copie chaîne non modifiée */
    memcpy(pt_ecriture, pt_debut_element, lg_element);
    pt_ecriture = pt_ecriture + lg_element;
    *pt_ecriture = '\0';
    pt_debut_element=pt_fin_element+1;
  }
  *lg = strlen(GIVBuffXML);

  /* Traduction UTF8 */
  iConv = iconv_open ("UTF-8","ISO8859-1");
  buf_in = GIVBuffXML;
  lg_in = strlen(GIVBuffXML)+1;
  buf_out = GIVBuffInter;
  lgInter = sizeof(GIVBuffInter);

  if ((iconv_t)(-1) != iConv)
  {
    iconv(iConv, &buf_in, (size_t *)&lg_in, &buf_out, (size_t *)&lgInter);
    iconv_close(iConv);
    strcpy(GIVBuffXML, GIVBuffInter);
    GWTTrace (GWT_NIV_FONCT, ("Fin de Conversion UTF8: %d, %d\n",lgInter,strlen(GIVBuffXML)));
  }

  *lg = strlen(GIVBuffXML);

  return;
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givConvClob                                                    */
/*                                                                            */
/* But       : traitement UTF8, carcatères spéciaux d'un XMLType              */
/*                                                                            */
/* Entree(s) : le buffer                                                      */
/*                                                                            */
/* Sortie(s) : le même buffer                                                 */
/*                                                                            */
/*----------------------------------------------------------------------------*/

void givConvClob()
{
  size_t lgInter, lg_in;
  iconv_t iConv;
  char * buf_in;
  char * buf_out;


      (void)strcpy(GIVBuffXML,GIVBuffInter);
      /* Traduction UTF8 */
      iConv = iconv_open ("UTF-8","ISO8859-1");
      buf_in = GIVBuffXML;
      lg_in = strlen(GIVBuffXML)+1;
      buf_out = GIVBuffInter;
      lgInter = sizeof(GIVBuffInter);
      if ((iconv_t)(-1) != iConv)
      {
        iconv(iConv, &buf_in, (size_t *)&lg_in, &buf_out, (size_t *)&lgInter);
        iconv_close(iConv);

	/* Mantis 70297 : remplacement des caractères spéciaux par leur chaîne UTF8	*/
	/* (les caractères Laquo et Raquo sont éliminés en amont par PJ)		*/
	gwtRemplaceChaine(GIVBuffInter, GXW_cg_Euro, GXW_utf8_Euro, GIVBuffXML);
	gwtRemplaceChaine(GIVBuffXML,   GXW_cg_OE,   GXW_utf8_OE,   GIVBuffInter);
	gwtRemplaceChaine(GIVBuffInter, GXW_cg_oe,   GXW_utf8_oe,   GIVBuffXML);
	gwtRemplaceChaine(GIVBuffXML, GXW_cg_Copyright,   GXW_utf8_Copyright,   GIVBuffInter);
	gwtRemplaceChaine(GIVBuffInter, GXW_cg_Nbsp,   GXW_utf8_Nbsp,   GIVBuffXML);
	gwtRemplaceChaine(GIVBuffXML,   GXW_cg_Laquo, GXW_utf8_Laquo, GIVBuffInter);
	gwtRemplaceChaine(GIVBuffInter, GXW_cg_Raquo, GXW_utf8_Raquo, GIVBuffXML);
	(void)strcpy (GIVBuffInter, GIVBuffXML);

        GWTTrace (GWT_NIV_FONCT, ("Fin de Conversion UTF8: %d, %d\n",lgInter,strlen(GIVBuffInter)));
      }
  GIVBuffXML[0] = '\0';

  return;
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givConvURL                                                   */
/*                                                                            */
/* But       : traitement UTF8, carcatères spéciaux d'une URL                 */
/*                                                                            */
/* Entree(s) : le buffer                                                      */
/*                                                                            */
/* Sortie(s) : le même buffer                                                 */
/*                                                                            */
/*----------------------------------------------------------------------------*/

void givConvURL(char *acLibUrl)
{
  size_t lgInter, lg_in;
  iconv_t iConv;
  char * buf_in;
  char * buf_out;
  int4 i,j;

  buf_concat[0] = '\0';
    /* traduction de <,> et " */
    j = 0;
    for(i=0; i<strlen(acLibUrl); i++)
    {
      if ( '<' == acLibUrl[i])
      {
      	buf_concat[j] = '\0';
      	strcat(buf_concat,"&lt;");
        j = strlen(buf_concat);
      }
      else if ( '>' == acLibUrl[i])
      {
      	buf_concat[j] = '\0';
      	strcat(buf_concat,"&gt;");
        j = strlen(buf_concat);
      }
      else if ( '"' == acLibUrl[i])
      {
      	buf_concat[j] = '\0';
      	strcat(buf_concat,"&quot;");
        j = strlen(buf_concat);
      }
      else if ( '&' == acLibUrl[i])
      {
      	buf_concat[j] = '\0';
      	strcat(buf_concat,givTrad);
        j = strlen(buf_concat);
      }
      else
      {
        buf_concat[j] = acLibUrl[i];
        j++;
      }
    }
    buf_concat[j] = '\0';
    /* Traduction UTF8 */
    iConv = iconv_open ("UTF-8","ISO8859-1");
    buf_in = buf_concat;
    lg_in = strlen(buf_concat)+1;
    buf_out = GIVBuffInter;
    lgInter = sizeof(GIVBuffInter);

    if ((iconv_t)(-1) != iConv)
    {
      iconv(iConv, &buf_in, (size_t *)&lg_in, &buf_out, (size_t *)&lgInter);
      iconv_close(iConv);
      strcpy(buf_concat, GIVBuffInter);
      GWTTrace (GWT_NIV_FONCT, ("Fin de Conversion UTF8: %d, %d\n",lgInter,strlen(buf_concat)));
    }

  return;
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givLectClob                                                    */
/*                                                                            */
/* But       : lecture d'un clob en varchar                                   */
/*                                                                            */
/* Entree(s) : clob                                                           */
/*                                                                            */
/* Sortie(s) : buffer                                                         */
/*                                                                            */
/*----------------------------------------------------------------------------*/

void givLectClob(OCIClobLocator * apClob,char *apcEtab, char *apcObj, char *apcTyp, char *apcSource)
{
  int4 iCodRet = GWCCodeOK;    /* Code retour de la fonction */
  int4 iIntRet = GWCCodeOK;    /* Code retour des appels internes */
  EXEC SQL begin declare section;
  OCIClobLocator * pOraClob;
  int4 iLgEcrit = 0;
  nat8 length;
  nat8 lgthmax;
  VARCHAR tcXMLTexte[giv_LG_CLOB+1];
  EXEC SQL end declare section;
  GYBrParam_erreurT	vErreurSQL;   /* Traitement des erreurs SQL */

      /* lecture du début de bloc */
      (void)strcpy(vErreurSQL.acOrdre_sql,"Lecture dans CLOB");
      iIntRet = (int4)GYBok;
      length = 0;
      lgthmax = giv_LG_CLOB;
    	iLgEcrit = 0;
      pOraClob = apClob;
      GIVBuffInter[0] = '\0';
      while (((int4)GYBok == iIntRet) && (NULL != pOraClob))
      {
        tcXMLTexte.arr[0] = '\0';
        tcXMLTexte.len = giv_LG_CLOB;
        EXEC SQL LOB READ :length FROM :pOraClob INTO :tcXMLTexte WITH LENGTH :lgthmax;

        iIntRet = GIVBlocErreur (&vErreurSQL);

        GWTTrace (GWT_NIV_FONCT, ("Taille lob lue: %d,%d,%d\n",iIntRet,length,tcXMLTexte.len));
        /* Analyse du code resultat SQL */
        if (((int4)GYBok != iIntRet) && ((int4)GYBnodata != iIntRet))
        {
          GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur : [COD=%d TXT=%s]\n",
                   iIntRet,
                   vErreurSQL.acOrdre_sql));
          GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur lecture Clob: Epj='%s' Obj='%s' Typ='%s' Src='%s'\n",
                   apcEtab, apcObj, apcTyp, apcSource));

           iIntRet = (int4)GYBnok;
         }
        else
        {
          tcXMLTexte.arr[tcXMLTexte.len] = '\0';
          GWTTrace (GWT_NIV_FONCT, ("Debut lob lu: !%c,%c,%c!\n",tcXMLTexte.arr[0],tcXMLTexte.arr[1],tcXMLTexte.arr[2]));
          GWTTrace (GWT_NIV_FONCT, ("Fin lob lu: !%s!\n",&tcXMLTexte.arr[tcXMLTexte.len-5]));
          /* suppression de l'indentation */
          if ((int4)sizeof(GIVBuffInter) <= (iLgEcrit +(int4)tcXMLTexte.len))
          {
          	/* fin car buffer insuffisant */
            GWTTrace (GWT_NIV_GRAVE,
                  ("Buffer lecture Clob insuffisant : Epj='%s' Obj='%s' Typ='%s' Src='%s'\n",
                   apcEtab, apcObj, apcTyp, apcSource));
            GWTTrace (GWT_NIV_GRAVE, ("Taille Clob lue: %d,%d,%d,%d\n",iIntRet,length,tcXMLTexte.len,iLgEcrit));
          	iIntRet = (int4)GYBnok;
          }
          else
          {
            (void)GIWSuppIndent ((char *)tcXMLTexte.arr, &GIVBuffInter[iLgEcrit]);
            iLgEcrit = strlen(GIVBuffInter);
          }
          if ((int4)GYBnodata == iIntRet)
          {
            /* fin de lecture */
            iIntRet = (int4)GYBnok;
          }
        }
      }

  return;
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : GIVCodeClient                                                  */
/*----------------------------------------------------------------------------*/
int4 GIVCodeClient ( char *cClient, int4 lg_chp )
{
  int4 iLong = 0;
  int4 iVal,i = 0;
  int4 iCodRet = (int4)GWCCodeOK;
  char client_decode[14+1]="";  /* numlo ou IG decode pr bloc de parution */

  for (i=0;i<lg_chp;i++)
  {
    if ( (cClient[i] >= giv_Min) && (cClient[i] <= giv_Max ))
    {
      strcpy (client_decode, cClient);
      break;
    }
  }

  if (lg_chp == i)
  {
    while (iLong < lg_chp )
    {
      iVal = 0;
      while (((nat1)(cClient[iLong]) != givtcCLIENTLO[iVal]) && (256 != iVal))
      {
        iVal++;
      }
      if ( iVal == 256)
      {
        GWTTrace (GWT_NIV_FONCT,
                  ("Erreur ne retrouve pas la valeur ...\n"));
        iCodRet = (int4)GWCCodeKO ;
      }
      client_decode[(iLong*2)+1] = (char)((iVal % giv_DIV_PAR_DIX) + '0');
      iVal = iVal / giv_DIV_PAR_DIX;
      client_decode[(iLong*2)] = (char)((iVal % giv_DIV_PAR_DIX) + '0');
      iLong++;

    }
  }
  GWTTrace (GWT_NIV_FONCT,
            ( "client_decode = %s\n", client_decode ));
  strcpy ( GIVtcClientDecode,client_decode);

  return(iCodRet);

}
/*---------------------fin fonction-------------------------------------------*/


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givReprise ()                                                  */
/*                                                                            */
/* But       : offset de reprise                                              */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 givReprise (void)
{
  int4 iCodRet = GWCCodeOK;     /* Code retour de la fonction */
  fpos_t rOffset;
		/* HAL : fonction modifiée pour Linux : fpos_t est un entier sous AIX, une structure sous Linux	*/
		/* fpos64_t a été remplacé par fpos_t, et fgetpos64 a été remplacé par fgetpos			*/

  if (NULL != GIVfDescFicMCD)
  {
    iCodRet = (int4)fgetpos(GIVfDescFicMCD, &rOffset);
    if ((int4)GWCCodeOK != iCodRet)
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur offset reprise  %d\n",iCodRet));
    }
  }
  else
  {
    rOffset.__pos = 0;
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur offset reprise \n"));
  }

  GWTTrace (GWT_NIV_FONCT,
            ("Offset reprise  %10.0f\n",(double)rOffset.__pos));

  return(iCodRet);
}


/*----------------------------------Fonction----------------------------------*
 * Fonction :  givCompListObj
 *
 * But : Comparaison des objets publicitaires
 *
 * Description : comparaison Iamic
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres :
 *
 *	Valeurs retournées :
 *
 *	Erreurs :
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Jan/29/2008  (mb)
 *
 * Modification   (MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

static int4 givCompListObj(const void *apList1, const void *apList2)
{
  /** code retour des fonctions appelées */
  int4 iRetour;
  /** pointeur sur le rang du premier code à comparer */
  int4 iList10, iList1, iObj1;
  /** pointeur sur le rang du second code à comparer */
  int4 iList20, iList2, iObj2;

  /** Initialisation des pointeurs */
  iList10 = *(int4 *)apList1;
  iList20 = *(int4 *)apList2;
  iList1 = givrListObj.trEltListObj[iList10].iRgLigne;
  iList2 = givrListObj.trEltListObj[iList20].iRgLigne;
  iObj1 = givrListObj.trEltListObj[iList10].iRgObj;
  iObj2 = givrListObj.trEltListObj[iList20].iRgObj;
  iRetour = strcmp((doc2+iList1)->value.objets_pub.micro[iObj1].type,(doc2+iList2)->value.objets_pub.micro[iObj2].type);
  if (0 != iRetour)
  {
    return(iRetour);
  }
  iRetour = strcmp((doc2+iList1)->value.objets_pub.micro[iObj1].stype,(doc2+iList2)->value.objets_pub.micro[iObj2].stype);
  if (0 != iRetour)
  {
    return(iRetour);
  }
  iRetour = strcmp((doc2+iList1)->value.objets_pub.micro[iObj1].id,(doc2+iList2)->value.objets_pub.micro[iObj2].id);
  if (0 != iRetour)
  {
    return(iRetour);
  }
  if ((0 != strcmp((doc2+iList1)->value.objets_pub.micro[iObj1].stype,"VI"))
  	&& (0 != strcmp((doc2+iList1)->value.objets_pub.micro[iObj1].stype,"FI"))
  	&& (0 != strcmp((doc2+iList1)->value.objets_pub.micro[iObj1].stype,"IN")))
  {
    iRetour = strcmp((doc2+iList1)->value.objets_pub.micro[iObj1].sstype,(doc2+iList2)->value.objets_pub.micro[iObj2].sstype);
  }
  else
  {
  	/* video stand alone moins prioritaire */
    if ((0 == strcmp((doc2+iList2)->value.objets_pub.micro[iObj2].sstype,"VS"))
  	|| (0 == strcmp((doc2+iList2)->value.objets_pub.micro[iObj2].sstype,"VF"))
  	|| (0 == strcmp((doc2+iList2)->value.objets_pub.micro[iObj2].sstype,"VE")))
    {
    	return(-1);
    }
    else
    if ((0 == strcmp((doc2+iList1)->value.objets_pub.micro[iObj1].sstype,"VS"))
  	|| (0 == strcmp((doc2+iList1)->value.objets_pub.micro[iObj1].sstype,"VF"))
  	|| (0 == strcmp((doc2+iList1)->value.objets_pub.micro[iObj1].sstype,"VE")))
    {
    	return(1);
    }
    iRetour = strcmp((doc2+iList1)->value.objets_pub.micro[iObj1].sstype,(doc2+iList2)->value.objets_pub.micro[iObj2].sstype);
  }
  if (0 != iRetour)
  {
    return(iRetour);
  }
  else
  {
    iRetour = (int4) iList10 - iList20;
    return(iRetour);
  }
}

/*----------------------------------Fonction----------------------------------*
 * Fonction :  givAjoutListCRC
 *
 * But : Ajout de crc
 *
 * Description : ajout crc dans liste si absent
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres :
 *
 *	Valeurs retournées :
 *
 *	Erreurs :
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Nov/18/2013  (mb)
 *
 * Modification   (MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/
static int4 givAjoutListCRC(GYBrPrioCRCT rPrioCRC)
{
  /** code retour des fonctions appelées */
  int4 iCodRet;
  int4 i;

  iCodRet = (int4)GIXCodeOK;
  for(i=0; i<givrListCRC.iNbr; i++)
  {
    if ((0 == strcmp(rPrioCRC.acEtab,givrListCRC.trEltList[i].acEtab)) &&
        (0 == strcmp(rPrioCRC.acTpdsob,givrListCRC.trEltList[i].acTpdsob)) &&
        (0 == strcmp(rPrioCRC.acCRC,givrListCRC.trEltList[i].acCRC)) &&
        (0 == strcmp(rPrioCRC.acCodan8,givrListCRC.trEltList[i].acCodan8)) &&
        (0 == strcmp(rPrioCRC.acType,givrListCRC.trEltList[i].acType)) &&
        (rPrioCRC.iPrioCRC == givrListCRC.trEltList[i].iPrioCRC))
    {
      /* crc en double */
      break;
    }
  }

  giviNbCRC = givrListCRC.iNbr;
  if ((MAX_LIST_CRC == giviNbCRC) && (givrListCRC.iNbr == i))
  {
    iCodRet = (int4)GIXCodeKO;
    GWTTrace (GWT_NIV_GRAVE,(" Nombre de ref CRC atteint %d\n",giviNbCRC ));
  }
  else if (givrListCRC.iNbr == i)
  {
      (void)strcpy (givrListCRC.trEltList[giviNbCRC].acTpdsob,rPrioCRC.acTpdsob);
      (void)strcpy (givrListCRC.trEltList[giviNbCRC].acCodan8,rPrioCRC.acCodan8);
      (void)strcpy (givrListCRC.trEltList[giviNbCRC].acType,rPrioCRC.acType);
      (void)strcpy (givrListCRC.trEltList[giviNbCRC].acEtab,rPrioCRC.acEtab);
      (void)strcpy (givrListCRC.trEltList[giviNbCRC].acCRC,rPrioCRC.acCRC);
      givrListCRC.trEltList[giviNbCRC].iPrioCRC = rPrioCRC.iPrioCRC;
      givrListCRC.trEltRangList[giviNbCRC] = giviNbCRC;
      giviNbCRC++;
      givrListCRC.iNbr = giviNbCRC;
  }

  return (iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction :  givCompListCRC
 *
 * But : Comparaison des crc
 *
 * Description : comparaison etab,crc,an8,type
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres :
 *
 *	Valeurs retournées :
 *
 *	Erreurs :
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Oct/04/2012  (mb)
 *
 * Modification   (MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/
static int4 givCompListCRC(const void *apList1, const void *apList2)
{
  /** code retour des fonctions appelées */
  int4 iRetour;
  /** pointeur sur le rang du premier code à comparer */
  int4 iList1;
  /** pointeur sur le rang du second code à comparer */
  int4 iList2;

  /** Initialisation des pointeurs */
  iList1 = *(int4 *)apList1;
  iList2 = *(int4 *)apList2;

  if ((0 == strlen(givrListCRC.trEltList[iList1].acEtab))
      && (0 != strlen(givrListCRC.trEltList[iList2].acEtab)))
  {
    return(1);
  }
  if ((0 != strlen(givrListCRC.trEltList[iList1].acEtab))
      && (0 == strlen(givrListCRC.trEltList[iList2].acEtab)))
  {
    return(-1);
  }
  iRetour = strcmp(givrListCRC.trEltList[iList1].acEtab,givrListCRC.trEltList[iList2].acEtab);
  if (0 != iRetour)
  {
    return(iRetour);
  }
  else
  {
    iRetour = strcmp(givrListCRC.trEltList[iList1].acCodan8,givrListCRC.trEltList[iList2].acCodan8);
    if (0 != iRetour)
    {
      return(iRetour);
    }
    else
    {
      iRetour = strcmp(givrListCRC.trEltList[iList1].acCRC,givrListCRC.trEltList[iList2].acCRC);
      if (0 != iRetour)
      {
        return(iRetour);
      }
      else
      {
        iRetour = strcmp(givrListCRC.trEltList[iList1].acType,givrListCRC.trEltList[iList2].acType);
        if (0 != iRetour)
        {
          return(iRetour);
        }
        else
        {
          iRetour = strcmp(givrListCRC.trEltList[iList1].acTpdsob,givrListCRC.trEltList[iList2].acTpdsob);
          if (0 != iRetour)
          {
            return(iRetour);
          }
          else
          {
            if (GIXCodeOK == givrListCRC.trEltList[iList1].iPrioCRC && GIXCodeOK != givrListCRC.trEltList[iList2].iPrioCRC)
            {
              return(-1);
            }
            else if (GIXCodeOK != givrListCRC.trEltList[iList1].iPrioCRC && GIXCodeOK == givrListCRC.trEltList[iList2].iPrioCRC)
            {
              return(1);
            }
            return(0);
          }
        }
      }
    }
  }

}

/*----------------------------------Fonction----------------------------------*
 * Fonction :  givCompListInst
 *
 * But : Comparaison des codes géographiques d'installation
 *
 * Description : comparaison dept/loc/arr d'installation
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres :
 *
 *	Valeurs retournées :
 *
 *	Erreurs :
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Jan/29/2008  (mb)
 *
 * Modification   (MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

static int4 givCompListInst(const void *apList1, const void *apList2)
{
  /** code retour des fonctions appelées */
  int4 iRetour;
  /** pointeur sur le rang du premier code à comparer */
  int4 iList1;
  /** pointeur sur le rang du second code à comparer */
  int4 iList2;

  /** Initialisation des pointeurs */
  iList1 = *(int4 *)apList1;
  iList2 = *(int4 *)apList2;
  if (((int4)-1 == (int4) givrListInst.trEltList[iList1].iRangTri)
      && ((int4)-1 != (int4) givrListInst.trEltList[iList2].iRangTri))
  {
    return(1);
  }

  if (((int4)-1 != (int4) givrListInst.trEltList[iList1].iRangTri)
      && ((int4)-1 == (int4) givrListInst.trEltList[iList2].iRangTri))
  {
    return(-1);
  }
  iRetour = (int4) givrListInst.trEltList[iList1].iRangTri - givrListInst.trEltList[iList2].iRangTri;
  if (0 != iRetour)
  {
    return(iRetour);
  }
  else
  {
    iRetour = strcmp(givrListInst.trEltList[iList1].reg,givrListInst.trEltList[iList2].reg);
    if (0 != iRetour)
    {
      return(iRetour);
    }
    else
    {
      iRetour = strcmp(givrListInst.trEltList[iList1].dep,givrListInst.trEltList[iList2].dep);
      if (0 != iRetour)
      {
        return(iRetour);
      }
      else
      {
        iRetour = strcmp(givrListInst.trEltList[iList1].loc,givrListInst.trEltList[iList2].loc);
        if (0 != iRetour)
        {
          return(iRetour);
        }
        else
        {
          iRetour = strcmp(givrListInst.trEltList[iList1].arr,givrListInst.trEltList[iList2].arr);
          return(iRetour);
        }
      }
    }
  }

}
static int4 givCompListAn9Inst(const void *apList1, const void *apList2)
{
  /** code retour des fonctions appelées */
  int4 iRetour;
  /** pointeur sur le rang du premier code à comparer */
  int4 iList1;
  /** pointeur sur le rang du second code à comparer */
  int4 iList2;

  /** Initialisation des pointeurs */
  iList1 = *(int4 *)apList1;
  iList2 = *(int4 *)apList2;
  iRetour = strcmp(givrListInst.trEltList[iList1].rub,givrListInst.trEltList[iList2].rub);
  if (0 != iRetour)
  {
    return(iRetour);
  }
  else
  {
    iRetour = (int4) givrListInst.trEltList[iList1].iRgLigne - givrListInst.trEltList[iList2].iRgLigne;
    return(iRetour);
  }
}
static int4 givCompListDenomInst(const void *apList1, const void *apList2)
{
  /** code retour des fonctions appelées */
  int4 iRetour;
  /** pointeur sur le rang du premier code à comparer */
  int4 iList1;
  /** pointeur sur le rang du second code à comparer */
  int4 iList2;

  /** Initialisation des pointeurs */
  iList1 = *(int4 *)apList1;
  iList2 = *(int4 *)apList2;
  iList1 = givrListInst.trEltList[iList1].iRgLigne;
  iList2 = givrListInst.trEltList[iList2].iRgLigne;
  iRetour = strcmp((doc2+iList1)->value.intitule.denomination,(doc2+iList2)->value.intitule.denomination);
  if (0 != iRetour)
  {
    return(iRetour);
  }
  else
  {
    iRetour = (int4) iList1 - iList2;
    return(iRetour);
  }
}

/*----------------------------------Fonction----------------------------------*
 * Fonction :  givCompListParu
 *
 * But : Comparaison des codes géographiques de parution
 *
 * Description : comparaison dept/loc/arr de parution
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres :
 *
 *	Valeurs retournées :
 *
 *	Erreurs :
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Jan/29/2008  (mb)
 *
 * Modification   (MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

static int4 givCompListParu(const void *apList1, const void *apList2)
{
  /** code retour des fonctions appelées */
  int4 iRetour;
  /** pointeur sur le rang du premier code à comparer */
  int4 iList1;
  /** pointeur sur le rang du second code à comparer */
  int4 iList2;

  /** Initialisation des pointeurs */
  iList1 = *(int4 *)apList1;
  iList2 = *(int4 *)apList2;
  if (((int4)-1 == (int4) givrListParu.trEltList[iList1].iRangTri)
      && ((int4)-1 != (int4) givrListParu.trEltList[iList2].iRangTri))
  {
    return(1);
  }

  if (((int4)-1 != (int4) givrListParu.trEltList[iList1].iRangTri)
      && ((int4)-1 == (int4) givrListParu.trEltList[iList2].iRangTri))
  {
    return(-1);
  }
  iRetour = (int4) givrListParu.trEltList[iList1].iRangTri - givrListParu.trEltList[iList2].iRangTri;
  if (0 != iRetour)
  {
    return(iRetour);
  }
  else
  {
    iRetour = strcmp(givrListParu.trEltList[iList1].reg,givrListParu.trEltList[iList2].reg);
    if (0 != iRetour)
    {
      return(iRetour);
    }
    else
    {
      iRetour = strcmp(givrListParu.trEltList[iList1].dep,givrListParu.trEltList[iList2].dep);
      if (0 != iRetour)
      {
        return(iRetour);
      }
      else
      {
        iRetour = strcmp(givrListParu.trEltList[iList1].loc,givrListParu.trEltList[iList2].loc);
        if (0 != iRetour)
        {
          return(iRetour);
        }
        else
        {
          iRetour = strcmp(givrListParu.trEltList[iList1].arr,givrListParu.trEltList[iList2].arr);
          if (0 != iRetour)
          {
            return(iRetour);
          }
          else
          {
            if (((int4)GIXCodeKO == givrListParu.trEltList[iList1].iLF)
                && ((int4)GIXCodeKO != givrListParu.trEltList[iList2].iLF))
            {
              return(-1);
            }
            if (((int4)GIXCodeKO != givrListParu.trEltList[iList1].iLF)
                && ((int4)GIXCodeKO == givrListParu.trEltList[iList2].iLF))
            {
              return(1);
            }
            if ((int4)GIXCodeKO != givrListParu.trEltList[iList1].iZU)
            {
              return(-1);
            }
            return(1);
          }
        }
      }
    }
  }

}
static int4 givCompListAn9Paru(const void *apList1, const void *apList2)
{
  /** code retour des fonctions appelées */
  int4 iRetour;
  /** pointeur sur le rang du premier code à comparer */
  int4 iList1;
  /** pointeur sur le rang du second code à comparer */
  int4 iList2;

  /** Initialisation des pointeurs */
  iList1 = *(int4 *)apList1;
  iList2 = *(int4 *)apList2;
  iRetour = strcmp(givrListParu.trEltList[iList1].rub,givrListParu.trEltList[iList2].rub);
  if (0 != iRetour)
  {
    return(iRetour);
  }
  else
  {
    iRetour = (int4) givrListParu.trEltList[iList1].iRgLigne - givrListParu.trEltList[iList2].iRgLigne;
    return(iRetour);
  }
}
static int4 givCompListDenomParu(const void *apList1, const void *apList2)
{
  /** code retour des fonctions appelées */
  int4 iRetour;
  /** pointeur sur le rang du premier code à comparer */
  int4 iList1;
  /** pointeur sur le rang du second code à comparer */
  int4 iList2;

  /** Initialisation des pointeurs */
  iList1 = *(int4 *)apList1;
  iList2 = *(int4 *)apList2;
  iList1 = givrListParu.trEltList[iList1].iRgLigne;
  iList2 = givrListParu.trEltList[iList2].iRgLigne;
  iRetour = strcmp((doc2+iList1)->value.intitule.denomination,(doc2+iList2)->value.intitule.denomination);
  if (0 != iRetour)
  {
    return(iRetour);
  }
  else
  {
    iRetour = (int4) iList1 - iList2;
    return(iRetour);
  }
}

/*----------------------------------Fonction----------------------------------*
 * Fonction :  givCompListParuTaille
 *
 * But : Comparaison des codes géographiques de parution par taille de blocs
 *       rub/geo
 *
 * Description : comparaison dept/loc/arr de parution
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres :
 *
 *	Valeurs retournées :
 *
 *	Erreurs :
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Av/08/2008  (mb)
 *
 * Modification   (MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

static int4 givCompListParuTaille(const void *apList1, const void *apList2)
{
  /** code retour des fonctions appelées */
  int4 iRetour;
  /** pointeur sur le rang du premier code à comparer */
  int4 iList1;
  /** pointeur sur le rang du second code à comparer */
  int4 iList2;

  /** Initialisation des pointeurs */
  iList1 = *(int4 *)apList1;
  iList2 = *(int4 *)apList2;

  if (((int4)-1 == (int4) givrListParu.trEltList[iList1].iRgGeoTri)
      && ((int4)-1 != (int4) givrListParu.trEltList[iList2].iRgGeoTri))
  {
    return(1);
  }

  if (((int4)-1 != (int4) givrListParu.trEltList[iList1].iRgGeoTri)
      && ((int4)-1 == (int4) givrListParu.trEltList[iList2].iRgGeoTri))
  {
    return(-1);
  }
  iRetour = (int4) givrListParu.trEltList[iList1].iNbGeoTri - givrListParu.trEltList[iList2].iNbGeoTri;
  if (0 != iRetour)
  {
    return(iRetour);
  }
  iRetour = (int4) givrListParu.trEltList[iList1].iRgTriDblBis - givrListParu.trEltList[iList2].iRgTriDblBis;
  if (0 != iRetour)
  {
    return(iRetour);
  }

  iRetour = (int4) givrListParu.trEltList[iList1].iRangTri - givrListParu.trEltList[iList2].iRangTri;
  if (0 != iRetour)
  {
    return(iRetour);
  }

  iRetour = (int4) givrListParu.trEltList[iList1].iRgGeoTri - givrListParu.trEltList[iList2].iRgGeoTri;

  return(iRetour);
}


/*----------------------------------Fonction----------------------------------*
 * Fonction :  givCompListInstTaille
 *
 * But : Comparaison des codes géographiques d'installation par taille de blocs
 *       rub/geo
 *
 * Description : comparaison dept/loc/arr de parution
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres :
 *
 *	Valeurs retournées :
 *
 *	Erreurs :
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Av/08/2008  (mb)
 *
 * Modification   (MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

static int4 givCompListInstTaille(const void *apList1, const void *apList2)
{
  /** code retour des fonctions appelées */
  int4 iRetour;
  /** pointeur sur le rang du premier code à comparer */
  int4 iList1;
  /** pointeur sur le rang du second code à comparer */
  int4 iList2;

  /** Initialisation des pointeurs */
  iList1 = *(int4 *)apList1;
  iList2 = *(int4 *)apList2;

  if (((int4)-1 == (int4) givrListInst.trEltList[iList1].iRgGeoTri)
      && ((int4)-1 != (int4) givrListInst.trEltList[iList2].iRgGeoTri))
  {
    return(1);
  }
  if (((int4)-1 != (int4) givrListInst.trEltList[iList1].iRgGeoTri)
      && ((int4)-1 == (int4) givrListInst.trEltList[iList2].iRgGeoTri))
  {
    return(-1);
  }
  iRetour = (int4) givrListInst.trEltList[iList1].iNbGeoTri - givrListInst.trEltList[iList2].iNbGeoTri;
  if (0 != iRetour)
  {
    return(iRetour);
  }

  iRetour = (int4) givrListInst.trEltList[iList1].iRangTri - givrListInst.trEltList[iList2].iRangTri;
  if (0 != iRetour)
  {
    return(iRetour);
  }

  iRetour = (int4) givrListInst.trEltList[iList1].iRgGeoTri - givrListInst.trEltList[iList2].iRgGeoTri;
  return(iRetour);

}


/*----------------------------------Fonction----------------------------------*
 * Fonction :  givInitTriAn9Geo
 *
 * But : init Tri des codes géographiques
 *
 * Description : init du rang de rubrique
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres :
 *
 *	Valeurs retournées :
 *
 *	Erreurs :
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Jan/29/2008  (mb)
 *
 * Modification   (MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givInitTriAn9Geo(void)
{

  int4 iCodRet;     /* Code retour de la fonction */
  int4 iIntRet;     /* Code retour interne */
  int4 i,j,k,l,m,n;
  int4 iGeo;
  int4 iVal;
  char tcAn9Courant[GYBPaprofLgCodan9 + 1];
  int4 iRangRub,iRgRubDbl,iNbGeoRub,iRgGeoRub,iRangDeb,iNbrRub;
  int4 iNbrParuMax,iNbrInstMax;


  /* trier en fonction des an9 */
  qsort(givrListParu.trEltRangList,givrListParu.iNbr,sizeof(int4),givCompListAn9Paru);

  qsort(givrListInst.trEltRangList,givrListInst.iNbr,sizeof(int4),givCompListAn9Inst);
  iNbrInstMax = givrListInst.iNbr;
  iNbrParuMax = givrListParu.iNbr;

  strcpy(tcAn9Courant, givcR00000000);
  iRangRub = -1;
  /* analyse paru par rubrique */
  for(i=0; i<iNbrParuMax; i++)
  {
    k= givrListParu.trEltRangList[i];
    if ((0 != strcmp(tcAn9Courant,givrListParu.trEltList[k].rub)) || (0 == i))
    {
      strcpy(tcAn9Courant, givrListParu.trEltList[k].rub);
      iRangRub++;
      /* init arr si LF */
      for(m=0; m<3; m++)
      {
        givtrRefArr[m+3].nbarr = givtrRefArr[m].nbarr;
      }
      /* Init d'une installation par défaut */
      for(j=0; j<iNbrInstMax; j++)
      {
        l = givrListInst.trEltRangList[j];
        if (0 == strcmp(givrListInst.trEltList[l].rub,givrListParu.trEltList[k].rub))
        {
          break;
        }
      }
      if ((iNbrInstMax == j) && (MAX_LIST != givrListInst.iNbr))
      {
        /* ajout défaut */
        iGeo = givrListInst.iNbr;
        (void)strcpy(givrListInst.trEltList[iGeo].rub, givrListParu.trEltList[k].rub);
        (void)strcpy(givrListInst.trEltList[iGeo].dep,"999");
        (void)strcpy(givrListInst.trEltList[iGeo].loc,"99999");
        (void)strcpy(givrListInst.trEltList[iGeo].arr,"99");
        (void)strcpy(givrListInst.trEltList[iGeo].reg,"99");
        givrListInst.trEltList[iGeo].iRgLigne = (int4)GIXCodeKO;
        givrListInst.trEltList[iGeo].iGeo = 99;
        givrListInst.trEltList[iGeo].iGeoReg = 99;
        givrListInst.trEltList[iGeo].iGeoDept = 99;
        givrListInst.trEltList[iGeo].iGeoLoc = 99;
        givrListInst.trEltList[iGeo].iGeoArr = 99;
        givrListInst.trEltRangList[iGeo] = iGeo;
        givrListInst.iNbr++;
      }
      else if (iNbrInstMax == j)
      {
        /* Trop d'entrées internes */
        GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
      }
    }
    givrListParu.trEltList[k].iRangTri = iRangRub;

    /* analyse localité fictive par rubrique */
    if (0 == strcmp(givrListParu.trEltList[k].loc,givcLocFictive))
    {
      for(m=0; m<6; m++)
      {
        /* parution LF avec arrondissement */
        if ((0 == strcmp(givtrRefArr[m].dep,givrListParu.trEltList[k].dep)) && (0 == strcmp(givtrRefArr[m].loc,givrListParu.trEltList[k].loc)))
        {
          break;
        }
      }
      if (6 != m)
      {
        for(j = 1; j < (givtrRefArr[m].nbarr+1); j++)
        {
          iGeo = givrListParu.iNbr;
          if (MAX_LIST == iGeo)
          {
            /* Trop d'entrées internes */
            GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
              break;
          }
          /* givrListParu.trEltList[iGeo].iRgLigne = (int4)GIXCodeKO; */
          givrListParu.trEltList[iGeo].iRgLigne = givrListParu.trEltList[k].iRgLigne;
          givrListParu.trEltList[iGeo].iRgDnom = givrListParu.trEltList[k].iRgDnom;
          (void)strcpy(givrListParu.trEltList[iGeo].tcRgDnom, givrListParu.trEltList[k].tcRgDnom);
          givrListParu.trEltList[iGeo].iRangTri = givrListParu.trEltList[k].iRangTri;
          givrListParu.trEltList[iGeo].iGeo = 99;
          givrListParu.trEltList[iGeo].iGeoReg = 99;
          givrListParu.trEltList[iGeo].iGeoDept = 99;
          givrListParu.trEltList[iGeo].iGeoLoc = 99;
          givrListParu.trEltList[iGeo].iGeoArr = 99;
          if (0 != strcmp("075",givrListParu.trEltList[k].dep))
          {
            givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
          }
          else
          {
            givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
          }
          (void)strcpy(givrListParu.trEltList[iGeo].rub,givrListParu.trEltList[k].rub);
          (void)strcpy(givrListParu.trEltList[iGeo].rubinit,givrListParu.trEltList[k].rubinit);
          (void)strcpy(givrListParu.trEltList[iGeo].nature,givrListParu.trEltList[k].nature);
          givrListParu.trEltList[iGeo].iRangTri = givrListParu.trEltList[k].iRangTri;
          (void)strcpy(givrListParu.trEltList[iGeo].dep,givrListParu.trEltList[k].dep);
          (void)strcpy(givrListParu.trEltList[iGeo].loc,givtrRefArr[m-3].loc);
          iVal = j;
          for (l = 1; l >= 0; l--)
          {
            givrListParu.trEltList[iGeo].arr[l] = (char)((iVal % 10) + '0');
            iVal = iVal / 10;
          }
          (void)strcpy(givrListParu.trEltList[iGeo].reg,givtrRefArr[m-3].reg);
          givrListParu.trEltList[iGeo].iZU = (int4)GIXCodeKO;
          givrListParu.trEltList[iGeo].cParuloc = givrListParu.trEltList[k].cParuloc;
          givrListParu.trEltRangList[iGeo] = iGeo;
          givrListParu.iNbr++;
        }
        /* LF a ne plus traiter */
        givtrRefArr[m].nbarr = 0;
      }
    }
  }
  /* nombre de rubriques */
  givrListParu.iNbrTri = iRangRub + 1;

  strcpy(tcAn9Courant, givcR00000000);
  iRangRub = -1;
  /* analyse inst par rubrique */
  for(i=0; i<givrListInst.iNbr; i++)
  {
    k= givrListInst.trEltRangList[i];
    if ((0 != strcmp(tcAn9Courant,givrListInst.trEltList[k].rub)) || (0 == i))
    {
      iRangRub ++;
      strcpy(tcAn9Courant, givrListInst.trEltList[k].rub);
    }
    givrListInst.trEltList[k].iRangTri = iRangRub;
  }


  return(iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction :  givInitTriDenomGeo
 *
 * But : init Tri des codes géographiques
 *
 * Description : init du rang de denomination
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres :
 *
 *	Valeurs retournées :
 *
 *	Erreurs :
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Jan/29/2008  (mb)
 *
 * Modification   (MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givInitTriDenomGeo(int4 iTri)
{

  int4 iCodRet;     /* Code retour de la fonction */
  int4 iIntRet;     /* Code retour interne */
  int4 i,ii,j,k,kk,ll,l,m,n;
  int4 iGeo;
  int4 iVal;
  GYBstrIeinscDenomT rDenom;
  int4 iRang;
  int4 iNbrParuMax,iNbrInstMax;

  if (giv_DNOM != iTri)
  {
  /* analyse paru par dénomination */
  for(i=0; i<givrListParu.iNbr; i++)
  {
    k = givrListParu.trEltRangList[i];
    kk = givrListParu.trEltList[k].iRgLigne;
    givrListParu.trEltList[k].iRgDnom = (doc2+kk)->value.intitule.iRgDnom;
    (void)strcpy(givrListParu.trEltList[k].tcRgDnom, (doc2+kk)->value.intitule.tcRgDnom);
  }
  /* analyse inst par dénomination */
  for(i=0; i<givrListInst.iNbr; i++)
  {
    k = givrListInst.trEltRangList[i];
    kk = givrListInst.trEltList[k].iRgLigne;
    givrListInst.trEltList[k].iRgDnom = (doc2+kk)->value.intitule.iRgDnom;
    (void)strcpy(givrListInst.trEltList[k].tcRgDnom, (doc2+kk)->value.intitule.tcRgDnom);
  }
  }
  else
  {
  iRang = -1;
  /* analyse paru par dénomination */
  for(i=0; i<givrListParu.iNbr; i++)
  {
    k = givrListParu.trEltRangList[i];
    givrListParu.trEltList[k].iRangTri = givrListParu.trEltList[k].iRgDnom;
    if (givrListParu.trEltList[k].iRangTri > iRang)
    {
      iRang = givrListParu.trEltList[k].iRangTri;
    }
  }
  /* nombre de denominations */
  givrListParu.iNbrTri = iRang + 1;

  iRang = -1;
  /* analyse inst par dénomination */
  for(i=0; i<givrListInst.iNbr; i++)
  {
    k = givrListInst.trEltRangList[i];
    givrListInst.trEltList[k].iRangTri = givrListInst.trEltList[k].iRgDnom;
    if (givrListInst.trEltList[k].iRangTri > iRang)
    {
      iRang = givrListInst.trEltList[k].iRangTri;
    }
  }
  /* nombre de denominations */
  givrListInst.iNbrTri = iRang + 1;
  }


  return(iCodRet);


  /* trier en fonction des dénominations */
  qsort(givrListParu.trEltRangList,givrListParu.iNbr,sizeof(int4),givCompListDenomParu);

  qsort(givrListInst.trEltRangList,givrListInst.iNbr,sizeof(int4),givCompListDenomInst);
  iNbrInstMax = givrListInst.iNbr;
  iNbrParuMax = givrListParu.iNbr;

  strcpy(rDenom, "      ");
  iRang = -1;
  /* analyse paru par dénomination */
  for(i=0; i<iNbrParuMax; i++)
  {
    k = givrListParu.trEltRangList[i];
    kk = givrListParu.trEltList[k].iRgLigne;
    if ((0 != strcmp(rDenom,(doc2+kk)->value.intitule.denomination)) || (0 == i))
    {
      strcpy(rDenom, (doc2+kk)->value.intitule.denomination);
      iRang++;
      /* init arr si LF */
      for(m=0; m<3; m++)
      {
        givtrRefArr[m+3].nbarr = givtrRefArr[m].nbarr;
      }
      /* Init d'une installation par défaut */
      for(j=0; j<iNbrInstMax; j++)
      {
        l = givrListInst.trEltRangList[j];
        ll = givrListInst.trEltList[l].iRgLigne;
        if (0 == strcmp((doc2+ll)->value.intitule.denomination,(doc2+kk)->value.intitule.denomination))
        {
          break;
        }
      }
      if ((iNbrInstMax == j) && (MAX_LIST == givrListInst.iNbr))
      {
        /* Trop d'entrées internes */
        GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
      }
      else if (iNbrInstMax == j)
      {
        /* ajout défaut */
        iGeo = givrListInst.iNbr;
        (void)strcpy(givrListInst.trEltList[iGeo].rub, givrListParu.trEltList[k].rub);
        (void)strcpy(givrListInst.trEltList[iGeo].dep,"999");
        (void)strcpy(givrListInst.trEltList[iGeo].loc,"99999");
        (void)strcpy(givrListInst.trEltList[iGeo].arr,"99");
        (void)strcpy(givrListInst.trEltList[iGeo].reg,"99");
        givrListInst.trEltList[iGeo].iRgLigne = givrListParu.trEltList[k].iRgLigne;
        givrListInst.trEltList[iGeo].iRangTri = givrListParu.trEltList[k].iRangTri;
        givrListInst.trEltList[iGeo].iGeo = 99;
        givrListInst.trEltList[iGeo].iGeoReg = 99;
        givrListInst.trEltList[iGeo].iGeoDept = 99;
        givrListInst.trEltList[iGeo].iGeoLoc = 99;
        givrListInst.trEltList[iGeo].iGeoArr = 99;
        givrListInst.trEltRangList[iGeo] = iGeo;
        givrListInst.iNbr++;
      }
    }
    givrListParu.trEltList[k].iRangTri = iRang;

    /* analyse localité fictive par dénomination */
    if (0 == strcmp(givrListParu.trEltList[k].loc,givcLocFictive))
    {
      for(m=0; m<6; m++)
      {
        /* parution LF avec arrondissement */
        if ((0 == strcmp(givtrRefArr[m].dep,givrListParu.trEltList[k].dep)) && (0 == strcmp(givtrRefArr[m].loc,givrListParu.trEltList[k].loc)))
        {
          break;
        }
      }
      if (6 != m)
      {
        for(j = 1; j < (givtrRefArr[m].nbarr+1); j++)
        {
          iGeo = givrListParu.iNbr;
          if (MAX_LIST == iGeo)
          {
            /* Trop d'entrées internes */
            GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
              break;
          }
          givrListParu.trEltList[iGeo].iRgLigne = (int4)GIXCodeKO;
          givrListParu.trEltList[iGeo].iRgLigne = givrListParu.trEltList[k].iRgLigne;
          givrListParu.trEltList[iGeo].iRangTri = givrListParu.trEltList[k].iRangTri;
          givrListParu.trEltList[iGeo].iGeo = 99;
          givrListParu.trEltList[iGeo].iGeoReg = 99;
          givrListParu.trEltList[iGeo].iGeoDept = 99;
          givrListParu.trEltList[iGeo].iGeoLoc = 99;
          givrListParu.trEltList[iGeo].iGeoArr = 99;
          if (0 != strcmp("075",givrListParu.trEltList[k].dep))
          {
            givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
          }
          else
          {
            givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
          }
          (void)strcpy(givrListParu.trEltList[iGeo].rub,givrListParu.trEltList[k].rub);
          (void)strcpy(givrListParu.trEltList[iGeo].rubinit,givrListParu.trEltList[k].rubinit);
          (void)strcpy(givrListParu.trEltList[iGeo].nature,givrListParu.trEltList[k].nature);
          givrListParu.trEltList[iGeo].iRangTri = givrListParu.trEltList[k].iRangTri;
          (void)strcpy(givrListParu.trEltList[iGeo].dep,givrListParu.trEltList[k].dep);
          (void)strcpy(givrListParu.trEltList[iGeo].loc,givtrRefArr[m-3].loc);
          iVal = j;
          for (l = 1; l >= 0; l--)
          {
            givrListParu.trEltList[iGeo].arr[l] = (char)((iVal % 10) + '0');
            iVal = iVal / 10;
          }
          (void)strcpy(givrListParu.trEltList[iGeo].reg,givtrRefArr[m-3].reg);
          givrListParu.trEltList[iGeo].iZU = (int4)GIXCodeKO;
          givrListParu.trEltList[iGeo].cParuloc = givrListParu.trEltList[k].cParuloc;
          givrListParu.trEltRangList[iGeo] = iGeo;
          givrListParu.iNbr++;
        }
        /* LF a ne plus traiter */
        givtrRefArr[m].nbarr = 0;
      }
    }
  }
  /* nombre de denominations */
  givrListParu.iNbrTri = iRang + 1;

  strcpy(rDenom, "      ");
  iRang = -1;
  /* analyse inst par dénomination */
  for(i=0; i<givrListInst.iNbr; i++)
  {
    k = givrListInst.trEltRangList[i];
    kk = givrListInst.trEltList[k].iRgLigne;
    if ((0 != strcmp(rDenom,(doc2+kk)->value.intitule.denomination)) || (0 == i))
    {
      iRang ++;
      strcpy(rDenom, (doc2+kk)->value.intitule.denomination);
    }
    givrListInst.trEltList[k].iRangTri = iRang;
  }


  return(iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction :  givInitTriObjGeo
 *
 * But : Tri des objets publiciatires
 *
 * Description : init du rang d'objet
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres :
 *
 *	Valeurs retournées :
 *
 *	Erreurs :
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Jan/29/2008  (mb)
 *
 * Modification   (MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givInitTriObj(GYBrDOCUMENT *doc, int4 indice, int4 iTri)
{

  int4 iCodRet;     /* Code retour de la fonction */
  int4 iIntRet;     /* Code retour interne */
  int4 i,ii,j,k,kk,l,m;
  int4 iObj,iCVI;
  int4 iRang,iOrd,iRgLigne,iRgObj;
  GYBrIamicT rIamic;
  char tcType[3]; /* type */

  /* analyse objet par ligne */
  iCVI = -1;
  givrListObj.iNbr = 0;
  /* analyse des CVIV */
  for(i=0; i<indice; i++)
  {
    for(j=0; j<(doc+i)->value.objets_pub.nb_micro; j++)
    {
    	strcpy(tcType, (doc+i)->value.objets_pub.micro[j].stype);
    	for ( k = 0; (k < givNbFixeCVI && 0 != strcmp(givTabCVI[k],tcType)); k++);
    	if (givNbFixeCVI != k)
    	{
    		iCVI = k;
    		break;
    	}
    }
    if ((doc+i)->value.objets_pub.nb_micro != j)
    {
    	break;
    }
  }
  for(i=0; i<indice; i++)
  {
    for(j=0; j<(doc+i)->value.objets_pub.nb_micro; j++)
    {
      iObj = givrListObj.iNbr;
      if (MAX_LIST == iObj)
      {
        /* Trop d'entrées internes */
        GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
        break;
      }
      if ((0 == strcmp ("RM", (doc+i)->value.objets_pub.micro[j].stype)) &&
          ((-1 == iCVI) ||
      	   ((0 != strcmp( "001",(doc+i)->value.inscription[0].val_seqLS)) &&
      	   (0 != strlen((doc+i)->value.inscription[0].val_seqLS)))))
      {
        /* pas de RM (Ranking Mappy) si CVIV inactif */
        GWTTrace (GWT_NIV_FONCT, ("Objet RM avec CVIV absent : %s\n",(doc+i)->value.objets_pub.micro[j].id));
      	continue;
      }
      givrListObj.trEltRangListObj[iObj] = iObj;
      givrListObj.trEltListObj[iObj].iRgLigne = i;
      givrListObj.trEltListObj[iObj].iRgObj = j;
      givrListObj.iNbr++;
    }
  }

  if (0 != givrListObj.iNbr)
  {
    /* existence d'objet publicitaire */
  /* trier en fonction des objets */
  qsort(givrListObj.trEltRangListObj,givrListObj.iNbr,sizeof(int4),givCompListObj);

  /* analyse liste par objet */
  iRang = -1;
  iOrd = 0;
  for(i=0; i<givrListObj.iNbr; i++)
  {
    k = givrListObj.trEltRangListObj[i];
    kk = givrListObj.trEltListObj[k].iRgLigne;
    iObj = givrListObj.trEltListObj[k].iRgObj;
    if ((0 != strcmp(rIamic.acTypobj, (doc+kk)->value.objets_pub.micro[iObj].type)) || (0 == i) ||
        (0 != strcmp(rIamic.acTpdsob, (doc+kk)->value.objets_pub.micro[iObj].stype)) ||
        (0 != strcmp(rIamic.acNumobj, (doc+kk)->value.objets_pub.micro[iObj].id)))
    {
      iRang ++;
      iOrd = 0;
      strcpy(rIamic.acTypobj, (doc+kk)->value.objets_pub.micro[iObj].type);
      strcpy(rIamic.acTpdsob, (doc+kk)->value.objets_pub.micro[iObj].stype);
      strcpy(rIamic.acStobj, (doc+kk)->value.objets_pub.micro[iObj].sstype);
      strcpy(rIamic.acNumobj,(doc+kk)->value.objets_pub.micro[iObj].id);
    GWTTrace (GWT_NIV_FONCT,
            (" Tri objet 1 : ... %d,%d\n",iRang,iOrd));
    }
    else if ((0 == strcmp(rIamic.acTypobj, (doc+kk)->value.objets_pub.micro[iObj].type)) &&
        (0 == strcmp(rIamic.acTpdsob, (doc+kk)->value.objets_pub.micro[iObj].stype)) &&
        (0 != strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,"VI")) &&
        (0 != strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,"FI")) &&
        (0 != strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,"IN")) &&
        (0 != strcmp(rIamic.acStobj, (doc+kk)->value.objets_pub.micro[iObj].sstype)) &&
        (0 == strcmp(rIamic.acNumobj, (doc+kk)->value.objets_pub.micro[iObj].id)))
    {
      iRang ++;
      iOrd = 0;
      strcpy(rIamic.acTypobj, (doc+kk)->value.objets_pub.micro[iObj].type);
      strcpy(rIamic.acTpdsob, (doc+kk)->value.objets_pub.micro[iObj].stype);
      strcpy(rIamic.acStobj, (doc+kk)->value.objets_pub.micro[iObj].sstype);
      strcpy(rIamic.acNumobj,(doc+kk)->value.objets_pub.micro[iObj].id);
    GWTTrace (GWT_NIV_FONCT,
            (" Tri objet 2 : ... %d,%d\n",iRang,iOrd));
    }
    else if ((0 == strcmp(rIamic.acTypobj, (doc+kk)->value.objets_pub.micro[iObj].type)) &&
        (0 == strcmp(rIamic.acTpdsob, (doc+kk)->value.objets_pub.micro[iObj].stype)) &&
        ((0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,"VI")) ||
        (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,"FI")) ||
        (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,"IN"))) &&
        (0 != strcmp(rIamic.acStobj, (doc+kk)->value.objets_pub.micro[iObj].sstype)) &&
        (0 != strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype,"VS"))	&&
        (0 != strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype,"VF"))	&&
        (0 != strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype,"VE")) &&
        (0 == strcmp(rIamic.acNumobj, (doc+kk)->value.objets_pub.micro[iObj].id)))
    {
      iRang ++;
      iOrd = 0;
      strcpy(rIamic.acTypobj, (doc+kk)->value.objets_pub.micro[iObj].type);
      strcpy(rIamic.acTpdsob, (doc+kk)->value.objets_pub.micro[iObj].stype);
      strcpy(rIamic.acStobj, (doc+kk)->value.objets_pub.micro[iObj].sstype);
      strcpy(rIamic.acNumobj,(doc+kk)->value.objets_pub.micro[iObj].id);
    GWTTrace (GWT_NIV_FONCT,
            (" Tri objet 3 : ... %d,%d\n",iRang,iOrd));
    }
    else
    {
    	iOrd ++;
      strcpy(rIamic.acTypobj, (doc+kk)->value.objets_pub.micro[iObj].type);
      strcpy(rIamic.acTpdsob, (doc+kk)->value.objets_pub.micro[iObj].stype);
      strcpy(rIamic.acStobj, (doc+kk)->value.objets_pub.micro[iObj].sstype);
      strcpy(rIamic.acNumobj,(doc+kk)->value.objets_pub.micro[iObj].id);
    GWTTrace (GWT_NIV_FONCT,
            (" Tri objet 4 : ... %d,%d\n",iRang,iOrd));
    }
    givrListObj.trEltListObj[k].iRangTri = iRang;
    givrListObj.trEltListObj[k].iOrdTri = iOrd;
    GWTTrace (GWT_NIV_FONCT,
            (" Tri objet : ... %d,%d,%d,%d,%d,%d,%s,%s,%s,%s\n",i,k,iRang,iOrd,kk,iObj,
            (doc+kk)->value.objets_pub.micro[iObj].type,
            (doc+kk)->value.objets_pub.micro[iObj].stype,
            (doc+kk)->value.objets_pub.micro[iObj].sstype,
            (doc+kk)->value.objets_pub.micro[iObj].id));
    GWTTrace (GWT_NIV_FONCT,
            (" Tri objet ref : ... %d,%d,%d,%d,%d,%d,%s,%s,%s,%s\n",i,k,iRang,iOrd,kk,iObj,
            rIamic.acTypobj,
            rIamic.acTpdsob,
            rIamic.acStobj,
            rIamic.acNumobj));
  }
    iRang ++;
    givrListObj.iNbrTri = iRang;
    GWTTrace (GWT_NIV_FONCT,
            (" No_objets : ... %d,%d\n", givrListObj.iNbrTri,givrListObj.iNbr));
  }

  return(iCodRet);
}

int4 givInitTriObjGeo(GYBrDOCUMENT *doc, int4 indice, int4 iTri)
{

  int4 iCodRet;     /* Code retour de la fonction */
  int4 iIntRet;     /* Code retour interne */
  int4 i,ii,j,k,kk,l,m;
  int4 iObj,iCVI;
  int4 iRang,iOrd,iRgLigne,iRgObj;
  GYBrIamicT rIamic;
  char tcType[3]; /* type */
  char *buf_pos;

  if (0 == givrListObj.iNbr)
  {
    /* pas d'objet publicitaire */
    if (giv_OBJ == iTri)
    {
      givrListParu.iNbrTri = 0;
    }
    return(iCodRet);
  }


    /* init rangs Paru et Inst à -1 */
    for(i=0; i<givrListParu.iNbr; i++)
    {
      givrListParu.trEltList[i].iRangTri = -1;
      givrListParu.trEltList[i].iRgObj = -1;
    }
    for(i=0; i<givrListInst.iNbr; i++)
    {
      givrListInst.trEltList[i].iRangTri = -1;
      givrListInst.trEltList[i].iRgObj = -1;
    }
  givrListParu.iNbrTri = 0;
  l= 0;
  while (l<givrListObj.iNbr)
  {
    k = givrListObj.trEltRangListObj[l];
    iRang = givrListObj.trEltListObj[k].iRangTri;
    for(m=l; m<givrListObj.iNbr; m++)
    {
      kk = givrListObj.trEltRangListObj[m];
      if (iRang != givrListObj.trEltListObj[kk].iRangTri)
      {
       	break;
      }

      /* analyse paru par objet */
      for(i=0; i<givrListParu.iNbr; i++)
      {
        ii = givrListParu.trEltRangList[i];
        if (givrListObj.trEltListObj[kk].iRgLigne == givrListParu.trEltList[ii].iRgLigne)
        {
          if ((-1 == givrListParu.trEltList[ii].iRangTri) && (giv_OBJ == iTri))
          {
            /* premier objet pour une ligne */
            givrListParu.trEltList[ii].iRangTri = iRang;
            givrListParu.trEltList[ii].iRgObj = givrListObj.trEltListObj[kk].iRgObj;
          }
          else if (giv_OBJ == iTri)
          {
            if (MAX_LIST == givrListParu.iNbrTot)
            {
              /* Trop d'entrées internes */
              GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne Paru dépassée: %s,%d,%d\n",doc->value.a_classer.etab,givrListObj.iNbr,givrListObj.iNbrTri));
              break;
            }
            /* ajout objet suivant pour une ligne */
            givrListParu.trEltList[givrListParu.iNbrTot] = givrListParu.trEltList[ii];
            givrListParu.trEltList[givrListParu.iNbrTot].iRangTri = iRang;
            givrListParu.trEltList[givrListParu.iNbrTot].iRgObj = givrListObj.trEltListObj[kk].iRgObj;
            givrListParu.trEltList[givrListParu.iNbrTot].iRgDnom = -1;
            givrListParu.trEltRangList[givrListParu.iNbrTot] = givrListParu.iNbrTot;
            givrListParu.iNbrTot++;
          }
          else
          {
          /* Rang de tri d'objet dans document d'une ligne */
          iRgLigne = givrListObj.trEltListObj[kk].iRgLigne;
          iRgObj = givrListObj.trEltListObj[kk].iRgObj;
          (doc+iRgLigne)->value.objets_pub.micro[iRgObj].iRgObj = iRang;
          sprintf((doc+iRgLigne)->value.objets_pub.micro[iRgObj].tcRgObj, "%04d",iRang);
          }
        }
      }

      /* analyse inst par objet */
      for(i=0; i<givrListInst.iNbr; i++)
      {
        ii = givrListInst.trEltRangList[i];
        if (givrListObj.trEltListObj[kk].iRgLigne == givrListInst.trEltList[ii].iRgLigne)
        {
          if ((-1 == givrListInst.trEltList[ii].iRangTri) && (giv_OBJ == iTri))
          {
            /* premier objet pour une ligne */
            givrListInst.trEltList[ii].iRangTri = iRang;
            givrListInst.trEltList[ii].iRgObj = givrListObj.trEltListObj[kk].iRgObj;
          }
          else if (giv_OBJ == iTri)
          {
            if (MAX_LIST == givrListInst.iNbrTot)
            {
              /* Trop d'entrées internes */
              GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne Inst dépassée: %s,%d,%d\n",doc->value.a_classer.etab,givrListObj.iNbr,givrListObj.iNbrTri));
              break;
            }
            /* ajout objet suivant pour une ligne */
            givrListInst.trEltList[givrListInst.iNbrTot] = givrListInst.trEltList[ii];
            givrListInst.trEltList[givrListInst.iNbrTot].iRangTri = iRang;
            givrListInst.trEltList[givrListInst.iNbrTot].iRgObj = givrListObj.trEltListObj[kk].iRgObj;
            givrListInst.trEltRangList[givrListInst.iNbrTot] = givrListInst.iNbrTot;
            givrListInst.iNbrTot++;
          }
        }
      }
    }
    /* nombre d'objets */
    if (giv_OBJ == iTri)
    {
      if (MAX_LIST == givrListParu.iNbrTot)
      {
        /* Trop d'entrées internes */
        GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
      }
      else
      {
        givrListParu.iNbrTri++;
      }
    }
    l = m;
  }

  givrListParu.iNbr = givrListParu.iNbrTot;
  givrListInst.iNbr = givrListInst.iNbrTot;

  return(iCodRet);
}


/*----------------------------------Fonction----------------------------------*
 * Fonction :  givTriZU
 *
 * But : Tri des codes géographiques sur ZU
 *
 * Description :
 * Fonction de tri des réponses en fonction d'un critère qui précise l'ordre
 * de priorité des tris
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres :
 *
 *	Valeurs retournées :
 *
 *	Erreurs :
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Jun/14/2013  (mb)
 *
 * Modification   (MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givTriZU(void)
{
  int4 iCodRet;     /* Code retour de la fonction */
  char tcDeplocarr[GYBIeinscLgDeppar+GYBIeinscLgLocpar+GYBIeinscLgArrond+1];
  int4 iRgLigne, iRefLigne, iLF, iGeo;
  int4 i,j,k,l;

  iCodRet = (int4)GIXCodeOK;
  iGeo = givrListParu.iNbr;
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    if (0 == strcmp(givrListParu.trEltList[i].loc,givcLocFictive))
    {
      for(l=0; l<j; l++)
      {
         k = givrListParu.trEltRangList[l];
         if ((0 == strcmp(givrListParu.trEltList[k].loc,givcLocFictive))
         	&& (0 == strcmp(givrListParu.trEltList[i].dep,givrListParu.trEltList[k].dep)))
         {
         	 /* dep LF déjà traité */
     	     break;
         }
      }
    }
    if ((0 == strcmp(givrListParu.trEltList[i].loc,givcLocFictive)) && (l == j))
    {
    	iRgLigne = -1;
      iRefLigne = givrListParu.trEltList[i].iRgLigne;
      strcpy(tcDeplocarr,givrListParu.trEltList[i].dep);
      GWTTrace (GWT_NIV_FONCT, ("ZU LF [%d],[%d],[%s],[%s]\n", givrListParu.trEltList[i].iRgLigne, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc));
      for(l=0; l<(givrListParu.iNbr); l++)
      {
        k = givrListParu.trEltRangList[l];
        GWTTrace (GWT_NIV_FONCT, ("ZU LF Ins [%d],[%d],[%d],[%d],[%d],[%s],[%s]\n", iRefLigne, iRgLigne, iLF, givrListParu.trEltList[k].iRgLigne, givrListParu.trEltList[k].iZU, givrListParu.trEltList[k].dep, givrListParu.trEltList[k].loc));
        if (iRefLigne == givrListParu.trEltList[k].iRgLigne)
        {
        	continue;
        }
        else if (iRgLigne != givrListParu.trEltList[k].iRgLigne)
        {
        	/* changement de ligne */
        	iRgLigne = givrListParu.trEltList[k].iRgLigne;
        	iLF = GIXCodeKO;
        	if (0 == strcmp(givrListParu.trEltList[k].loc,givcLocFictive))
        	{
        		/* localité fictive à ne pas traiter */
        		iLF = GIXCodeOK;
        	}
        }
        else if (GIXCodeOK == iLF)
        {
        	/* même ligne avec LF ne pas traiter */
        }
        else if (((int4)GIXCodeOK == givrListParu.trEltList[k].iZU) && (0 == strcmp(tcDeplocarr,givrListParu.trEltList[k].dep)))
        {
        	/* même ligne avec ZU et dep de LF */
        	/* implicitement parution sur le pôle */
          GWTTrace (GWT_NIV_FONCT, ("Ajout ZU LF Ins [%d],[%d]\n", iGeo, MAX_LIST));
          if (MAX_LIST == iGeo)
          {
            /* Trop d'entrées internes */
            GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
            break;
          }
          (void)strcpy(givrListParu.trEltList[iGeo].rub, givrListParu.trEltList[k].rub);
          (void)strcpy(givrListParu.trEltList[iGeo].rubinit, givrListParu.trEltList[k].rubinit);
          (void)strcpy(givrListParu.trEltList[iGeo].nature,givrListParu.trEltList[k].nature);
          givrListParu.trEltList[iGeo].orig = givrListParu.trEltList[k].orig;
          givrListParu.trEltList[iGeo].cParuloc = givrListParu.trEltList[k].cParuloc;
          (void)strcpy(givrListParu.trEltList[iGeo].dep,givrListParu.trEltList[k].dep);
          (void)strcpy(givrListParu.trEltList[iGeo].loc,givrListParu.trEltList[k].loc);
          (void)strcpy(givrListParu.trEltList[iGeo].arr,"00");
          (void)strcpy(givrListParu.trEltList[iGeo].reg,givrListParu.trEltList[k].reg);
          givrListParu.trEltList[iGeo].iDbl = -1;
          givrListParu.trEltList[iGeo].iRgLigne = givrListParu.trEltList[k].iRgLigne ;
          givrListParu.trEltList[iGeo].iGeo = 99;
          givrListParu.trEltList[iGeo].iGeoReg = 99;
          givrListParu.trEltList[iGeo].iGeoDept = 99;
          givrListParu.trEltList[iGeo].iGeoLoc = 99;
          givrListParu.trEltList[iGeo].iGeoArr = 99;
          givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
          givrListParu.trEltList[iGeo].iZU = (int4)GIXCodeKO;
          givrListParu.trEltRangList[iGeo] = iGeo;
          iGeo++;
        }
      }
    }
  }

  givrListParu.iNbr = iGeo;

  return(iCodRet);
}


/*----------------------------------Fonction----------------------------------*
 * Fonction :  givTriGeo
 *
 * But : Tri des codes géographiques
 *
 * Description :
 * Fonction de tri des réponses en fonction d'un critère qui précise l'ordre
 * de priorité des tris
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres :
 *
 *	Valeurs retournées :
 *
 *	Erreurs :
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Jan/29/2008  (mb)
 *
 * Modification   (MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givTriGeo(GYBrDOCUMENT *doc, int4 indice, int4 iTri)
{

  int4 iCodRet;     /* Code retour de la fonction */
  int4 iIntRet;     /* Code retour interne */
  int4 iFinInst;
  int4 iFinParu;
  int4   iDblRegInst;
  int4   iDblDeptInst;
  int4   iDblLocInst;
  int4   iDblArrInst;
  int4   iDblRegParu;
  int4   iDblDeptParu;
  int4   iDblLocParu;
  int4   iDblArrParu;
  int4   iDblZU;
  int4 iGeoParu,iGeoInst;
  int4 iGeoArr,iGeoArrInst,iGeoLoc,iGeoDept,iGeoReg;
  int4 i,j,k,l,m,n;
  int4 ii,jj,kk,ll;
  int4 iIndCar;
  int4 iVal;
  int4 iRangRub,iRgRubDbl,iNbGeoRub,iRgGeoRub,iRangDeb,iNbrRub;
  iFinInst = (int4)GIXCodeKO;
  iFinParu = (int4)GIXCodeKO;
  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  /* doubles */
  iDblRegInst = (int4)GIXCodeKO;
  iDblDeptInst = (int4)GIXCodeKO;
  iDblLocInst = (int4)GIXCodeKO;
  iDblArrInst = (int4)GIXCodeKO;
  iDblRegParu = (int4)GIXCodeKO;
  iDblDeptParu = (int4)GIXCodeKO;
  iDblLocParu = (int4)GIXCodeKO;
  iDblArrParu = (int4)GIXCodeKO;
  iDblZU = (int4)GIXCodeKO;

  if (0 == givrListParu.iNbr)
  {
    /* pas de possibilité d'arrondissement d'installation local */
    /* Retourner sans erreur */
    return(iCodRet);
  }

  /* trier en fonction des codes de parution */
  qsort(givrListParu.trEltRangList,givrListParu.iNbr,sizeof(int4),givCompListParu);
  GWTTrace (GWT_NIV_FONCT, ("givTriGeo 1 \n"));

  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Parution [%d],[%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d]\n", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgLigne, givrListParu.trEltList[i].iRgObj, givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU));
  }
  /* supression objets hors tri */
  for(i=0; i<givrListParu.iNbr; i++)
  {
    j = givrListParu.trEltRangList[i];
    if (-1 ==  givrListParu.trEltList[j].iRangTri)
    {
      break;
    }
  }
  givrListParu.iNbr = i;
  if (0 == givrListParu.iNbr)
  {
    /* Retourner sans erreur */
    return(iCodRet);
  }
  /* trier en fonction des codes d'installation */
  qsort(givrListInst.trEltRangList,givrListInst.iNbr,sizeof(int4),givCompListInst);

  for(j=0; j<(givrListInst.iNbr); j++)
  {
    i = givrListInst.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Installation [%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\n", givrListInst.trEltList[i].iRangTri, givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc, givrListInst.trEltList[i].iGeoArr));
  }
  /* supression objets hors tri */
  for(i=0; i<givrListInst.iNbr; i++)
  {
    j = givrListInst.trEltRangList[i];
    if (-1 ==  givrListInst.trEltList[j].iRangTri)
    {
      break;
    }
  }
  givrListInst.iNbr = i;

  /* analyse de codes Locaux ou Extra-Locaux */
  i = 0;
  j = 0;
  k = givrListParu.trEltRangList[i];
  l = givrListInst.trEltRangList[j];
  kk = -1;
  ll = -1;
  while (((int4)GIXCodeKO == iFinInst) || ((int4)GIXCodeKO == iFinParu))
  {

    /* analyse changement de parution */
    iDblRegParu = (int4)GIXCodeKO;
    iDblDeptParu = (int4)GIXCodeKO;
    iDblLocParu = (int4)GIXCodeKO;
    iDblArrParu = (int4)GIXCodeKO;
    if (kk != k)
    {
      if ((0 != strcmp(givrListParu.trEltList[kk].reg,givrListParu.trEltList[k].reg)) || (0 == i) || (givrListParu.trEltList[kk].iRangTri != givrListParu.trEltList[k].iRangTri))
      {
        /* changement de reg */
        iDblRegParu = (int4)GIXCodeOK;
        iDblDeptParu = (int4)GIXCodeOK;
        iDblLocParu = (int4)GIXCodeOK;
        iDblArrParu = (int4)GIXCodeOK;
      }
      else if (0 != strcmp(givrListParu.trEltList[kk].dep,givrListParu.trEltList[k].dep))
      {
        /* changement de dept */
        iDblDeptParu = (int4)GIXCodeOK;
        iDblLocParu = (int4)GIXCodeOK;
        iDblArrParu = (int4)GIXCodeOK;
      }
      else if (0 != strcmp(givrListParu.trEltList[kk].loc,givrListParu.trEltList[k].loc))
      {
        /* changement de loc */
        iDblLocParu = (int4)GIXCodeOK;
        iDblArrParu = (int4)GIXCodeOK;
      }
      else if (0 != strcmp(givrListParu.trEltList[kk].arr,givrListParu.trEltList[k].arr))
      {
        /* changement d'arr */
        iDblArrParu = (int4)GIXCodeOK;
      }
    }

    /* analyse changement d'installation */
    iDblRegInst = (int4)GIXCodeKO;
    iDblDeptInst = (int4)GIXCodeKO;
    iDblLocInst = (int4)GIXCodeKO;
    iDblArrInst = (int4)GIXCodeKO;

    if (ll != l)
    {
      if ((0 != strcmp(givrListInst.trEltList[ll].reg,givrListInst.trEltList[l].reg)) || (0 == j) || (givrListInst.trEltList[ll].iRangTri != givrListInst.trEltList[l].iRangTri))
      {
        iDblArrInst = (int4)GIXCodeOK;
      }
      else if (0 != strcmp(givrListInst.trEltList[ll].dep,givrListInst.trEltList[l].dep))
      {
        iDblArrInst = (int4)GIXCodeOK;
      }
      else if (0 != strcmp(givrListInst.trEltList[ll].loc,givrListInst.trEltList[l].loc))
      {
        iDblArrInst = (int4)GIXCodeOK;
      }
      else if (0 != strcmp(givrListInst.trEltList[ll].arr,givrListInst.trEltList[l].arr))
      {
        iDblArrInst = (int4)GIXCodeOK;
      }
    }

    /* comparaison Parution/Installation */

    kk = k;
    ll = l;
    iGeoReg = 99;
    iGeoDept = 99;
    iGeoLoc = 99;
    iGeoArr = 99;
    iGeoArrInst = giv_INIT_ARR;

    if ((0 == strcmp(givrListParu.trEltList[k].reg,givrListInst.trEltList[l].reg)) && (givrListParu.trEltList[k].iRangTri == givrListInst.trEltList[l].iRangTri))
    {
      /* même région */

      if (0 == strcmp(givrListParu.trEltList[k].dep,givrListInst.trEltList[l].dep))
      {
        iGeoDept = giv_LOC;
        iGeoReg = giv_LOC;
        if (0 == strcmp(givrListParu.trEltList[k].loc,givrListInst.trEltList[l].loc))
        {
          /* inscription locale */
          iGeoLoc = giv_LOC;
          /* inscription locale : arr */
          if ((0 != strcmp("99",givrListInst.trEltList[l].arr)) && ((int4)GIXCodeOK != givrListParu.trEltList[k].iZU))
          {
            iGeoArrInst = giv_ARR;
          }

          if ((0 == strcmp(givrListInst.trEltList[l].arr,givrListParu.trEltList[k].arr)) && ((int4)GIXCodeKO == iFinParu))
          {
            /* même arrondissement */
            /* inscription locale : arr */
            if (0 != strcmp("99",givrListParu.trEltList[k].arr))
            {
              iGeoArr = giv_ARR;
            }
            /* arr paru suivant */
            i++;
          }
          else if ( ((0 < strcmp(givrListInst.trEltList[l].arr,givrListParu.trEltList[k].arr)) && ((int4)GIXCodeKO == iFinParu)) || ((int4)GIXCodeOK == iFinInst) )
          {
            /* arr inst > arr paru */
            /* différents arrondissements */
            if (0 != strcmp("99",givrListParu.trEltList[k].arr))
            {
              iGeoArr = giv_EXTL;
            }
            /* inscription locale : arr extra */
            /* arr paru suivant */
            i++;
          }
          else if ((0 > strcmp(givrListInst.trEltList[l].arr,givrListParu.trEltList[k].arr)) || ((int4)GIXCodeOK == iFinParu))

          {
            /* arr inst < arr paru */
            /* différents arrondissements */
            /* inscription locale : arr  */
            if (0 != strcmp("99",givrListParu.trEltList[k].arr))
            {
              iGeoArr = giv_EXTL;
            }
            /* arr inst suivant */
            j++;
          }
        }
        else if ( ((0 > strcmp(givrListParu.trEltList[k].loc,givrListInst.trEltList[l].loc)) && ((int4)GIXCodeKO == iFinParu)) || ((int4)GIXCodeOK == iFinInst) )
        {
          /* inscription départementale */
          /* loc inst > loc paru */
          /* différentes localités */
          iGeoLoc = giv_EXTL;
          if (0 != strcmp("99",givrListParu.trEltList[k].arr))
          {
            iGeoArr = giv_EXTL;
          }
          /* inscription dept : loc extra */
          /* loc paru suivante */
          i++;
        }
        else if ((0 < strcmp(givrListParu.trEltList[k].loc,givrListInst.trEltList[l].loc)) || ((int4)GIXCodeOK == iFinParu))
        {
          /* inscription départementale */
          /* loc inst < loc paru */
          iGeoLoc = giv_EXTL;
          if (0 != strcmp("99",givrListParu.trEltList[k].arr))
          {
            iGeoArr = giv_EXTL;
          }
          /* loc inst suivante */
          j++;
        }
      }

      else
      {
        /* inscription extra départementale */
        iGeoDept = giv_EXTL;
        iGeoLoc = giv_EXTL;
        if (0 != strcmp("99",givrListParu.trEltList[k].arr))
        {
          iGeoArr = giv_EXTL;
        }
        /* inscription régionale */
        iGeoReg = giv_LOC;

        if ( ((0 > strcmp(givrListParu.trEltList[k].dep,givrListInst.trEltList[l].dep)) && ((int4)GIXCodeKO == iFinParu)) || ((int4)GIXCodeOK == iFinInst) )
        {
          /* dept inst > dept paru */
          /* différents départements */
          /* inscription extra dept : dep extra */
          /* dept paru suivant */
          i++;
        }

        else if ((0 < strcmp(givrListParu.trEltList[k].dep,givrListInst.trEltList[l].dep)) || ((int4)GIXCodeOK == iFinParu))
        {
          /* dept inst < dept paru */
          /* dept inst suivant */
          j++;
        }

      }
    }
    else if (givrListParu.trEltList[k].iRangTri == givrListInst.trEltList[l].iRangTri)
    {
      /* différentes régions */
      /* inscription extra départementale */
      iGeoDept = giv_EXTL;
      iGeoLoc = giv_EXTL;
      if (0 != strcmp("99",givrListParu.trEltList[k].arr))
      {
        iGeoArr = giv_EXTL;
      }
      /* inscription extra-régionale */
      iGeoReg = giv_EXTL;

      if ( ((0 > strcmp(givrListParu.trEltList[k].reg,givrListInst.trEltList[l].reg)) && ((int4)GIXCodeKO == iFinParu)) || ((int4)GIXCodeOK == iFinInst) )
      {
        /* reg inst > reg paru */
        /* différents départements */
        /* inscription extra dept : dep extra */
        /* dept paru suivant */
        i++;
      }

      else if ((0 < strcmp(givrListParu.trEltList[k].reg,givrListInst.trEltList[l].reg)) || ((int4)GIXCodeOK == iFinParu))
      {
        /* reg inst < reg paru */
        /* dept inst suivant */
        j++;
      }

    }
    else
    {
      /* différentes rubriques */
      /* inscription extra départementale */
      iGeoDept = giv_EXTL;
      iGeoLoc = giv_EXTL;
      if (0 != strcmp("99",givrListParu.trEltList[k].arr))
      {
        iGeoArr = giv_EXTL;
      }
      /* inscription extra-régionale */
      iGeoReg = giv_EXTL;

      if ( ((givrListParu.trEltList[k].iRangTri < givrListInst.trEltList[l].iRangTri) && ((int4)GIXCodeKO == iFinParu)) || ((int4)GIXCodeOK == iFinInst) )
      {
        /* rub inst > rub paru */
        /* rub paru suivante */
        i++;
      }

      else if ( (givrListParu.trEltList[k].iRangTri > givrListInst.trEltList[l].iRangTri) || ((int4)GIXCodeOK == iFinParu) )
      {
        /* rub inst < rub paru */
        /* rub inst suivante */
        j++;
      }

    }

    /* pas d'arrondissement pour le pôle de zone urbaine */
    if (0 == strcmp("00",givrListParu.trEltList[k].arr))
    {
      iGeoArr = 99;
    }

    if (0 == strcmp("999",givrListParu.trEltList[k].dep))
    {
    	/* ancienne région : seule la parution sur région est validée */
      iGeoDept = 99;
      iGeoLoc = 99;
      iGeoArr = 99;
      iGeoArrInst = giv_INIT_ARR;
    }

    GWTTrace (GWT_NIV_FONCT, ("Parution [%d],[%d],[%d],[%d]\n",givrListParu.iNbr,i,givrListInst.iNbr,j));

    /* Analyse meilleur iGeo */
    if ((99 != givrListParu.trEltList[k].iGeoReg) && (iGeoReg < givrListParu.trEltList[k].iGeoReg))
    {
      iDblRegParu = (int4)GIXCodeOK;
    }
    if ((99 != givrListParu.trEltList[k].iGeoDept) && (iGeoDept < givrListParu.trEltList[k].iGeoDept))
    {
      iDblDeptParu = (int4)GIXCodeOK;
    }
    if ((99 != givrListParu.trEltList[k].iGeoLoc) && (iGeoLoc < givrListParu.trEltList[k].iGeoLoc))
    {
      iDblLocParu = (int4)GIXCodeOK;
    }
    if ((99 != givrListParu.trEltList[k].iGeoArr) && (iGeoArr < givrListParu.trEltList[k].iGeoArr))
    {
      iDblArrParu = (int4)GIXCodeOK;
    }
    if ((99 != givrListInst.trEltList[l].iGeoArr) && (iGeoArrInst < givrListInst.trEltList[l].iGeoArr))
    {
      iDblArrInst = (int4)GIXCodeOK;
    }


    /* Validation iGeo */
    if ((int4)GIXCodeOK == iDblRegParu)
    {
      /* changement de reg */
      givrListParu.trEltList[k].iGeoReg = iGeoReg;
    }
    if ((int4)GIXCodeOK == iDblDeptParu)
    {
      /* changement de dept */
      givrListParu.trEltList[k].iGeoDept = iGeoDept;
    }
    if ((int4)GIXCodeOK == iDblLocParu)
    {
      /* changement de loc */
      givrListParu.trEltList[k].iGeoLoc = iGeoLoc;
    }
    if (((int4)GIXCodeOK == iDblArrParu) && (0 != strcmp("99",givrListParu.trEltList[k].arr)))
    {
      /* changement d'arr */
      givrListParu.trEltList[k].iGeoArr = iGeoArr;
    }
    if ((int4)GIXCodeOK == iDblArrInst)
    {
      /* changement d'arr instal */
      givrListInst.trEltList[l].iGeoArr = iGeoArrInst;
    }


    if ((i < givrListParu.iNbr) && (j == givrListInst.iNbr) && (j != 0))
    {
      /* fin de liste installation */
      j--;
      iFinInst = (int4)GIXCodeOK;
    }
    else if ((i == givrListParu.iNbr) && (j < givrListInst.iNbr) && (i != 0))
    {
      /* fin de liste parution */
      i--;
      iFinParu = (int4)GIXCodeOK;
    }
    else if ((i == givrListParu.iNbr) && (j == givrListInst.iNbr))
    {
      /* fin de liste parution */
      iFinParu = (int4)GIXCodeOK;
      /* fin de liste installation */
      iFinInst = (int4)GIXCodeOK;
    }
    else
    {
      /* Parution suivante */
      k = givrListParu.trEltRangList[i];
      /* Installation suivante */
      l = givrListInst.trEltRangList[j];

      if (givrListParu.trEltList[kk].iRangTri != givrListParu.trEltList[k].iRangTri)
      {
        /* fin de rubrique dans liste parution */
        i--;
        iFinParu = (int4)GIXCodeOK;
      }
      if (givrListInst.trEltList[ll].iRangTri != givrListInst.trEltList[l].iRangTri)
      {
        /* fin de rubrique dans liste installation */
        j--;
        iFinInst = (int4)GIXCodeOK;
      }

      if (((int4)GIXCodeOK == iFinParu) && ((int4)GIXCodeOK == iFinInst))
      {
        iFinParu = (int4)GIXCodeKO;
        i++;
        iFinInst = (int4)GIXCodeKO;
        j++;
      }
    }

    /* Parution suivante */
    k = givrListParu.trEltRangList[i];
    /* Installation suivante */
    l = givrListInst.trEltRangList[j];

    GWTTrace (GWT_NIV_FONCT, ("Parution [%d],[%d]\n",i,j));

  }

  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Comp Parution [%s], [%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d]\n", givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU));
  }
  for(j=0; j<(givrListInst.iNbr); j++)
  {
    i = givrListInst.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Comp Installation [%s], [%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\n", givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc, givrListInst.trEltList[i].iGeoArr));
  }

  /* tranformation de codes Arr/Loc/Dept/Extra */
  /* rang géograhique par rubrique */
  iRgGeoRub = 0;
  iRangRub = 0;
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    if (iRangRub != givrListParu.trEltList[i].iRangTri)
    {
      iRangRub = givrListParu.trEltList[i].iRangTri;
      iRgGeoRub = 0;
    }

    if (99 != givrListParu.trEltList[i].iGeoReg)
    {
      iGeoReg = givrListParu.trEltList[i].iGeoReg;
    }
    if (99 != givrListParu.trEltList[i].iGeoDept)
    {
      iGeoDept = givrListParu.trEltList[i].iGeoDept;
    }
    if (99 != givrListParu.trEltList[i].iGeoLoc)
    {
      iGeoLoc = givrListParu.trEltList[i].iGeoLoc;
    }
    if (99 != givrListParu.trEltList[i].iGeoArr)
    {
      iGeoArr = givrListParu.trEltList[i].iGeoArr;
    }

    if (((int4)GIXCodeOK != iDblZU) && ((int4)GIXCodeOK == givrListParu.trEltList[i].iZU))
    {
        givrListParu.trEltList[i].iGeoReg = 99;
        givrListParu.trEltList[i].iGeoDept = 99;
        givrListParu.trEltList[i].iGeoLoc = 99;
        givrListParu.trEltList[i].iGeoArr = 99;
      iDblZU = (int4)GIXCodeOK;
    }
    else if (((int4)GIXCodeOK == iDblZU) && ((int4)GIXCodeOK == givrListParu.trEltList[i].iZU))
    {
      if ( (99 != givrListParu.trEltList[i].iGeoReg)
           || (99 != givrListParu.trEltList[i].iGeoDept)
           || (99 != givrListParu.trEltList[i].iGeoLoc)
           || (99 != givrListParu.trEltList[i].iGeoArr) )
      {
      	/* changement de ZU */
      }
        givrListParu.trEltList[i].iGeoReg = 99;
        givrListParu.trEltList[i].iGeoDept = 99;
        givrListParu.trEltList[i].iGeoLoc = 99;
        givrListParu.trEltList[i].iGeoArr = 99;
    }
    else if (((int4)GIXCodeOK == iDblZU) && ((int4)GIXCodeOK != givrListParu.trEltList[i].iZU))
    {
      if ( (99 == givrListParu.trEltList[i].iGeoReg)
           && (99 == givrListParu.trEltList[i].iGeoDept)
           && (99 == givrListParu.trEltList[i].iGeoLoc) )
      {
      	/* parution sur même ZU */
        givrListParu.trEltList[i].iZU = (int4)GIXCodeOK;
      }
        if (99 == givrListParu.trEltList[i].iGeoReg)
        {
          givrListParu.trEltList[i].iGeoReg = iGeoReg;
        }
        if (99 == givrListParu.trEltList[i].iGeoDept)
        {
          givrListParu.trEltList[i].iGeoDept = iGeoDept;
        }
        if (99 == givrListParu.trEltList[i].iGeoLoc)
        {
          givrListParu.trEltList[i].iGeoLoc = iGeoLoc;
        }
        if (99 == givrListParu.trEltList[i].iGeoArr)
        {
          givrListParu.trEltList[i].iGeoArr = iGeoArr;
        }
      iDblZU = (int4)GIXCodeKO;
    }

    if (giv_LOC == iGeoReg)
    {
      if (giv_LOC == iGeoDept)
      {
        if (giv_LOC == iGeoLoc)
        {
          if (99 != givrListParu.trEltList[i].iGeoReg)
          {
            givrListParu.trEltList[i].iGeoReg = giv_REG;
          }
          if (99 != givrListParu.trEltList[i].iGeoDept)
          {
            givrListParu.trEltList[i].iGeoDept = giv_DEPT;
          }
          if (99 != givrListParu.trEltList[i].iGeoLoc)
          {
            givrListParu.trEltList[i].iGeoLoc = giv_LOC;
          }
          if ((giv_EXTL == iGeoArr) && (99 != givrListParu.trEltList[i].iGeoArr))
          {
            givrListParu.trEltList[i].iGeoArr = giv_LOC;
          }
          else if ((giv_ARR == iGeoArr) && (99 != givrListParu.trEltList[i].iGeoArr))
          {
            givrListParu.trEltList[i].iGeoArr = giv_ARR;
          }
          else
          {
            givrListParu.trEltList[i].iGeoArr = 99;
          }
        }
        else
        {
          if (99 != givrListParu.trEltList[i].iGeoReg)
          {
            givrListParu.trEltList[i].iGeoReg = giv_REG;
          }
          if (99 != givrListParu.trEltList[i].iGeoDept)
          {
            givrListParu.trEltList[i].iGeoDept = giv_DEPT;
          }
          if (99 != givrListParu.trEltList[i].iGeoLoc)
          {
            givrListParu.trEltList[i].iGeoLoc = giv_DEPT;
          }
          if ((giv_EXTL == iGeoArr) && (99 != givrListParu.trEltList[i].iGeoArr))
          {
            givrListParu.trEltList[i].iGeoArr = giv_DEPT;
          }
          else
          {
            givrListParu.trEltList[i].iGeoArr = 99;
          }
        }
      }
      else
      {
        if (99 != givrListParu.trEltList[i].iGeoReg)
        {
          givrListParu.trEltList[i].iGeoReg = giv_REG;
        }
        if (99 != givrListParu.trEltList[i].iGeoDept)
        {
          givrListParu.trEltList[i].iGeoDept = giv_EXTL;
        }
        if (99 != givrListParu.trEltList[i].iGeoLoc)
        {
          givrListParu.trEltList[i].iGeoLoc = giv_EXTL;
        }
        if ((giv_EXTL == iGeoArr) && (99 != givrListParu.trEltList[i].iGeoArr))
        {
          givrListParu.trEltList[i].iGeoArr = giv_EXTL;
        }
        else
        {
          givrListParu.trEltList[i].iGeoArr = 99;
        }
      }
    }
    else
    {
      if (99 != givrListParu.trEltList[i].iGeoReg)
      {
        givrListParu.trEltList[i].iGeoReg = giv_EXTL;
      }
      if (99 != givrListParu.trEltList[i].iGeoDept)
      {
        givrListParu.trEltList[i].iGeoDept = giv_EXTL;
      }
      if (99 != givrListParu.trEltList[i].iGeoLoc)
      {
        givrListParu.trEltList[i].iGeoLoc = giv_EXTL;
      }
      if ((giv_EXTL == iGeoArr) && (99 != givrListParu.trEltList[i].iGeoArr))
      {
        givrListParu.trEltList[i].iGeoArr = giv_EXTL;
      }
      else
      {
        givrListParu.trEltList[i].iGeoArr = 99;
      }
    }
    if ( (99 == givrListParu.trEltList[i].iGeoReg)
         && (99 == givrListParu.trEltList[i].iGeoDept)
         && (99 == givrListParu.trEltList[i].iGeoLoc)
         && ( (98 == givrListParu.trEltList[i].iGeoArr)
              || (99 == givrListParu.trEltList[i].iGeoArr) ) )
    {
      givrListParu.trEltList[i].iRgGeoTri = -1;
    }
    else
    {
      givrListParu.trEltList[i].iRgGeoTri = iRgGeoRub;
      iRgGeoRub++;
    }
    if (0 == strcmp("999",givrListParu.trEltList[i].dep))
    {
    	/* ancienne région : seule la parution sur région est validée */
      givrListParu.trEltList[i].iGeoDept = giv_DFT;
      givrListParu.trEltList[i].iGeoLoc = giv_DFT;
      givrListParu.trEltList[i].iGeoArr = giv_DFT;
      givrListParu.trEltList[i].iGeoArr = giv_DFT;
    }
  }
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Parution Géo-Dénom [%s], [%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d]\n", givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU));
  }

  for(j=1; (j<(givrListParu.iNbr) && giv_RUB == iTri); j++)
  {
    /* restauration des iGeo pour dénom différentes */
    i = givrListParu.trEltRangList[j];
    ii = givrListParu.trEltRangList[j-1];
    if (99 == givrListParu.trEltList[i].iGeoReg)
    {
      givrListParu.trEltList[i].iGeoReg = givrListParu.trEltList[ii].iGeoReg;
    }
    if (99 == givrListParu.trEltList[i].iGeoDept)
    {
      givrListParu.trEltList[i].iGeoDept = givrListParu.trEltList[ii].iGeoDept;
    }
    if (99 == givrListParu.trEltList[i].iGeoLoc)
    {
      givrListParu.trEltList[i].iGeoLoc = givrListParu.trEltList[ii].iGeoLoc;
    }
    if (99 == givrListParu.trEltList[i].iGeoArr)
    {
      givrListParu.trEltList[i].iGeoArr = givrListParu.trEltList[ii].iGeoArr;
    }
    if (98 == givrListParu.trEltList[i].iGeoArr)
    {
      givrListParu.trEltList[i].iGeoArr = givrListParu.trEltList[ii].iGeoArr;
    }
  }
  for(j=0; (j<(givrListParu.iNbr) && giv_RUB == iTri); j++)
  {
    /* pas de restauration des iGeo pour iZU */
    i = givrListParu.trEltRangList[j];
    if ((-1 == givrListParu.trEltList[i].iRgGeoTri) && ((int4)GIXCodeOK == givrListParu.trEltList[i].iZU))
    {
      givrListParu.trEltList[i].iGeoReg = 99;
      givrListParu.trEltList[i].iGeoDept = 99;
      givrListParu.trEltList[i].iGeoLoc = 99;
      givrListParu.trEltList[i].iGeoArr = 99;
    }
  }
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Parution Géo-Dénom [%s], [%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d]\n", givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU));
  }

#if 0
  for(j=1; (j<(givrListInst.iNbr) && giv_RUB == iTri); j++)
  {
    /* restauration des iGeoArr d'installation pour dénom différentes */
    i = givrListInst.trEltRangList[j];
    ii = givrListInst.trEltRangList[j-1];
    if (99 == givrListInst.trEltList[i].iGeoArr)
    {
      givrListInst.trEltList[i].iGeoArr = givrListInst.trEltList[ii].iGeoArr;
    }
    if (98 == givrListInst.trEltList[i].iGeoArr)
    {
      givrListInst.trEltList[i].iGeoArr = givrListInst.trEltList[ii].iGeoArr;
    }
  }
#endif

  iRgGeoRub = 0;
  iRangRub = 0;
  for(j=0; j<(givrListInst.iNbr); j++)
  {
    i = givrListInst.trEltRangList[j];
    if (iRangRub != givrListInst.trEltList[i].iRangTri)
    {
      iRangRub = givrListInst.trEltList[i].iRangTri;
      iRgGeoRub = 0;
    }
    if ( (99 == givrListInst.trEltList[i].iGeoReg)
         && (99 == givrListInst.trEltList[i].iGeoDept)
         && (99 == givrListInst.trEltList[i].iGeoLoc)
         && ( (98 == givrListInst.trEltList[i].iGeoArr)
              || (99 == givrListInst.trEltList[i].iGeoArr) ) )
    {
      givrListInst.trEltList[i].iRgGeoTri = -1;
    }
    else
    {
      givrListInst.trEltList[i].iRgGeoTri = iRgGeoRub;
      iRgGeoRub++;
    }
  }


  /* nombre de rangs géographiques significatifs par rubrique */
  iNbGeoRub = 0;
  iRangRub = 0;
  iRangDeb = 0;
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    if (iRangRub != givrListParu.trEltList[i].iRangTri)
    {
      iRgGeoRub = 0;
      for(l=iRangDeb; l<j; l++)
      {
        k = givrListParu.trEltRangList[l];
        givrListParu.trEltList[k].iNbGeoTri = iNbGeoRub;
        if (-1 != givrListParu.trEltList[k].iRgGeoTri)
        {
          givrListParu.trEltList[k].iRgGeoTri = iRgGeoRub;
          iRgGeoRub++;
        }
      }
      iRangRub = givrListParu.trEltList[i].iRangTri;
      iNbGeoRub = 0;
      iRangDeb = j;
    }
    if (-1 != givrListParu.trEltList[i].iRgGeoTri)
    {
      iNbGeoRub++;
    }
    if ((givrListParu.iNbr - 1) == j)
    {
      iRgGeoRub = 0;
      for(l=iRangDeb; l<(givrListParu.iNbr) ; l++)
      {
        k = givrListParu.trEltRangList[l];
        givrListParu.trEltList[k].iNbGeoTri = iNbGeoRub;
        if (-1 != givrListParu.trEltList[k].iRgGeoTri)
        {
          givrListParu.trEltList[k].iRgGeoTri = iRgGeoRub;
          iRgGeoRub++;
        }
      }
    }
  }

  iNbGeoRub = 0;
  iRangRub = 0;
  iRangDeb = 0;
  for(j=0; j<(givrListInst.iNbr); j++)
  {
    i = givrListInst.trEltRangList[j];
    if (iRangRub != givrListInst.trEltList[i].iRangTri)
    {
      iRgGeoRub = 0;
      for(l=iRangDeb; l<j; l++)
      {
        k = givrListInst.trEltRangList[l];
        givrListInst.trEltList[k].iNbGeoTri = iNbGeoRub;
        if (-1 != givrListInst.trEltList[k].iRgGeoTri)
        {
          givrListInst.trEltList[k].iRgGeoTri = iRgGeoRub;
          iRgGeoRub++;
        }
      }
      iRangRub = givrListInst.trEltList[i].iRangTri;
      iNbGeoRub = 0;
      iRangDeb = j;
    }
    if (-1 != givrListInst.trEltList[i].iRgGeoTri)
    {
      iNbGeoRub++;
    }
    if ((givrListInst.iNbr - 1) == j)
    {
      iRgGeoRub = 0;
      for(l=iRangDeb; l<(givrListInst.iNbr) ; l++)
      {
        k = givrListInst.trEltRangList[l];
        givrListInst.trEltList[k].iNbGeoTri = iNbGeoRub;
        if (-1 != givrListInst.trEltList[k].iRgGeoTri)
        {
          givrListInst.trEltList[k].iRgGeoTri = iRgGeoRub;
          iRgGeoRub++;
        }
      }
    }
  }

  /* tri en fonction des tailles de blocs par geo/rub  */

  /* liste installation */
  qsort(givrListInst.trEltRangList,givrListInst.iNbr,sizeof(int4),givCompListInstTaille);

  if (giv_OBJ != iTri)
  {
    givrListInst.iNbrTot = givrListInst.iNbr;
  }
  for(j=0; j<(givrListInst.iNbr); j++)
  {
    i = givrListInst.trEltRangList[j];
    givrListInst.trEltList[i].iRgTriDbl = -1;
    if (-1 == givrListInst.trEltList[i].iRgGeoTri)
    {
      givrListInst.iNbr = j;
      break;
    }
  }

  GWTTrace (GWT_NIV_FONCT, ("givTriGeo 3 \n"));
  for(j=0; j<(givrListInst.iNbr); j++)
  {
    i = givrListInst.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Installation [%d],[%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\n", givrListInst.trEltList[i].iRgGeoTri, givrListInst.trEltList[i].iNbGeoTri, givrListInst.trEltList[i].iRangTri, givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc, givrListInst.trEltList[i].iGeoArr));
  }

  /* recherche des rubriques ayant même géographie */

  /* recherche des rubriques ayant même géographie */
  /* liste installation */

  j = 0;
  while( j < givrListInst.iNbr )
  {
    i = givrListInst.trEltRangList[j];
    if (-1 == givrListInst.trEltList[i].iRgTriDbl)
    {
      givrListInst.trEltList[i].iRgTriDbl = givrListInst.trEltList[i].iRangTri;
    }
    GWTTrace (GWT_NIV_FONCT, ("iRgRubDbl [%d]\n", givrListInst.trEltList[i].iRgTriDbl));
    iNbGeoRub = givrListInst.trEltList[i].iNbGeoTri;
    l = j + iNbGeoRub;
    k = givrListInst.trEltRangList[l];
    while( (l < givrListInst.iNbr) && (givrListInst.trEltList[i].iRangTri == givrListInst.trEltList[i].iRgTriDbl) )
    {
      if ((givrListInst.trEltList[i].iNbGeoTri != givrListInst.trEltList[k].iNbGeoTri) || (-1 != givrListInst.trEltList[k].iRgTriDbl))
      {
        /* tailles différentes ou déjà doublé */
        iNbGeoRub = givrListInst.trEltList[k].iNbGeoTri;
        l = l + iNbGeoRub;
        k = givrListInst.trEltRangList[l];
      }
      else
      {
        /* même taille */
        for(m=0; m<iNbGeoRub; m++)
        {
          if (givrListInst.trEltList[givrListInst.trEltRangList[j + m]].iRgGeoTri != givrListInst.trEltList[givrListInst.trEltRangList[l + m]].iRgGeoTri)
          {
            /* rangs différents */
            break;
          }
          if (0 != strcmp(givrListInst.trEltList[givrListInst.trEltRangList[j + m]].reg ,givrListInst.trEltList[givrListInst.trEltRangList[l + m]].reg))
          {
            break;
          }
          if (0 != strcmp(givrListInst.trEltList[givrListInst.trEltRangList[j + m]].dep ,givrListInst.trEltList[givrListInst.trEltRangList[l + m]].dep))
          {
            break;
          }
          if (0 != strcmp(givrListInst.trEltList[givrListInst.trEltRangList[j + m]].loc ,givrListInst.trEltList[givrListInst.trEltRangList[l + m]].loc))
          {
            break;
          }
          if (0 != strcmp(givrListInst.trEltList[givrListInst.trEltRangList[j + m]].arr ,givrListInst.trEltList[givrListInst.trEltRangList[l + m]].arr))
          {
            break;
          }
          if (givrListInst.trEltList[givrListInst.trEltRangList[j + m]].iGeoArr != givrListInst.trEltList[givrListInst.trEltRangList[l + m]].iGeoArr)
          {
            break;
          }
        }
        if (m == iNbGeoRub)
        {
          /* égalité complète des rubriques */
          givrListInst.trEltList[k].iRgTriDbl = givrListInst.trEltList[i].iRgTriDbl;
          /* nombre de rubriques */
          GWTTrace (GWT_NIV_FONCT, ("Partie 3 Nombre de rubriques [%d]\n", givrListInst.iNbrTri));
        }
        GWTTrace (GWT_NIV_FONCT, ("iRgRubDbl [%d]\n", givrListInst.trEltList[k].iRgTriDbl));

        /* rubrique suivante */
        iNbGeoRub = givrListInst.trEltList[k].iNbGeoTri;
        l = l + iNbGeoRub;
        k = givrListInst.trEltRangList[l];
      }

    }
    iNbGeoRub = givrListInst.trEltList[i].iNbGeoTri;
    j = j + iNbGeoRub;
  }
  for(j=0; (j<givrListInst.iNbr && giv_RUB == iTri); j++)
  {
    /* restauration de iRgTriDbl */
    jj = givrListInst.trEltRangList[j];
    if (-1 != givrListInst.trEltList[jj].iRgTriDbl)
    {
      ii = jj;
    }

    else
    {
      givrListInst.trEltList[jj].iRgTriDbl = givrListInst.trEltList[ii].iRgTriDbl;
    }
  }
  for(j=givrListInst.iNbr; (j<givrListInst.iNbrTot && giv_RUB == iTri); j++)
  {
    /* restauration de iRgTriDbl */
    jj = givrListInst.trEltRangList[j];
    for(i=0; i<givrListInst.iNbr; i++)
    {
      ii = givrListInst.trEltRangList[i];
      if (givrListInst.trEltList[ii].iRangTri == givrListInst.trEltList[jj].iRangTri)
      {
      	givrListInst.trEltList[jj].iRgTriDbl = givrListInst.trEltList[ii].iRgTriDbl;
      	break;
      }
    }
  }


  /* recherche des rubriques ayant même géographie */
  /* listes parution et installation confondues */

  for (j = 0 ;j < givrListParu.iNbr; j++)
  {
    i = givrListParu.trEltRangList[j];
    /* même rubrique parution/installation */
    for (l = 0 ;l < givrListInst.iNbr; l++)
    {
      k = givrListInst.trEltRangList[l];
      if (givrListParu.trEltList[i].iRangTri == givrListInst.trEltList[k].iRangTri)
      {
        givrListParu.trEltList[i].iRgTriDblBis = givrListInst.trEltList[k].iRgTriDbl;
        break;
      }
    }
    if (givrListInst.iNbr == l)
    {
      /* pas de rubrique installation */
      givrListParu.trEltList[i].iRgTriDblBis = -1;
    }
    GWTTrace (GWT_NIV_FONCT, ("iRgRubDblBis [%d]\n", givrListParu.trEltList[i].iRgTriDblBis));
  }

  /* tri en fonction des tailles de blocs par geo/rub  */
  /* liste parution */
  qsort(givrListParu.trEltRangList,givrListParu.iNbr,sizeof(int4),givCompListParuTaille);
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Parution Tri Taille[%d],[%d],[%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d],[%d]\n", givrListParu.trEltList[i].iRgGeoTri, givrListParu.trEltList[i].iNbGeoTri, givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgTriDbl, givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].iRgLigne));
  }

  if (giv_RUB == iTri)
  {
    /* il peut y avoir des objets hors tri */
    givrListParu.iNbrTot = givrListParu.iNbr;
  }
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    givrListParu.trEltList[i].iRgTriDbl = -1;
    if (-1 == givrListParu.trEltList[i].iRgGeoTri)
    {
      givrListParu.iNbr = j;
      break;
    }
  }
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Parution Tri Taille[%d],[%d],[%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d],[%d]\n", givrListParu.trEltList[i].iRgGeoTri, givrListParu.trEltList[i].iNbGeoTri, givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgTriDbl, givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].iRgLigne));
  }

  /* recherche des rubriques ayant même géographie */

  /* liste parution */
  j = 0;
  while( j < givrListParu.iNbr )
  {
    i = givrListParu.trEltRangList[j];
    if (-1 == givrListParu.trEltList[i].iRgTriDbl)
    {
      givrListParu.trEltList[i].iRgTriDbl = givrListParu.trEltList[i].iRangTri;
    }
    GWTTrace (GWT_NIV_FONCT, ("iRgRubDbl [%d],[%d]\n", givrListParu.trEltList[i].iRgTriDbl,givrListParu.trEltList[i].iRangTri));

    iNbGeoRub = givrListParu.trEltList[i].iNbGeoTri;
    l = j + iNbGeoRub;
    k = givrListParu.trEltRangList[l];
    while( (l < givrListParu.iNbr) && (givrListParu.trEltList[i].iRangTri == givrListParu.trEltList[i].iRgTriDbl) )
    {
      if ((givrListParu.trEltList[i].iNbGeoTri != givrListParu.trEltList[k].iNbGeoTri) || (-1 != givrListParu.trEltList[k].iRgTriDbl))
      {
        /* tailles différentes ou déjà doublé */
        iNbGeoRub = givrListParu.trEltList[k].iNbGeoTri;
        l = l + iNbGeoRub;
        k = givrListParu.trEltRangList[l];
      }
      else if (givrListParu.trEltList[i].iRgTriDblBis != givrListParu.trEltList[k].iRgTriDblBis)
      {
        /* installations différentes */
        iNbGeoRub = givrListParu.trEltList[k].iNbGeoTri;
        l = l + iNbGeoRub;
        k = givrListParu.trEltRangList[l];
      }
      else
      {
        /* même taille */
        for(m=0; m<iNbGeoRub; m++)
        {
          if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].iRgGeoTri != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].iRgGeoTri)
          {
            /* rangs différents */
            break;
          }
          if (0 != strcmp(givrListParu.trEltList[givrListParu.trEltRangList[j + m]].reg ,givrListParu.trEltList[givrListParu.trEltRangList[l + m]].reg))
          {
            break;
          }
          if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].iGeoReg != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].iGeoReg)
          {
            break;
          }
          if (0 != strcmp(givrListParu.trEltList[givrListParu.trEltRangList[j + m]].dep ,givrListParu.trEltList[givrListParu.trEltRangList[l + m]].dep))
          {
            break;
          }
          if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].iGeoDept != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].iGeoDept)
          {
            break;
          }
          if (0 != strcmp(givrListParu.trEltList[givrListParu.trEltRangList[j + m]].loc ,givrListParu.trEltList[givrListParu.trEltRangList[l + m]].loc))
          {
            break;
          }
          if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].iGeoLoc != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].iGeoLoc)
          {
            break;
          }
          if (0 != strcmp(givrListParu.trEltList[givrListParu.trEltRangList[j + m]].arr ,givrListParu.trEltList[givrListParu.trEltRangList[l + m]].arr))
          {
            break;
          }
          if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].iGeoArr != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].iGeoArr)
          {
            break;
          }
          if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].iZU != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].iZU)
          {
            break;
          }
          if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].cParuloc != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].cParuloc)
          {
            break;
          }
        }

        if (m == iNbGeoRub)
        {
          /* égalité complète des rubriques */
          givrListParu.trEltList[k].iRgTriDbl = givrListParu.trEltList[i].iRgTriDbl;
          /* nombre de rubriques */
          GWTTrace (GWT_NIV_FONCT, ("Partie 3 Nombre de rubriques [%d]\n", givrListParu.iNbrTri));
        }
        GWTTrace (GWT_NIV_FONCT, ("iRgRubDbl [%d],[%d]\n", givrListParu.trEltList[k].iRgTriDbl,givrListParu.trEltList[k].iRangTri));

        /* rubrique suivante */
        iNbGeoRub = givrListParu.trEltList[k].iNbGeoTri;
        l = l + iNbGeoRub;
        k = givrListParu.trEltRangList[l];
      }

    }
    iNbGeoRub = givrListParu.trEltList[i].iNbGeoTri;
    j = j + iNbGeoRub;
  }
  for(j=0; (j<givrListParu.iNbr && giv_RUB == iTri); j++)
  {
    /* restauration de iRgTriDbl */
    jj = givrListParu.trEltRangList[j];
    if (-1 != givrListParu.trEltList[jj].iRgTriDbl)
    {
      ii = jj;
    }

    else
    {
      givrListParu.trEltList[jj].iRgTriDbl = givrListParu.trEltList[ii].iRgTriDbl;
    }
  }
  for(j=givrListParu.iNbr; (j<givrListParu.iNbrTot && giv_RUB == iTri); j++)
  {
    /* restauration de iRgTriDbl */
    jj = givrListParu.trEltRangList[j];
    for(i=0; i<givrListParu.iNbr; i++)
    {
      ii = givrListParu.trEltRangList[i];
      if (givrListParu.trEltList[ii].iRangTri == givrListParu.trEltList[jj].iRangTri)
      {
      	givrListParu.trEltList[jj].iRgTriDbl = givrListParu.trEltList[ii].iRgTriDbl;
      	break;
      }
    }
  }

        GWTTrace (GWT_NIV_FONCT, ("Nb Parution [%d],[%d]\n", givrListParu.iNbrTot,givrListParu.iNbr));
  for(j=0; j<(givrListParu.iNbrTot); j++)
  {
    i = givrListParu.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Parution [%d],[%d],[%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d],[%d],[%d]\n", givrListParu.trEltList[i].iRgGeoTri, givrListParu.trEltList[i].iNbGeoTri, givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgTriDbl, givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].iRgLigne, givrListParu.trEltList[i].iRgObj));
  }

        GWTTrace (GWT_NIV_FONCT, ("Nb Installation [%d],[%d]\n", givrListInst.iNbrTot,givrListInst.iNbr));
  for(j=0; j<(givrListInst.iNbrTot); j++)
  {
    i = givrListInst.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Installation [%d],[%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\n", givrListInst.trEltList[i].iRgGeoTri, givrListInst.trEltList[i].iNbGeoTri, givrListInst.trEltList[i].iRangTri, givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc, givrListInst.trEltList[i].iGeoArr));
  }



/* Retourner sans erreur */
  return(iCodRet);
}

int4 givPreparerRequetesIeBloc()
{
  int4			iCodRet = (int4)GIXCodeOK;	/* Code retour de la fonction */
  int4			iIntRet = (int4)GIXCodeOK;	/* Code retour des appels internes */
  EXEC SQL begin declare section;
  char          tcRequete[1024];
  EXEC SQL end declare section ;
  static int4 iDejaPrepare = (int4)GWCCodeKO;

  if ( (int4)GWCCodeOK != iDejaPrepare )
  {
    /* suppressions */
    (void)sprintf ( tcRequete, GIV_DEL_IEBLOC, GIXcNomDest );
    EXEC SQL prepare rqtDelIeBloc from :tcRequete;

    (void)sprintf ( tcRequete, GIV_DEL_IEBLOC_CRC, GIXcNomDest );
    EXEC SQL prepare rqtDelIeBlocCRC from :tcRequete;

    iDejaPrepare = (int4)GWCCodeOK;
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerRequetesIeBloc\n"));

  return (iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLecturePELREP ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche du libelle de       */
/*             localite a partir du code localite dans la table GYTtabPelrep  */
/*             		                                                      */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

extern int4 givPreparerLectureLocAtt (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureLocAtt\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_LIB_LJLORN);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_LIB_LJLORN);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureLocAtt
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureLocAtt");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureLocAtt : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureLocAtt");
      EXEC SQL
      declare crsLectureLocAtt cursor for rqtLectureLocAtt;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureLocAtt ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_LOC_DEP);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_LOC_DEP);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureLocDep
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureLocDep");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureLocDep : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureLocDep");
      EXEC SQL
      declare crsLectureLocDep cursor for rqtLectureLocDep;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureLocDep ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureLocAtt\n"));

  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureTypeURL ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche du type de          */
/*             l'URL a partir du numero d'objet dans la table GYTtabPemicURL  */
/*             		                                                      */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

extern int4 givPreparerLectureTypeURL (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureTypeURL\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_TYPE_URL);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_TYPE_URL);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureTypeURL
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureTypeURL");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureTypeURL : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureTypeURL");
      EXEC SQL
      declare crsLectureTypeURL cursor for rqtLectureTypeURL;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureTypeURL ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureTypeURL\n"));

  return (iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureEtab ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche des  données        */
/*             à partir de l'établissement dans les tables GYTtabPeetab,      */
/*             GYTtabEpjMic et GYTTabLiensEtab                                */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

extern int4 givPreparerLectureEtab (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE*4];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureEtabMC\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_ETAB_MC);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_ETAB_MC);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureEtabMC
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureEtabMC");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureEtabMC : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureEtabMC");
      EXEC SQL
      declare crsLectureEtabMC cursor for rqtLectureEtabMC;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureEtabMC ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_SIREN);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_SIREN);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureSiren
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureSiren");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureSirenC : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureSiren");
      EXEC SQL
      declare crsLectureSiren cursor for rqtLectureSiren;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureSiren ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_ETAB);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_ETAB);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureEtab
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureEtab");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureEtab : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureEtab");
      EXEC SQL
      declare crsLectureEtab cursor for rqtLectureEtab;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureEtab ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_DENOM_ETAB);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_DENOM_ETAB);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureDenomEtab
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureDenomEtab");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureDenomEtab : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureDenomEtab");
      EXEC SQL
      declare crsLectureDenomEtab cursor for rqtLectureDenomEtab;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureDenomEtab ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_PHOTOS_ETAB);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_PHOTOS_ETAB);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLecturePhotosEtab
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLecturePhotosEtab");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLecturePhotosEtab : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLecturePhotosEtab");
      EXEC SQL
      declare crsLecturePhotosEtab cursor for rqtLecturePhotosEtab;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLecturePhotosEtab ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_PUB_ETAB);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_PUB_ETAB);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLecturePubEtab
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLecturePubEtab");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLecturePubEtab : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLecturePubEtab");
      EXEC SQL
      declare crsLecturePubEtab cursor for rqtLecturePubEtab;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLecturePubEtab ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_PUB_GCPT);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_PUB_GCPT);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLecturePubGCpt
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLecturePubGCpt");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLecturePubGCpt : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLecturePubGCpt");
      EXEC SQL
      declare crsLecturePubGCpt cursor for rqtLecturePubGCpt;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLecturePubGCpt ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_PEETAB);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_PEETAB);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLecturePeEtab
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLecturePeEtab");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLecturePeEtab : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLecturePeEtab");
      EXEC SQL
      declare crsLecturePeEtab cursor for rqtLecturePeEtab;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLecturePeEtab ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_OLD_ETAB);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_OLD_ETAB);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureOldEtab
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureOldEtab");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureOldEtab : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureOldEtab");
      EXEC SQL
      declare crsLectureOldEtab cursor for rqtLectureOldEtab;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureOldEtab ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }
    /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_SLC_CONT_PROF_ETAB);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_SLC_CONT_PROF_ETAB);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureContProfEtab
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureContProfEtab");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureContProfEtab : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureContProfEtab");
      EXEC SQL
      declare crsLectureContProfEtab cursor for rqtLectureContProfEtab;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureContProfEtab ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_SLC_TYP_CONT_ETAB);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_SLC_TYP_CONT_ETAB);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureTypContEtab
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureTypCont");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureTypContEtab : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureTypContEtab");
      EXEC SQL
      declare crsLectureTypContEtab cursor for rqtLectureTypContEtab;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureTypContEtab ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_SLC_LVS_SEO_ETAB);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_SLC_LVS_SEO_ETAB);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureLvsSeoEtab
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureLvsSeo");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureLvsSeoEtab : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureLvsSeoEtab");
      EXEC SQL
      declare crsLectureLvsSeoEtab cursor for rqtLectureLvsSeoEtab;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureLvsSeoEtab ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }


  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_SLC_LIENS_PROD_ETAB);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_SLC_LIENS_PROD_ETAB);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureLiensEtab
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureLiensEtab");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureLiensEtab : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureLiensEtab");
      EXEC SQL
      declare crsLectureLiensEtab cursor for rqtLectureLiensEtab;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureLiensEtab ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureEtab/ContenusEtab/EtabMC/SIRET/Pub/Old/LvsSeo/LiensEtab\n"));

  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureEmbauche ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de                  */
/*             ref à partir de numcli dans la table GYTtabEmbauche            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureEmbauche (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureEmbauche\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_EMBAUCHE);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_EMBAUCHE);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureEmbauche
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureEmbauche");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureEmbauche : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureEmbauche");
      EXEC SQL
      declare crsLectureEmbauche cursor for rqtLectureEmbauche;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureEmbauche ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureEmbauche\n"));

  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureStat ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche du                  */
/*             code statistique de l'annonceur                                */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureStat (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureStat\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_STAT);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_STAT);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureStat
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureStat");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureStat : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureStat");
      EXEC SQL
      declare crsLectureStat cursor for rqtLectureStat;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureStat ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureStat\n"));

  return (iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureImag ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche du                  */
/*             nombre d'images pour le produit PVI                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureImag (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureImag\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_IMAG);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_IMAG);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureImag
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureImag");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureImag : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureImag");
      EXEC SQL
      declare crsLectureImag cursor for rqtLectureImag;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureImag ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureImag\n"));

  return (iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureMotsCles ()	              		              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche du                  */
/*             crc mots cles                                                  */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureMotsCles (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureImag\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_SLC_MOT_CLE);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_SLC_MOT_CLE);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureMCles
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureMCles");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureMCles : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureMCles");
      EXEC SQL
      declare crsLectureMCles cursor for rqtLectureMCles;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureMCles ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureMCles\n"));

  return (iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureBonPlan ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de                  */
/*             ref à partir de etab dans la table GYTtabBonPlan               */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureBonPlan (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE*2];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureBonPlan\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_BONPLAN_PUB);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_BONPLAN_PUB);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureBonPlanPub
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureBonPlanPub");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureBonPlanPub : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureBonPlanPub");
      EXEC SQL
      declare crsLectureBonPlanPub cursor for rqtLectureBonPlanPub;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureBonPlanPub ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureBonPlan\n"));

  return (iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureBUC ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de                  */
/*             numcli à partir de etab dans la table GYTtabIeInsc             */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureBUC ()

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureBUC\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_BUC);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_BUC);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureBUC
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureBUC");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureBUC : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureBUC");
      EXEC SQL
      declare crsLectureBUC cursor for rqtLectureBUC;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureBUC ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureBUC\n"));

  return (iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureSEO ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de                  */
/*             numcli à partir de etab dans la table GYTtabIeInsc             */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureSEO (char *apcDepart)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;
  char          conf[50];
  char *pChar;
  char tcClause[GWT_LG_MAX_LIGNE];
  char    tcBlocDoc[4]; /* destinataire bloc doc associé */

  EXEC SQL begin declare section;
  char cRequete[6*giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureSEO\n"));

  (void) sprintf(conf, "%s_%s","GIV_BLOC_DOC_EPJ",GIXcNomDest);
  iIntRet = GWTLireConf(conf, tcBlocDoc);
  if ( GWTok != iIntRet )
  {
    (void)strcpy(tcBlocDoc, GIXcNomDest);
  }
  GWTTrace(GWT_NIV_FONCT,("Destinataire des blocs Pertimm : %s\n",tcBlocDoc));

  /* Préparer la requête de version */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "select version de bloc");

  (void)sprintf ( cRequete, GIV_VERS_SEO, tcBlocDoc );
  EXEC SQL prepare rqtVersSEO from :cRequete;

  EXEC SQL DECLARE crsVersSEO CURSOR FOR rqtVersSEO;

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  (void) sprintf(conf, "%s_%s","GIV_CLAUSE_SEO_SERVICE",GIXcNomDest);
  if (0 != GWTLireConf(conf,&givtcClause[0]))
  {
    strcpy(givtcClause,"");
  }
  pChar = &givtcClause[0];
  while(*pChar!=0)
  {
    if ('@'==*pChar) {*pChar='=';}
    pChar++;
  }
  GWTTrace(GWT_NIV_FONCT,("La clause where SEO_SERVICE est : [%s],%d\n",givtcClause,strlen(givtcClause)));
  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_SRV_SEO)+strlen (givtcClause);
  iLgBuffer = sizeof (cRequete);

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
    GWTTrace (GWT_NIV_GRAVE,
            ("SEO_SERVICE : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_SRV_SEO,givtcClause);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureSrvSEO
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureSrvSEO");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureSrvSEO : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureSrvSEO");
      EXEC SQL
      declare crsLectureSrvSEO cursor for rqtLectureSrvSEO;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureSrvSEO ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }
  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_DNOM_PRINC);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_DNOM_PRINC,GIXcNomFour,GIXcNomDest,apcDepart,GIXcNomFour,GIXcNomDest,apcDepart,GIXcNomFour,GIXcNomDest,apcDepart);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureDnomPrinc
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureDnomPrinc");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureDnomPrinc : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureDnomPrinc");
      EXEC SQL
      declare crsLectureDnomPrinc cursor for rqtLectureDnomPrinc;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureDnomPrinc ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }


  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureSEO\n"));

  return (iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureExtraLoc ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de                  */
/*             extra loc à partir de etab dans la table GYTtabIeInsc          */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureExtraLoc (char *apcDepart)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[6*giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureExtraLoc\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_EXTRA_LOC_IS);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_EXTRA_LOC_IS,GIXcNomFour,GIXcNomDest,apcDepart,GIXcNomFour,GIXcNomDest,apcDepart,GIXcNomFour,GIXcNomDest,apcDepart);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureExtraLocIS
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureExtraLocIS");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureExtraLocIS : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureExtraLocIS");
      EXEC SQL
      declare crsLectureExtraLocIS cursor for rqtLectureExtraLocIS;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureExtraLocIS ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_EXTRA_LOC_INTER_IS);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_EXTRA_LOC_INTER_IS,GIXcNomFour,GIXcNomDest,apcDepart,GIXcNomFour,GIXcNomDest,apcDepart,GIXcNomFour,GIXcNomDest,apcDepart);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureExtraLocInterIS
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureExtraLocInterIS");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureExtraLocInterIS : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureExtraLocIS");
      EXEC SQL
      declare crsLectureExtraLocInterIS cursor for rqtLectureExtraLocInterIS;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureExtraLocInterIS ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_EXTRA_LOC_IO);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_EXTRA_LOC_IO,GIXcNomFour,GIXcNomDest,apcDepart,GIXcNomFour,GIXcNomDest,apcDepart,GIXcNomFour,GIXcNomDest,apcDepart,GIXcNomFour,GIXcNomDest,apcDepart,GIXcNomFour,GIXcNomDest,apcDepart);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureExtraLocIO
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureExtraLocIO");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureExtraLocIO : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureExtraLocIO");
      EXEC SQL
      declare crsLectureExtraLocIO cursor for rqtLectureExtraLocIO;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureExtraLocIO ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }


  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureExtraLoc\n"));

  return (iCodRet);
}



/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureEvIlo ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de                  */
/*             ref à partir de etab dans la table GYTtabEvIlo                 */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureEvIlo (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureEvIlo\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_EVILO);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_EVILO);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureEvIlo
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureEvIlo");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureEvIlo : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureEvIlo");
      EXEC SQL
      declare crsLectureEvIlo cursor for rqtLectureEvIlo;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureEvIlo ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureEvIlo\n"));

  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureSIRET ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche du type de          */
/*             SIRET a partir de la table GYTtabPagesPro                      */
/*             		                                                      */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

extern int4 givPreparerLectureSIRET (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureSIRET\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_SIRET);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_SIRET);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureSIRET
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureSIRET");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureSIRET : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureSIRET");
      EXEC SQL
      declare crsLectureSIRET cursor for rqtLectureSIRET;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureSIRET ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureSIRET\n"));

  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureOppositionPart ()		              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de                  */
/*             l'opposition à partir du partenaire dans table GYTtabOppPart   */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureOppositionPart (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureOppositionPart\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_OPP_PART);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_OPP_PART);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureOppPart
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureOppositionPart");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureOppositionPart : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureOppositionPart");
      EXEC SQL
      declare crsLectureOppPart cursor for rqtLectureOppPart;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureOppPart ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureOppositionPart\n"));

  return (iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureOppositionsURLGratuite ()		      */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de                  */
/*             l'opposition dans tables GYTTabURLGrOpp et GYTTabURLGrProf     */
/*             pour les contenus de type GS                                   */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureOppositionsURLGratuite (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureOppositionsURLGratuite\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_OPP_URLGR);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_OPP_URLGR);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureOppURLGr
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureOppURLGr");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureOppURLGr : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureOppURLGr");
      EXEC SQL
      declare crsLectureOppURLGr cursor for rqtLectureOppURLGr;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureOppURLGr ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_PROF_URLGR);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_PROF_URLGR);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureProfURLGr
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureProfURLGr");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureProfURLGr : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureProfURLGr");
      EXEC SQL
      declare crsLectureProfURLGr cursor for rqtLectureProfURLGr;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureProfURLGr ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureOppositionsURLGratuite\n"));

  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLecturePrioProfCRC ()         		      */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de                  */
/*             priorité selon CRC et An8 dans table GYTTabCRCProfPrio         */
/*             pour les contenus                                              */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLecturePrioProfCRC (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLecturePrioProfCRC\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_PRIO_PROF_CRC);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_PRIO_PROF_CRC);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLecturePrioProfCRC
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLecturePrioProfCRC");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLecturePrioProfCRC : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLecturePrioProfCRC");
      EXEC SQL
      declare crsLecturePrioProfCRC cursor for rqtLecturePrioProfCRC;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLecturePrioProfCRC ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_BL_CRC_LR);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_BL_CRC_LR);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureBLCRCLR
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureBLCRCLR");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureBLCRCLR : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureBLCRCLR");
      EXEC SQL
      declare crsLectureBLCRCLR cursor for rqtLectureBLCRCLR;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureBLCRCLR ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_BL_EPJ_FD);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_BL_EPJ_FD);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureBLEPJFD
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureBLEPJFD");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureBLEPJFD : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureBLEPJFD");
      EXEC SQL
      declare crsLectureBLEPJFD cursor for rqtLectureBLEPJFD;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureBLEPJFD ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_BL_CRC_FD);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_BL_CRC_FD);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureBLCRCFD
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureBLCRCFD");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureBLCRCFD : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureBLCRCFD");
      EXEC SQL
      declare crsLectureBLCRCFD cursor for rqtLectureBLCRCFD;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureBLCRCFD ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_BL_EPJ_PROF);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_BL_EPJ_PROF);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureBLEPJProf
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureBLEPJProf");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureBLEPJProf : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureBLEPJProf");
      EXEC SQL
      declare crsLectureBLEPJProf cursor for rqtLectureBLEPJProf;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureBLEPJProf ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

/* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLecturePrioProfCRC\n"));

  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerSynonyme ()	     		                                */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de                  */
/*             synomymes d'une dénomination                                   */
/*             dans la table GYTtabDenomSynonyme                              */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerSynonyme ()

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[6*giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerSynonyme\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)giv_LG_REQUETE);


  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIVRequeteSyno);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    strcpy (cRequete, GIVRequeteSyno);
    GWTTrace (GWT_NIV_FONCT,
              ("Requete SQL Paruadr : %s\n", cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureSyno
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureSyno");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureSyno : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureSyno");
      EXEC SQL
      declare crsLectureSyno cursor for rqtLectureSyno;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureSyno ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerSynonyme\n"));

  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : supprimer_doublon                                              */
/*                                                                            */
/* But       : supprimer les doublons dans les champs de critere selection    */
/*                                                                            */
/* Entree(s) : le buffer                                                      */
/*                                                                            */
/* Sortie(s) : le même buffer                                                 */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 supprimer_doublon(char * liste, char delim)
{

  char *pt_fin_liste;
  char *pt_debut_element;
  char *pt_fin_element;
  char *pt_debut_doublon;
  char *pt_fin_doublon;
  int4 lg_element;
  int4 lg_doublon;
  GWTTrace (GWT_NIV_FONCT,
              ("Taille buffer doublons : %d\n",
               strlen(liste)));
  if (strlen(liste) >= sizeof(buf_concat))
  {
    GWTTrace (GWT_NIV_GRAVE,
              ("Buffer doublons : %s\n",
               liste));
    GWTTrace (GWT_NIV_GRAVE,
              ("Buffer doublons : %d,%s\n",
               strlen(buf_concat),buf_concat));
    return(strlen(liste));
  }
  pt_fin_liste=liste+strlen(liste);

  for (pt_debut_element=liste; pt_debut_element < pt_fin_liste; )
  {
    pt_fin_element=strchr(pt_debut_element, delim);
                if (pt_fin_element == 0)
                {
                        pt_fin_element=pt_fin_liste;

                }
                else
                {
                        lg_element=pt_fin_element-pt_debut_element;
                        /* suppression des doublons */
                        for (pt_debut_doublon=pt_fin_element+1; pt_debut_doublon < pt_fin_liste; )
                        {
                                pt_fin_doublon=strchr(pt_debut_doublon, delim);
                                if (pt_fin_doublon == 0)
                                {
                                        pt_fin_doublon=pt_fin_liste;
                                        lg_doublon=pt_fin_doublon-pt_debut_doublon;
                                        /* voir s'ils sont identique */
                                        if ((lg_doublon == lg_element) && (strncmp(pt_debut_element,pt_debut_doublon,lg_element) == 0))
                                        {
                                          pt_fin_liste-=pt_fin_doublon-pt_debut_doublon+1;
                                          *pt_fin_liste=0;
                                          pt_debut_doublon=pt_fin_liste;
                                        }
                                        else
                                        {
                                          pt_debut_doublon=pt_fin_doublon+1;
                                        }
                                }
                                else
                                {
                                  /* voir s'ils sont identique */
                                  lg_doublon=pt_fin_doublon-pt_debut_doublon;
                                  if ((lg_doublon == lg_element) && (strncmp(pt_debut_element,pt_debut_doublon,lg_element) == 0)
                                      )
                                  {
                                    if (pt_fin_liste-pt_fin_doublon-1 > 0)
                                      memmove(pt_debut_doublon,pt_fin_doublon+1, pt_fin_liste-pt_fin_doublon-1);
                                    pt_fin_liste-=pt_fin_doublon+1-pt_debut_doublon;
                                    *pt_fin_liste=0;
                                  }
                                  else
                                  {
                                    pt_debut_doublon=pt_fin_doublon+1;
                                  }
                                }
                        }
                }
                pt_debut_element=pt_fin_element+1;
  }
  return(pt_fin_liste-liste);
}


/*----------------------------------Fonction----------------------------------*
 * Fonction :  givPreparerLectureRJRUPR
 *
 * But : Prépération de la requête de lecture de la table rjrupr
 *
 * Description :
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givPreparerLectureRJRUPR (void)
{
  int4                iCodRet = 0;
 int4                iIntRet = 0;
  GYBrParam_erreurT     vErreurSQL;
  int4                   iLgBuffer = 0;
  int4                   iLgRequete = 0;
  static int4 iDejaPrepare = (int4)GWCCodeKO;


  EXEC SQL begin declare section;
  char cRequete[300];
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)300);
  if ( (int4)GWCCodeOK == iDejaPrepare )
  {
    return (iCodRet);
  }
  iDejaPrepare = (int4)GWCCodeOK;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureIAPROF\n"));

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIVRequeteLectureRJRUPR);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  if ((int4)GIXCodeOK == iCodRet)
  {
    strcpy (cRequete, GIVRequeteLectureRJRUPR);
    GWTTrace (GWT_NIV_FONCT,
              ("Requete SQL : %s\n", cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
      prepare rqtLectureRJRUPR
      from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureRJRUPR");

    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur prepare rqtLectureRJRUPR : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureRJRUPR");
      EXEC SQL
        declare crsLectureRJRUPR cursor for rqtLectureRJRUPR;

      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_FONCT,
                  ("Erreur DECLARE crsLectureRJRUPR ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }
  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureIAPROF\n"));

  return (iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction :  givPreparerLectureThemeED
 *
 * But : Prépération de la requête de lecture de la table ThemeED
 *
 * Description :
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givPreparerLectureThemeED (void)
{
  int4                iCodRet = 0;
  int4                iIntRet = 0;
  GYBrParam_erreurT     vErreurSQL;
  int4                   iLgBuffer = 0;
  int4                   iLgRequete = 0;
  static int4 iDejaPrepare = (int4)GWCCodeKO;


  EXEC SQL begin declare section;
  char cRequete[300];
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                (size_t)300);
  if ( (int4)GWCCodeOK == iDejaPrepare )
  {
    return (iCodRet);
  }
  iDejaPrepare = (int4)GWCCodeOK;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureThemeED\n"));

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIVRequeteLectureThemeED);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  if ((int4)GIXCodeOK == iCodRet)
  {
    strcpy (cRequete, GIVRequeteLectureThemeED);
    GWTTrace (GWT_NIV_FONCT,
              ("Requete SQL : %s\n", cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
      prepare rqtLectureThemeED
      from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureThemeED");

    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur prepare rqtLectureThemeED : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureThemeED");
      EXEC SQL
        declare crsLectureThemeED cursor for rqtLectureThemeED;

      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_FONCT,
                  ("Erreur DECLARE crsLectureThemeED ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }
  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureThemeED\n"));

  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureZU ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de zone urbaine     */
/*             a partir des codes dep et loc dans GYTTabPelzu                  */
/*             		                                                      */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureZU (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;
  static int4 iDejaPrepare = (int4)GWCCodeKO;
  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                sizeof(cRequete));
   if ( (int4)GWCCodeOK == iDejaPrepare )
  {
    return (iCodRet);
  }
  iDejaPrepare = (int4)GWCCodeOK;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureZU\n"));

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_ZU);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_ZU);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureZU
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureZU");

    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureZU : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureZU");
      EXEC SQL
      declare crsLectureZU cursor for rqtLectureZU;

      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureZU ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureZU\n"));

  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureLocFus ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de localité         */
/*             fusionnée à partir des codes dep et loc dans GYTTabPelFusion   */
/*             		                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureLocFus (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;
  static int4 iDejaPrepare = (int4)GWCCodeKO;
  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                sizeof(cRequete));
   if ( (int4)GWCCodeOK == iDejaPrepare )
  {
    return (iCodRet);
  }
  iDejaPrepare = (int4)GWCCodeOK;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureLocFus\n"));

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_LOCFUS);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_LOCFUS);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureLocFus
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureLocFus");

    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureLocFus : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureLocFus");
      EXEC SQL
      declare crsLectureLocFus cursor for rqtLectureLocFus;

      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureLocFus ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureLocFus\n"));

  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureCRC ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de CRC              */
/*                                                                            */
/*             		                                                      */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureCRC (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureCRC\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                sizeof(cRequete));

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_CRC);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_CRC);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureCRC
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureCRC");

    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureCRC : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureCRC");
      EXEC SQL
      declare crsLectureCRC cursor for rqtLectureCRC;

      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureCRC ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureCRC\n"));

  return (iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givPreparerLectureRegion ()			              */
/*                                                                            */
/* But       : Preparation de la requete SQL de recherche de région     */
/*             a partir du code dep dans LJDEPT                         */
/*             		                                                      */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 givPreparerLectureRegion (void)

{
  int4			iCodRet;     /* Code retour de la fonction */
  int4			iIntRet;     /* Code retour interne */
  GYBrParam_erreurT	vErreurSQL;  /* Traitement des erreurs SQL */
  int4			iLgBuffer;
  int4			iLgRequete;
  static int4 iDejaPrepare = (int4)GWCCodeKO;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE];
  EXEC SQL end declare section;
  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)memset ((void *)cRequete,
                0x00,
                sizeof(cRequete));
  if ( (int4)GWCCodeOK == iDejaPrepare )
  {
    return (iCodRet);
  }
  iDejaPrepare = (int4)GWCCodeOK;
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureRegion\n"));

  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_NEW_REGION);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    if (0 == strcmp(givtcRegCECI, "NON"))
    {
      (void)sprintf (cRequete,
                   GIV_RQ_SELECT_REGION);
    }
    else
    {
      (void)sprintf (cRequete,
                   GIV_RQ_SELECT_NEW_REGION);
    }

    GWTTrace (GWT_NIV_FONCT,
              ("Requete SQL CECI : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureRegion
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureRegion");

    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureRegion : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureRegion");
      EXEC SQL
      declare crsLectureRegion cursor for rqtLectureRegion;

      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureRegion ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givPreparerLectureRegion\n"));

  return (iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givLecAncBloc                                                    */
/*                                                                            */
/* But       : Récupération du blocid antérieur                               */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) :                                                                */
/*                                                                            */
/* Portable  : Surement portable                                              */
/*                                                                            */
/*----------------------------------------------------------------------------*/
int4 givLecAncBloc( char * apcNumnat, char * apcNumlo, char * apcNumls, char * apcBlocid)
{
  int4 iCodRet = (int4)GWZOk;
  int4 iIntRet = (int4)GYBok;
  static int4 iDejaPrepare = (int4)GWCCodeKO;
  GYBrParam_erreurT  rErreurSQL;

  EXEC SQL begin declare section;
  char tcRequete[800];
  char *pcNumnat;
  char *pcNumlo;
  char *pcNumls;
  char cBlocid[27+1];
  int2 indicatrice_Blocid;
  int4 iNbIns;
  EXEC SQL VAR cBlocid IS STRING;
  EXEC SQL end declare section;


  /* Préparer la requête */
  if ( (int4)GWCCodeOK != iDejaPrepare )
  {
    (void)sprintf ( tcRequete, GIV_RQ_SELECT_ANC_BLOC, GIXcNomFour, GIXcNomDest, GIXcDepartement, GIXcDepartement);

    EXEC SQL prepare rqtLectAncBloc from :tcRequete;
    iIntRet = GIVBlocErreur (&rErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_BIZAR,
                ("Erreur prepare rqtLectAncBloc: [COD=%d TXT=%s]\n", iIntRet, rErreurSQL.acDonnees_retour));
      iCodRet = (int4)GWZKo;
    }

    EXEC SQL declare crsLectAncBloc cursor for rqtLectAncBloc;

    iDejaPrepare = (int4)GWCCodeOK;
  }

  /* initialisation des variables */
  if ( (int4)GWZOk == iCodRet )
  {
    pcNumnat = apcNumnat;
    pcNumlo = apcNumlo;
    pcNumls = apcNumls;
  }
  cBlocid[0]= '\0';

  GWTTrace(GWT_NIV_FONCT,("LecAncBloc: <%s>,<%s>,<%s>\n",apcNumnat,apcNumlo,apcNumls));

  /* Ouvrir le curseur */
  if ( GWZOk == iCodRet )
  {
    EXEC SQL OPEN crsLectAncBloc USING :pcNumnat,:pcNumlo,:pcNumls;
    iIntRet = GIVBlocErreur (&rErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_BIZAR,
                ("Erreur open crsLectAncBloc: [COD=%d TXT=%s]\n", iIntRet, rErreurSQL.acDonnees_retour));
      iCodRet = (int4)GWZKo;
    }
  }
  /* Récupération des indicateurs */
  if ( GWZOk == iCodRet )
  {
    EXEC SQL FETCH crsLectAncBloc INTO :cBlocid:indicatrice_Blocid;
    iIntRet = GIVBlocErreur (&rErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_BIZAR,
                ("Erreur fetch crsLectAncBloc: [COD=%d TXT=%s]\n", iIntRet, rErreurSQL.acDonnees_retour));
      iCodRet = (int4)GWZKo;
    }

  }

  /* fermer le curseur */
  EXEC SQL close crsLectAncBloc;
  iIntRet = GIVBlocErreur (&rErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_BIZAR,
              ("Erreur fermeture crsLectAncBloc: [COD=%d TXT=%s]\n", iIntRet, rErreurSQL.acDonnees_retour));
    iCodRet = (int4)GWZKo;
  }

  if (((int2)GYBok != indicatrice_Blocid) || (GWZOk != iCodRet))
  {
    apcBlocid[0] = '\0';
  }
  else
  {
    strcpy(apcBlocid, cBlocid);
  }


  return( iCodRet );
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureLibRub
 *
 * But : Conversion du type de voie en libélé de type de voie.
 *
 * Description : Lecture du libélé de type de voie correspondant au type de voie
 *               dans la table GYTtabPetvoi.
 *               En cas d'absence ddu type de voie dans la table GYTtabPetvoi
 *               on prend le type de voie tel quel.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureLibRub(char * val_codan9)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1                  indFinFetch = 0;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int4                   iIdx,iLg;

  EXEC SQL begin declare section;
  VARCHAR libelle_rub[300 + 1];
  VARCHAR codeAn9[8 + 1];
  int2 sLibCod_i = -1;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  iIntRet = givPreparerLectureRJRUPR();

  GIVBuffInter[0] = '\0';
  if ((int4)GIXCodeOK  == iIntRet)
  {
    memset((char *)codeAn9.arr, ' ', sizeof(codeAn9.arr));
    memcpy((char *)codeAn9.arr, val_codan9, strlen(val_codan9));
    codeAn9.len = strlen(val_codan9);
  }
  else {GWTTrace(GWT_NIV_FONCT,("code an9: <%s>,%d\n",val_codan9, strlen(val_codan9) ));}

  if ( GIXCodeOK == iIntRet )
  {
    EXEC SQL OPEN crsLectureRJRUPR USING :codeAn9;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureRJRUPR: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iIntRet = (int4)GWZKo;
    }
  }

  if ( GIXCodeOK == iIntRet )
  {
    EXEC SQL FETCH crsLectureRJRUPR INTO :libelle_rub:sLibCod_i;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      if ( GYBnodata == iIntRet )
      {
        iIntRet = (int4)GIXCodeOK;
      }

      else
      {
        GWTTrace (GWT_NIV_FONCT,
                  ("Erreur fetch crsLectureRJRUPR: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
        iIntRet = (int4)GIXCodeKO;
      }
    }
    else
    {
      memcpy(GIVBuffInter,(char *)libelle_rub.arr, libelle_rub.len );
      GIVBuffInter[libelle_rub.len] = '\0';
      if ((int4)GWCCodeOK == giviPart)
      {
        iLg = libelle_rub.len;
        GIVBuffInter[iLg] = '\0';
      }
      GWTTrace(GWT_NIV_FONCT,("libellé de rub: <%s>,%d\n", GIVBuffInter, libelle_rub.len ));
    }

  }
  EXEC SQL close crsLectureRJRUPR;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureRJRUPR: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iIntRet = (int4)GIXCodeKO;
  }

  return( iCodRet );
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureLibLocAtt
 *
 * But : localite de rattachement.
 *
 * Description : Lecture du libéllé de localité de rattachement
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureLibLocAtt(char **buf_pos_in, char *apcDepLocInst, char *apcEtab)
{

  int4			iCodRet;	/* Code retour de la fonction */
  int4			iIntRet;	/* Code retour des appels internes */
  int1			indFinFetch;	/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT	vErreurSQL;   /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrPelrepT    *pvCodloc;
  GYBrIndPelrepT *pvIndCodloc;
  EXEC SQL end declare section;
  int4 pipe;				 /* Flag pour ajout pipe */
  char * buf_pos;
  int4 lg_write;

  GWTTrace (GWT_NIV_FONCT,
            ("givLectureLibLocAtt\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  indFinFetch = (int1)GIXCodeOK;
  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  /* Valorisation du pointeur vers la structure de description de la table PAYS */
  pvCodloc    = &GIVvLocrep;
  pvIndCodloc = &GIVvIndLocrep;

  /* Valorisation du pointeur vers la structure de description */
  /*   du tableau de recuperation des correspondances AN8/AN9 */
  (void)memcpy(pvCodloc->acDepart,&apcDepLocInst[0],GYBIeinscLgDeppar);
  pvCodloc->acDepart[GYBIeinscLgDeppar] = '\0';
  (void)strcpy(pvCodloc->acNumloc,&apcDepLocInst[GYBIeinscLgDeppar]);

  /* Ouverture curseur SQL (car requete type SELECT) */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                "open crsLectureLocAtt");
  EXEC SQL
    open crsLectureLocAtt
    using :pvCodloc->acDepart,
    :pvCodloc->acNumloc;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ((int4)GYBok != iIntRet)
  {
    /* Erreur sur declaration curseur SQL */
          GWTTrace (GWT_NIV_GRAVE,
                    ("Erreur open rqtLectureLocAtt : [COD=%d TXT=%s EPJ=%s LOC=%s]\n",
                     iIntRet,
                     vErreurSQL.acDonnees_retour,
                     apcEtab,
                     apcDepLocInst));

    iCodRet = (int4)GIXCodeKO;
  }
  else
  {
    /* Execution requete de denombrement (FETCH du curseur) */
    indFinFetch = (int1)GIXCodeOK;
    pipe = 0;
    while ((int1)GIXCodeOK == indFinFetch)
    {
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "fetch crsLectureLocAtt");
      EXEC SQL
        fetch crsLectureLocAtt into
        :pvCodloc->acLibloc:pvIndCodloc->sLiblocI;

      iIntRet = GIVBlocErreur (&vErreurSQL);

      /* Analyse du code retour SQL */
      switch (iIntRet)
      {
        case (int4)GYBok :
        {
          indFinFetch = (int1)GIXCodeOK;
          iCodRet = (int4)GIXCodeOK;
          if (pipe == 0)
          {
            pipe = 1;
          }
          lg_write = giv_ecrit_balise(buf_pos, GIVvLocrep.acLibloc, "liblocatt");
          buf_pos = buf_pos + lg_write;

          break;
        }

        case (int4)GYBnodata :
        {
          /* la localite n'existe pas */
          /* generer une signalisation */

          indFinFetch = (int1)GIXCodeKO;
          iCodRet = (int4)GIXCodeKO;
          break;
        }

        default :
        {
          /* la consultation de la base s'est mal passee */
          GWTTrace (GWT_NIV_GRAVE,
                    ("Erreur execute rqtLectureLocAtt : [COD=%d TXT=%s]\n",
                     iIntRet,
                     vErreurSQL.acDonnees_retour));
          indFinFetch = (int1)GIXCodeKO;
          iCodRet = (int4)GIXCodeKO;
          break;
        }
      }
    }

    *buf_pos_in = buf_pos;
    /* Fermeture du curseur */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "close crsLectureLocAtt");
    EXEC SQL
      close crsLectureLocAtt;

    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      /* Erreur sur fermeture curseur SQL */
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur CLOSE crsLectureLocAtt ...\n"));
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("GIVLectureLibLocAtt\n"));

  return (iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureLocDep
 *
 * But : localite d'un département.
 *
 * Description : Lecture du libéllé de localité de rattachement
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureLocDep(char *apcDep, int4 *apiAjout)
{

  int4			iCodRet;	/* Code retour de la fonction */
  int4			iIntRet;	/* Code retour des appels internes */
  int1			indFinFetch;	/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT	vErreurSQL;   /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrPelrepT    *pvCodloc;
  GYBrIndPelrepT *pvIndCodloc;
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givLectureLocDep\n"));

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  indFinFetch = (int1)GIXCodeOK;

  /* Valorisation du pointeur vers la structure de description de la table PAYS */
  pvCodloc    = &GIVvLocrep;
  pvIndCodloc = &GIVvIndLocrep;

  /* Valorisation du pointeur vers la structure de description */
  /*   du tableau de recuperation des correspondances AN8/AN9 */
  (void)strcpy(pvCodloc->acDepart,apcDep);

  /* Ouverture curseur SQL (car requete type SELECT) */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                "open crsLectureLocDep");
  EXEC SQL
    open crsLectureLocDep
    using :pvCodloc->acDepart;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ((int4)GYBok != iIntRet)
  {
    /* Erreur sur declaration curseur SQL */
    GWTTrace (GWT_NIV_GRAVE,
              ("Erreur OPEN crsLectureLocDep ...\n"));

    iCodRet = (int4)GIXCodeKO;
  }
  else
  {
    /* Execution requete de denombrement (FETCH du curseur) */
    indFinFetch = (int1)GIXCodeOK;
    while ((int1)GIXCodeOK == indFinFetch)
    {
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "fetch crsLectureLocDep");
      EXEC SQL
        fetch crsLectureLocDep into
        :pvCodloc->acNumloc:pvIndCodloc->sNumlocI;

      iIntRet = GIVBlocErreur (&vErreurSQL);

      /* Analyse du code retour SQL */
      switch (iIntRet)
      {
        case (int4)GYBok :
        {
          if (0 == *apiAjout)
          {
            strcpy(buf_concat, apcDep);
            *apiAjout = 1;
          }
          else
          {
            strcat (buf_concat, "|");
            strcat(buf_concat, apcDep);
          }
          strcat(buf_concat, GIVvLocrep.acNumloc);
          break;
        }

        case (int4)GYBnodata :
        {
          /* fin */
          indFinFetch = (int1)GIXCodeKO;
          break;
        }

        default :
        {
          /* la consultation de la base s'est mal passee */
          GWTTrace (GWT_NIV_GRAVE,
                    ("Erreur execute rqtLectureLocDep : [COD=%d TXT=%s]\n",
                     iIntRet,
                     vErreurSQL.acDonnees_retour));
          indFinFetch = (int1)GIXCodeKO;
          iCodRet = (int4)GIXCodeKO;
          break;
        }
      }
    }

    /* Fermeture du curseur */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "close crsLectureLocDep");
    EXEC SQL
      close crsLectureLocDep;

    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      /* Erreur sur fermeture curseur SQL */
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur CLOSE crsLectureLocDep ...\n"));
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("givLectureLocDep %s\n", buf_concat));

  return (iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureThemeRub
 *
 * But : theme de rubrique.
 *
 * Description : Lecture du theme d'une rubrique
 *               dans la table GYTtabThemeED.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureThemeED(char *val_codan9)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1                  indFinFetch = 0;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int4                   iIdx;
  int4                   j;

  EXEC SQL begin declare section;
  char theme_rub;
  char codeAn9[8 + 1];
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  buf_concat[0] = '\0';
  iIntRet = givPreparerLectureThemeED();

  if ((int4)GIXCodeOK  == iIntRet)
  {
    strcpy(&codeAn9[0], val_codan9);
  }

  GWTTrace(GWT_NIV_FONCT,("code an9: <%s>,%d\n",val_codan9, strlen(val_codan9) ));

  if ( GIXCodeOK == iIntRet )
  {
    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureThemeED");
    EXEC SQL OPEN crsLectureThemeED USING :codeAn9;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureThemeED: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iIntRet = (int4)GWZKo;
    }
  }

  if ( GIXCodeOK == iIntRet )
  {
    EXEC SQL FETCH crsLectureThemeED INTO :theme_rub;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      if ( GYBnodata == iIntRet )
      {
        iIntRet = (int4)GIXCodeOK;
      }

      else
      {
        GWTTrace (GWT_NIV_FONCT,
                  ("Erreur fetch crsLectureThemeED: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
        iIntRet = (int4)GIXCodeKO;
      }
    }
    else
    {
      buf_concat[0] = theme_rub;
      buf_concat[1] = '\0';
      GWTTrace(GWT_NIV_FONCT,("theme de rub: <%s>\n", buf_concat));
    }
  }
  EXEC SQL close crsLectureThemeED;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureThemeED: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iIntRet = (int4)GIXCodeKO;
  }

  return( iCodRet );
}


/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureTypeURL
 *
 * But : type de l'URL.
 *
 * Description : Lecture du type d'URL
 *               dans la table GYTtabPemicURL.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureTypeURL(GYBrIamicT *aprIamic, GYBrIndIamicT *aprIndIamic)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int4                   i,j;
  size_t lgInter, lg_in;
  iconv_t iConv;
  char * buf_in;
  char * buf_out;

  EXEC SQL begin declare section;
  GYBrIamicT *prOraIamic;
  GYBrIndIamicT *prOraIndIamic;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  prOraIamic = aprIamic;
  prOraIndIamic = aprIndIamic;
  buf_concat[0] = '\0';
    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureTypeURL");
    EXEC SQL OPEN crsLectureTypeURL
      USING :prOraIamic->acNumobj,
      :prOraIamic->acTypobj,
      :prOraIamic->acTpdsob;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureTypeURL: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }

  if ( (int4)GYBok == iIntRet )
  {
    EXEC SQL FETCH crsLectureTypeURL INTO
      :prOraIamic->acTpdUrl:prOraIndIamic->sTpdUrlI,
      :prOraIamic->acLibUrl:prOraIndIamic->sLibUrlI;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
        iCodRet = (int4)GIXCodeKO;
    }
  }
  EXEC SQL close crsLectureTypeURL;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if (((int4)GYBok != iIntRet) || ((int4)GYBok != prOraIndIamic->sLibUrlI))
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureTypeURL: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }
  else
  {
  	givConvURL(aprIamic->acLibUrl);
  }

  return( iCodRet );
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureImag
 *
 * But : nombre d'images d'un produit PVI.
 *
 * Description : Lecture du nombre
 *               dans la table GYTtabPVIMAG.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureImag(GYBrIamicT *aprIamic, char *prNbimag, char *prImagCat, char * pcMenu)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1                  indFinFetch = 0;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int4                   iIdx;
  int4                   j;

  EXEC SQL begin declare section;
  GYBrIamicT *prOraIamic;
  char prOraRef[20];
  int2 sIndic;
  char tcOraRef[2];
  char cOraMenu;
  EXEC SQL VAR prOraRef IS STRING;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  prOraIamic = aprIamic;
  prNbimag[0] = '\0';
  prImagCat[0] = '\0';
  tcOraRef[0] = '\0';
  prOraRef[0] = '\0';
  pcMenu[0] = '\0';
    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureImag");
    EXEC SQL OPEN crsLectureImag
      USING :prOraIamic->acNumobj;
   iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureImag: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }

  if ( (int4)GYBok == iIntRet )
  {
    EXEC SQL FETCH crsLectureImag INTO
      :prOraRef:sIndic, :tcOraRef, :cOraMenu;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      strcpy(prNbimag, prOraRef);
      strcpy(prImagCat, tcOraRef);
      * pcMenu = cOraMenu;
    }
  }
  EXEC SQL close crsLectureImag;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureImag: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }
  GWTTrace (GWT_NIV_FONCT,
              ("Imag: %s, %s, %c\n", prOraIamic->acNumobj, prNbimag, pcMenu));


  return( iCodRet );
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureMotsCles
 *
 * But : crc mots cles
 *
 * Description : lecture terme de cri
 *               dans la table GYTtabMotsClesCri.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureMotsCles(GYBrIamicT *aprIamic)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1                  indFinFetch = 0;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int4                   i,j;
  char tcAn9Courant[GYBPaprofLgCodan9 + 1];

  EXEC SQL begin declare section;
  GYBrIamicT *prOraIamic;
  GYBrIaprofT prOraIaprof;
  GYBstrMClesCriAnnotT tcAnnotMCle;     /* annotation mots clés */
  GYBstrMClesCriIdT tcIdMCle;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  prOraIamic = aprIamic;
    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureMCles");
    EXEC SQL OPEN crsLectureMCles
      USING :prOraIamic->acNumobj;
   iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureMCles: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
  GWTTrace (GWT_NIV_FONCT,("Objet Mot Clé cherché : '%s'\n",prOraIamic->acNumobj));

  if ( (int4)GYBok == iIntRet )
  {
    iCodRet = (int4)GIXCodeKO;
    indFinFetch = (int1)GIXCodeOK;
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureMCles INTO
      :tcIdMCle,
      :prOraIaprof.acCodan8,
      :tcAnnotMCle;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      switch (iIntRet)
      {
        case (int4)GYBok :
        {
          if (NULL != strstr(GIVBuffClob, tcIdMCle))
          {
          	break;
          }
          /* recherche de la rubrique de CRI parmi les rubriques du bloc */
          i = 0;
          GWTTrace (GWT_NIV_FONCT,("Critère Mot Clé trouvé : '%s', '%s'\n",
          tcIdMCle,prOraIaprof.acCodan8));
          strcpy(tcAn9Courant, givcR00000000);
          for(i=0; i<(givrListParu.iNbr); i++)
          {
            j= givrListParu.trEltRangList[i];
            if (0 != strcmp(tcAn9Courant, givrListParu.trEltList[j].rub))
            {
              strcpy(tcAn9Courant, givrListParu.trEltList[j].rub);
              if (0 == strcmp(prOraIaprof.acCodan8, givrListParu.trEltList[j].rubinit))
              {
      	        break;
              }
            }
          }
          if ((givrListParu.iNbr != i) && (0 != strcmp (givcR000000, prOraIaprof.acCodan8)))
          {
            GWTTrace (GWT_NIV_FONCT,("Critère Mot Clé validé : '%s', '%s'\n",
            tcIdMCle,prOraIaprof.acCodan8));
            iCodRet = (int4)GIXCodeOK;
            if ((int4)sizeof(GIVBuffInter) <= ((int4)strlen(GIVBuffInter) + (int4)strlen(tcAnnotMCle)))
            {
          	  /* fin car buffer insuffisant */
              GWTTrace (GWT_NIV_GRAVE,
                  ("Buffer lecture CRI Mots Clés insuffisant : %d, %s\n",
                   (int4)strlen(GIVBuffInter),prOraIamic->acNumobj));
              iCodRet = (int4)GIXCodeKO;
	            indFinFetch = (int1)GIXCodeKO;
	            break;
            }
    	      (void)strcat(GIVBuffInter,tcAnnotMCle);
            if ((int4)sizeof(GIVBuffClob) <= ((int4)strlen(GIVBuffClob) + (int4)strlen(tcIdMCle)))
            {
          	  /* fin car buffer insuffisant */
              GWTTrace (GWT_NIV_GRAVE,
                  ("Buffer lecture ID Mots Clés insuffisant : %d, %s\n",
                   (int4)strlen(GIVBuffClob),prOraIamic->acNumobj));
              iCodRet = (int4)GIXCodeKO;
	            indFinFetch = (int1)GIXCodeKO;
	            break;
            }
    	      if (0 == strlen(GIVBuffClob))
            {
        	    strcpy(GIVBuffClob,tcIdMCle);
            }
            else
            {
              strcat (GIVBuffClob, "|");
        	    strcat(GIVBuffClob,tcIdMCle);
            }
          }
          break;
        }
        case (int4)GYBnodata :
        {
	        /* il n'existe pas ou plus de liens */
	        indFinFetch = (int1)GIXCodeKO;
	        break;
        }
        default :
        {
	        /* la consultation de la base s'est mal passee */
	        GWTTrace(GWT_NIV_GRAVE,
		       ("Erreur execute rqtLectureMCles : [COD=%d TXT=%s] [numobj=%s]\n",
		      iIntRet, vErreurSQL.acDonnees_retour, prOraIamic->acNumobj));
	        iCodRet = (int4)GIXCodeKO;
	        indFinFetch = (int1)GIXCodeKO;
	        break;
        }
      }
    }
  }
  EXEC SQL close crsLectureMCles;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureMCles: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }
  GWTTrace (GWT_NIV_FONCT,
              ("MotsCles: %d, %s\n", iCodRet, tcAnnotMCle));


  return( iCodRet );
}


/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureEtabDonSupp
 *
 * But : données enrichies, données additionnelles.
 *
 * Description : lecture
 *               dans la table GYTtabPeetab ou  GYTtabDonAddEtab.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureEtabDonSupp(char *apcEtab, char *apcObj, char *apcTyp, char *apcSource)
{
  int4                   iCodRet = GWCCodeOK;    /* Code retour de la fonction */
  int4                   iIntRet = GWCCodeOK;    /* Code retour des appels internes */
  EXEC SQL begin declare section;
  char *pcOraEtab;
  char *pcOraObj;
  char *pcOraTyp;
  char *pcOraSce;
  OCIClobLocator * pClob;
  static int4 iLgEcrit = 0;
  char tcRequete[800];
  nat8 length;
  int2 sInd, sIndic;
  EXEC SQL end declare section;
  GYBrParam_erreurT	vErreurSQL;   /* Traitement des erreurs SQL */
  static int4 iDejaPrepare = (int4)GWCCodeKO;

  GIVBuffInter[0] = '\0';

   /* init CLOB PeEtab */
    (void)strcpy(vErreurSQL.acOrdre_sql,"Allocate de CLOB");
    EXEC SQL ALLOCATE :pClob;
    EXEC SQL LOB CREATE TEMPORARY :pClob;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    GWTTrace (GWT_NIV_FONCT, ("Allocation CLOB pour GYTtabPeEtab\n"));
    /* Analyse du code resultat SQL */
    if ((int4)GWCCodeOK != iIntRet)
    {
      iCodRet = iIntRet;
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur : [COD=%d TXT=%s]\n",
                 iCodRet,
                 vErreurSQL.acOrdre_sql));
      return( iCodRet );
    }

  (void)strcpy(vErreurSQL.acOrdre_sql,"Prepare SlcDonSupp");
  if ( (int4)GWCCodeOK != iDejaPrepare )
  {
    GWTTrace (GWT_NIV_FONCT, ("Préparation accès clob pour GYTtabPeEtab\n"));
  	iDejaPrepare = (int4)GWCCodeOK;
    (void)sprintf ( tcRequete, GIV_SLC_CLOB_DONENR);
    EXEC SQL prepare rqtSlcDonEnr from :tcRequete;

    EXEC SQL DECLARE crsSlcDonEnr CURSOR FOR rqtSlcDonEnr;
    (void)sprintf ( tcRequete, GIV_SLC_CLOB_DONREL);
    EXEC SQL prepare rqtSlcDonRel from :tcRequete;

    EXEC SQL DECLARE crsSlcDonRel CURSOR FOR rqtSlcDonRel;
    (void)sprintf ( tcRequete, GIV_SLC_CLOB_DONADD);
    EXEC SQL prepare rqtSlcDonRes from :tcRequete;

    EXEC SQL DECLARE crsSlcDonRes CURSOR FOR rqtSlcDonRes;

    (void)sprintf ( tcRequete, GIV_SLC_CLOB_DONADD_GCEN);
    EXEC SQL prepare rqtSlcDonGC from :tcRequete;

    EXEC SQL DECLARE crsSlcDonGC CURSOR FOR rqtSlcDonGC;
    (void)sprintf ( tcRequete, GIV_SLC_CLOB_ANNONC);
    EXEC SQL prepare rqtSlcContAnnc from :tcRequete;

    EXEC SQL DECLARE crsSlcContAnnc CURSOR FOR rqtSlcContAnnc;
    (void)sprintf ( tcRequete, GIV_SLC_CLOB_ETAB);
    EXEC SQL prepare rqtSlcContEtab from :tcRequete;

    EXEC SQL DECLARE crsSlcContEtab CURSOR FOR rqtSlcContEtab;
    (void)sprintf ( tcRequete, GIV_SLC_CLOB_ANNOT);
    EXEC SQL prepare rqtSlcContAnot from :tcRequete;

    EXEC SQL DECLARE crsSlcContAnot CURSOR FOR rqtSlcContAnot;
    (void)sprintf ( tcRequete, GIV_SLC_CLOB_DHNA);
    EXEC SQL prepare rqtSlcDonDHNA from :tcRequete;

    EXEC SQL DECLARE crsSlcDonDHNA CURSOR FOR rqtSlcDonDHNA;
    (void)sprintf ( tcRequete, GIV_SLC_CLOB_DHNE);
    EXEC SQL prepare rqtSlcDonDHNE from :tcRequete;

    EXEC SQL DECLARE crsSlcDonDHNE CURSOR FOR rqtSlcDonDHNE;
  }

    (void)strcpy(vErreurSQL.acOrdre_sql,"SlcDonSupp");
    GWTTrace (GWT_NIV_FONCT, ("Ouverture SlcDonSupp\n"));
    if (0 == strcmp(giv_HPN,apcSource))
    {
    	pcOraTyp = apcTyp;
      pcOraObj = apcObj;
      EXEC SQL open crsSlcDonDHNA using :pcOraTyp,:pcOraObj;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur open crsSlcDonDHNA: [COD=%d TXT=%s] %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcObj));
      }
      EXEC SQL fetch crsSlcDonDHNA into :pClob:sInd;
    }
    else if (0 == strcmp(giv_HGN,apcSource))
    {
      pcOraEtab = apcEtab;
      pcOraTyp = apcTyp;
      pcOraObj = apcObj;
      if (0 == strcmp(apcTyp,"DE"))
      {
      	sIndic = (int2)-1;
      	pcOraObj = NULL;
      }
      else
      {
      	sIndic = (int2)0;
      }
      EXEC SQL open crsSlcDonDHNE using :pcOraEtab,:pcOraTyp,:pcOraObj:sIndic;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur open crsSlcDonDHNE: [COD=%d TXT=%s] %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcEtab));
      }
      EXEC SQL fetch crsSlcDonDHNE into :pClob:sInd;
    }
    else if (0 == strlen(apcEtab))
    {
      pcOraObj = apcObj;
      pcOraTyp = apcTyp;
      EXEC SQL open crsSlcContAnnc using :pcOraObj, :pcOraTyp;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur open crsSlcContAnnc: [COD=%d TXT=%s] %s, %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcObj, apcTyp));
      }
      EXEC SQL fetch crsSlcContAnnc into :pClob:sInd;
    }
    else if (0 == strcmp(giv_EPJ,apcSource))
    {
      pcOraEtab = apcEtab;
      pcOraObj = apcObj;
      pcOraTyp = apcTyp;
      EXEC SQL open crsSlcContEtab using :pcOraEtab, :pcOraTyp, :pcOraObj;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur open crsSlcContEtab: [COD=%d TXT=%s] %s, %s, %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcEtab, apcObj, apcTyp));
      }
      EXEC SQL fetch crsSlcContEtab into :pClob:sInd;
    }
    else if (0 == strcmp(giv_ANO,apcSource))
    {
      pcOraEtab = apcEtab;
      pcOraObj = apcObj;
      pcOraTyp = apcTyp;
      EXEC SQL open crsSlcContAnot using :pcOraEtab, :pcOraTyp, :pcOraObj;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur open crsSlcContAnot: [COD=%d TXT=%s] %s, %s, %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcEtab, apcObj, apcTyp));
      }
      EXEC SQL fetch crsSlcContAnot into :pClob:sInd;
    }
    else if (0 == strcmp(giv_ENR,apcSource))
    {
      pcOraEtab = apcEtab;
      EXEC SQL open crsSlcDonEnr using :pcOraEtab;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur open crsSlcDonEnr: [COD=%d TXT=%s] %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcEtab));
      }
      EXEC SQL fetch crsSlcDonEnr into :pClob:sInd;
    }
    else if (0 == strcmp(giv_REL,apcSource))
    {
      pcOraEtab = apcEtab;
      EXEC SQL open crsSlcDonRel using :pcOraEtab;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur open crsSlcDonRel: [COD=%d TXT=%s] %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcEtab));
      }
      EXEC SQL fetch crsSlcDonRel into :pClob:sInd;
    }
    else if (0 == strcmp(giv_ADD,apcSource))
    {
      pcOraEtab = apcEtab;
      pcOraTyp = apcTyp;
      EXEC SQL open crsSlcDonRes using :pcOraEtab, :pcOraTyp;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur open crsSlcDonRes: [COD=%d TXT=%s] %s, %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcEtab, apcTyp));
      }
      EXEC SQL fetch crsSlcDonRes into :pClob:sInd;
    }
    else if (0 == strcmp(giv_ADG,apcSource))
    {
      pcOraEtab = apcEtab;
      pcOraTyp = apcTyp;
      EXEC SQL open crsSlcDonGC using :pcOraEtab, :pcOraTyp;
      EXEC SQL fetch crsSlcDonGC into :pClob:sInd;
    }
    else
    {
      GWTTrace (GWT_NIV_GRAVE,
              ("Erreur ouverture curseur : %s,%s,-%s-,-%s-\n", apcTyp, apcSource, apcEtab, apcObj));
    }

    iIntRet = GIVBlocErreur (&vErreurSQL);

    /* Analyse du code resultat SQL */
    if (((int4)GWCCodeOK != iIntRet) || (NULL == pClob))
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acOrdre_sql));
    }
    iLgEcrit = 0;
    if (((int4)GWCCodeOK == iIntRet) && ((int4)GYBok == sInd))
    {
      /* lecture des données xmltype */
      EXEC SQL LOB OPEN :pClob READ ONLY;
      givLectClob(pClob, apcEtab, apcObj, apcTyp, apcSource);
      iLgEcrit = strlen(GIVBuffInter);
      /* conversion du XMLType */
      (void) givConvClob();
      EXEC SQL LOB CLOSE :pClob;
    }

    if (0 == strcmp(giv_HPN,apcSource))
    {
      EXEC SQL close crsSlcDonDHNA;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur close crsSlcDonDHNA: [COD=%d TXT=%s] %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcObj));
      }
    }
    else if (0 == strcmp(giv_HGN,apcSource))
    {
      EXEC SQL close crsSlcDonDHNE;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur close crsSlcDonDHNE: [COD=%d TXT=%s] %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcEtab));
      }
    }
    else if (0 == strlen(apcEtab))
    {
      EXEC SQL close crsSlcContAnnc;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur close crsSlcContAnnc: [COD=%d TXT=%s] %s, %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcObj, apcTyp));
      }
    }
    else if (0 == strcmp(giv_EPJ,apcSource))
    {
      EXEC SQL close crsSlcContEtab;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur close crsSlcContEtab: [COD=%d TXT=%s] %s, %s, %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcEtab, apcObj, apcTyp));
      }
    }
    else if (0 == strcmp(giv_ANO,apcSource))
    {
      EXEC SQL close crsSlcContAnot;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur close crsSlcContAnot: [COD=%d TXT=%s] %s, %s, %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcEtab, apcObj, apcTyp));
      }
    }
    else if (0 == strcmp(giv_ENR,apcSource))
    {
      EXEC SQL close crsSlcDonEnr;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur close crsSlcDonEnr: [COD=%d TXT=%s] %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcEtab));
      }
    }
    else if (0 == strcmp(giv_REL,apcSource))
    {
      EXEC SQL close crsSlcDonRel;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur close crsSlcDonRel: [COD=%d TXT=%s] %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcEtab));
      }
    }
    else if (0 == strcmp(giv_ADD,apcSource))
    {
      EXEC SQL close crsSlcDonRes;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_GRAVE,
        ("Erreur close crsSlcDonRes: [COD=%d TXT=%s] %s, %s\n", iIntRet, vErreurSQL.acDonnees_retour, apcEtab, apcTyp));
      }
    }
    else if (0 == strcmp(giv_ADG,apcSource))
    {
      EXEC SQL close crsSlcDonGC;
    }
    else
    {
      GWTTrace (GWT_NIV_GRAVE,
              ("Erreur fermeture curseur : %s,%s,-%s-,-%s-\n", apcTyp, apcSource, apcEtab, apcObj));
    }

     GWTTrace (GWT_NIV_FONCT, ("Liberation CLOB pour GYTtabPeEtab\n"));
    /* liberation CLOB */
    (void)strcpy(vErreurSQL.acOrdre_sql,"Liberation de CLOB");
    EXEC SQL LOB FREE TEMPORARY :pClob;
    EXEC SQL FREE :pClob;

        iIntRet = GIVBlocErreur (&vErreurSQL);

         /* Analyse du code resultat SQL */
        if ((int4)GYBok != iIntRet)
        {
          GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur : [COD=%d TXT=%s]\n",
                   iIntRet,
                   vErreurSQL.acOrdre_sql));
          GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur libération Clob PeEtab\n"));

        }

  GWTTrace (GWT_NIV_FONCT,
              ("EtabDonSupp: %d, %s\n", strlen(GIVBuffInter),GIVBuffInter));

  return( iCodRet );
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLecturePartEtab
 *
 * But : données enrichies.
 *
 * Description : lecture
 *               dans la table GYTtabPartEtab.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLecturePartEtab(GYBrIapartT *apIapart, int4 aiClob)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  EXEC SQL begin declare section;
  static OCIClobLocator * pClob1;
  static OCIClobLocator * pClob2;
  static int2 sInd1I;
  static int2 sInd2I;
  OCIClobLocator * pClob;
  char tcRequete[800];
  nat8 length;
  GYBrIapartT   rIapart;
  EXEC SQL end declare section;
  GYBrParam_erreurT	vErreurSQL;   /* Traitement des erreurs SQL */
  int4 iLgEcrit;
  static int4 iDejaPrepare = (int4)GWCCodeKO;

  iLgEcrit = 0;
  GIVBuffInter[0] = '\0';
  iCodRet = (int4)GWCCodeOK;
  if ( (int4)GWCCodeOK != iDejaPrepare )
  {
    (void)strcpy(vErreurSQL.acOrdre_sql,"SlcPartEtab");
    (void)sprintf ( tcRequete, GIV_SLC_CLOB_PART);

    EXEC SQL prepare rqtSlcPart from :tcRequete;

    EXEC SQL DECLARE crsSlcPart CURSOR FOR rqtSlcPart;
    iDejaPrepare = (int4)GWCCodeOK;
  }

  if (GIXCodeOK == aiClob)
  {
   /* init CLOB PeEtab */
    (void)strcpy(vErreurSQL.acOrdre_sql,"Allocate de CLOB1");
    sInd1I = (int4)GYBnok;
    sInd2I = (int4)GYBnok;
    EXEC SQL ALLOCATE :pClob1;
    EXEC SQL LOB CREATE TEMPORARY :pClob1;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    GWTTrace (GWT_NIV_FONCT, ("Allocation CLOB pour GYTtabPartEtab\n"));
    /* Analyse du code resultat SQL */
    if ((int4)GWCCodeOK != iIntRet)
    {
      iCodRet = iIntRet;
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur : [COD=%d TXT=%s]\n",
                 iCodRet,
                 vErreurSQL.acOrdre_sql));
      return( iCodRet );
    }
    (void)strcpy(vErreurSQL.acOrdre_sql,"Allocate de CLOB2");
    EXEC SQL ALLOCATE :pClob2;
    EXEC SQL LOB CREATE TEMPORARY :pClob2;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    GWTTrace (GWT_NIV_FONCT, ("Allocation CLOB pour GYTtabPartEtab\n"));
    /* Analyse du code resultat SQL */
    if ((int4)GWCCodeOK != iIntRet)
    {
      EXEC SQL LOB FREE TEMPORARY :pClob1;
      EXEC SQL FREE :pClob1;
      iCodRet = iIntRet;
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur : [COD=%d TXT=%s]\n",
                 iCodRet,
                 vErreurSQL.acOrdre_sql));
      return( iCodRet );
    }
    (void)strcpy (rIapart.acOriPart,apIapart->acOriPart);
    (void)strcpy (rIapart.acRefPart,apIapart->acRefPart);
    GWTTrace (GWT_NIV_FONCT, ("GYTtabPartEtab : %s,%s\n",apIapart->acOriPart,apIapart->acRefPart));
    (void)strcpy(vErreurSQL.acOrdre_sql,"SlcPartEtab");

    EXEC SQL open crsSlcPart using :rIapart.acOriPart, :rIapart.acRefPart;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_GRAVE,
        ("Erreur open crsSlcPart: [COD=%d TXT=%s] %s,%s\n", iIntRet, vErreurSQL.acDonnees_retour, rIapart.acOriPart,rIapart.acRefPart));
      iCodRet = (int4)GWCCodeKO;
      EXEC SQL LOB FREE TEMPORARY :pClob1;
      EXEC SQL FREE :pClob1;
      EXEC SQL LOB FREE TEMPORARY :pClob2;
      EXEC SQL FREE :pClob2;
        return( iCodRet );
    }

    EXEC SQL fetch crsSlcPart into :pClob1:sInd1I, :pClob2:sInd2I;

    iIntRet = GIVBlocErreur (&vErreurSQL);

    /* Analyse du code resultat SQL */
    if (((int4)GWCCodeOK != iIntRet) ||
    	(((int4)GYBok != sInd1I) && ((int4)GYBok != sInd2I)))
    {
      iCodRet = (int4)GWCCodeKO;
      GWTTrace (GWT_NIV_BIZAR,
                ("Erreur : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acOrdre_sql));
      EXEC SQL close crsSlcPart;
      EXEC SQL LOB FREE TEMPORARY :pClob1;
      EXEC SQL FREE :pClob1;
      EXEC SQL LOB FREE TEMPORARY :pClob2;
      EXEC SQL FREE :pClob2;
      return( iCodRet );
    }
  }

  if ((GIXCodeOK == aiClob) && ((int4)GYBok == sInd1I))
  {
    pClob = pClob1;
   	EXEC SQL LOB OPEN :pClob1 READ ONLY;
  }
  else if ((GIXCodeOK != aiClob) && ((int4)GYBok == sInd2I))
  {
    pClob = pClob2;
   	EXEC SQL LOB OPEN :pClob2 READ ONLY;
  }
  else
  {
    GWTTrace (GWT_NIV_FONCT, ("Pas de donnée xmltype %d\n", aiClob));
    if (GIXCodeOK != aiClob)
    {
      EXEC SQL close crsSlcPart;
      EXEC SQL LOB FREE TEMPORARY :pClob1;
      EXEC SQL FREE :pClob1;
      EXEC SQL LOB FREE TEMPORARY :pClob2;
      EXEC SQL FREE :pClob2;
    }
    iCodRet = (int4)GWCCodeOK;
    return( iCodRet );
  }

  /* lecture des données xmltype */
  givLectClob(pClob,apIapart->acOriPart,apIapart->acRefPart,giv_PRT,giv_PRT);
  /* conversion du XMLType */
  (void) givConvClob();
  GIVBuffXML[0]='\0';
  GWTTrace (GWT_NIV_FONCT,
              ("PartEtab: %d, %s\n", strlen(GIVBuffInter),GIVBuffInter));
  if (GIXCodeOK == aiClob)
  {
    EXEC SQL LOB CLOSE :pClob1;
  }
  else if (GIXCodeOK != aiClob)
  {
    EXEC SQL close crsSlcPart;
     GWTTrace (GWT_NIV_FONCT, ("Liberation CLOB pour GYTtabPartEtab\n"));
    /* liberation CLOB */
    (void)strcpy(vErreurSQL.acOrdre_sql,"Liberation de CLOB");
    EXEC SQL LOB FREE TEMPORARY :pClob1;
    EXEC SQL FREE :pClob1;

        iIntRet = GIVBlocErreur (&vErreurSQL);

         /* Analyse du code resultat SQL */
        if ((int4)GYBok != iIntRet)
        {
          GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur : [COD=%d TXT=%s]\n",
                   iIntRet,
                   vErreurSQL.acOrdre_sql));
          GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur libération Clob PartEtab\n"));

        }
    EXEC SQL LOB CLOSE :pClob2;
    EXEC SQL LOB FREE TEMPORARY :pClob2;
    EXEC SQL FREE :pClob2;

        iIntRet = GIVBlocErreur (&vErreurSQL);

         /* Analyse du code resultat SQL */
        if ((int4)GYBok != iIntRet)
        {
          GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur : [COD=%d TXT=%s]\n",
                   iIntRet,
                   vErreurSQL.acOrdre_sql));
          GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur libération Clob PartEtab\n"));

        }
  }

  return( iCodRet );
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureEtabMC
 *
 * But : type de l'URL.
 *
 * Description : Lecture des données de niveau inscription
 *               dans la table GYTtabPeeatb.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureEtabMC(char *apcEtab, char acPar, char **buf_pos_in)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1                  indFinFetch = 0;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int4 lg_ecr,iIdx,j;
  char *buf_pos;

  static char tcEtab[GYBIeinscLgEtab2] = "";   /* code etablissement */
  EXEC SQL begin declare section;
  static GYBrPeEtabT rEtab;
  static GYBrIndPeEtabT rIndEtab;
  static char tcCount[6];
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  lg_ecr = 0;
  buf_pos = *buf_pos_in;
  if (0 != strcmp (tcEtab, apcEtab))
  {
  	/* changement d'etab */
    strcpy (tcEtab, apcEtab);
    strcpy (rEtab.acEtab, apcEtab);
    strcpy(tcCount,"00000");
    rIndEtab.sSiretI = GYBnok;
    rIndEtab.sLibUrlI = GYBnok;
    rIndEtab.sTefEtI = GYBnok;
    rIndEtab.sTefEnI = GYBnok;
    rIndEtab.sSiegeI = GYBnok;
    rIndEtab.sCJI = GYBnok;
    rIndEtab.sLibCJI = GYBnok;
    rIndEtab.sLibAPEI = GYBnok;
    rIndEtab.sDatI = GYBnok;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureEtabMC");
    EXEC SQL OPEN crsLectureEtabMC
      USING :rEtab.acEtab;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureEtabMC: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }

    if ( (int4)GYBok == iIntRet )
    {
      EXEC SQL FETCH crsLectureEtabMC INTO
      :rEtab.acSiret:rIndEtab.sSiretI,
      :rEtab.acLibUrl:rIndEtab.sLibUrlI,
      :rEtab.acTefEt:rIndEtab.sTefEtI,
      :rEtab.acTefEn:rIndEtab.sTefEnI,
      :rEtab.acSiege:rIndEtab.sSiegeI,
      :rEtab.acCJ:rIndEtab.sCJI,
      :rEtab.acLibCJ:rIndEtab.sLibCJI,
      :rEtab.acLibAPE:rIndEtab.sLibAPEI,
      :rEtab.acDat:rIndEtab.sDatI;
      iIntRet = GIVBlocErreur (&vErreurSQL);
    }
    EXEC SQL close crsLectureEtabMC;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureEtabMC: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    if ((int4)GYBok == rIndEtab.sSiretI)
    {
  	  /* utilisation de siren (9 car de siret) */
      rEtab.acSiret[9] = '\0';
      /* Traitement des erreurs SQL */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureSiren");
      EXEC SQL OPEN crsLectureSiren
      USING :rEtab.acSiret;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureSiren: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
        iCodRet = (int4)GIXCodeKO;
      }
      else
      {
        EXEC SQL FETCH crsLectureSiren INTO
        :tcCount;
        iIntRet = GIVBlocErreur (&vErreurSQL);
        EXEC SQL close crsLectureSiren;
        iIntRet = GIVBlocErreur (&vErreurSQL);
        if ( (int4)GYBok != iIntRet )
        {
          GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureSiren: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
          iCodRet = (int4)GIXCodeKO;
        }
      }
    }
  }

  if ('0' == acPar)
  {
  	rIndEtab.sSiretI = GYBnok;
    rIndEtab.sTefEtI = GYBnok;
    rIndEtab.sTefEnI = GYBnok;
    rIndEtab.sSiegeI = GYBnok;
    rIndEtab.sCJI = GYBnok;
    rIndEtab.sLibCJI = GYBnok;
    rIndEtab.sLibAPEI = GYBnok;
    rIndEtab.sDatI = GYBnok;
  }
  if ((int4)GYBok == rIndEtab.sLibUrlI)
  {
    lg_ecr = giv_ecrit_balise(buf_pos, rEtab.acLibUrl, "etaburl");
    buf_pos = buf_pos + lg_ecr;
  }
  if ((int4)GYBok == rIndEtab.sTefEtI)
  {
    lg_ecr = giv_ecrit_balise(buf_pos, rEtab.acTefEt, "eta_tefet");
    buf_pos = buf_pos + lg_ecr;
  }
  if ((int4)GYBok == rIndEtab.sTefEnI)
  {
  	lg_ecr = giv_ecrit_balise(buf_pos, rEtab.acTefEn, "eta_tefen");
    buf_pos = buf_pos + lg_ecr;
  }
  if (((int4)GYBok == rIndEtab.sSiegeI) && ('0' == rEtab.acSiege))
  {
   	lg_ecr = giv_ecrit_balise(buf_pos, "0", "eta_siege");
    buf_pos = buf_pos + lg_ecr;
  }
  else if ((int4)GYBok == rIndEtab.sSiegeI)
  {
   	lg_ecr = giv_ecrit_balise(buf_pos, "1", "eta_siege");
    buf_pos = buf_pos + lg_ecr;
  }
  if ((int4)GYBok == rIndEtab.sCJI)
  {
   	lg_ecr = giv_ecrit_balise(buf_pos, rEtab.acCJ, "eta_cj");
    buf_pos = buf_pos + lg_ecr;
  }
  if ((int4)GYBok == rIndEtab.sSiretI)
  {
    lg_ecr = giv_ecrit_balise(buf_pos, rEtab.acSiret, "siren");
    buf_pos = buf_pos + lg_ecr;
    lg_ecr = giv_ecrit_balise(buf_pos, tcCount, "nbetsiren");
    buf_pos = buf_pos + lg_ecr;
  }
  /* Ecriture dans le fichier de sortie */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  if ((int4)GYBok == rIndEtab.sLibCJI)
  {
   	lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acLibCJ, "eta_cjlib");
  }
  if ((int4)GYBok == rIndEtab.sLibAPEI)
  {
   	lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acLibAPE, "libape");
  }
  if ((int4)GYBok == rIndEtab.sDatI)
  {
   	lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acDat, "dtcreentr");
  }

  *buf_pos_in=buf_pos;

  return( iCodRet );
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureSynonyme
 *
 * But : synonymes de dénomination.
 *
 * Description : Lecture des données de niveau bloc
 *               dans la table GYTtabDenomSynonyme.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureSynonyme(GYBrDOCUMENT *doc, char **buf_pos_in, int4 aiRang, int4 aIndice)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1                  indFinFetch = 0;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  char *buf_pos;
  int4 lg_ecr;
  int4 i,j;
  int4 iDeb;

  EXEC SQL begin declare section;
  GYBrDenomSynoT rOraSyno;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  iDeb = 1 ;
  buf_pos = *buf_pos_in;

  strcpy(rOraSyno.acDenom,(doc+aiRang)->value.intitule.denomination);

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureSyno");
  EXEC SQL OPEN crsLectureSyno
      USING :rOraSyno.acDenom;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureSyno: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureSyno");
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureSyno INTO
        :rOraSyno.acCodan8,
        :rOraSyno.acSyno;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
      }
      else
      {
        GWTTrace (GWT_NIV_FONCT,
              ("Syno : %s, %s\n", rOraSyno.acCodan8, rOraSyno.acSyno));
      	for(i=0; i< aIndice; i++)
        {
        	if ( (doc+aiRang)->value.intitule.iRgDnom == (doc+i)->value.intitule.iRgDnom )
        	{
      	    for(j=0; j< (doc+i)->value.rubriques.iNban9; j++)
            {
              if (0 == strcmp((doc+i)->value.rubriques.Tan9[j].val_codan8, rOraSyno.acCodan8))
              {
                break;
              }
            }
            if ((doc+i)->value.rubriques.iNban9 != j)
            {
              break;
            }
          }
        }
        if (aIndice != i)
        {
        	if (1 == iDeb)
        	{
            lg_ecr = giv_ecrit_noeud_simple(buf_pos,"synonymes");
            buf_pos = buf_pos + lg_ecr;
        		iDeb = 0;
        	}
          lg_ecr = giv_ecrit_balise_iso(buf_pos, rOraSyno.acSyno, "synonyme");
          buf_pos = buf_pos + lg_ecr;
        }
      }
    }
  }
  if (1 != iDeb)
 	{
    lg_ecr = giv_ecrit_fin_noeud(&buf_pos,"synonymes");
    buf_pos = buf_pos + lg_ecr;
 	}

  EXEC SQL close crsLectureSyno;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureSyno: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  *buf_pos_in=buf_pos;

  return( iCodRet );
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureEmbauche
 *
 * But : ref d'Embauche
 *
 * Description : Lecture de ref
 *               dans la table GYTtabEmbauche.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureEmbauche(char *apcNumcli, char *apcRefext)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1                  indFinFetch = 0;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int4                   iIdx;
  int4                   j;

  EXEC SQL begin declare section;
  char *pcOraCli;
  char pcOraRef[17+1];
  int2 sIndic;
  EXEC SQL VAR pcOraCli IS STRING;
  EXEC SQL VAR pcOraRef IS STRING;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  pcOraCli = apcNumcli;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureEmbauche");
    EXEC SQL OPEN crsLectureEmbauche
      USING :pcOraCli;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureEmbauche: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }

  apcRefext[0] = '\0';

  if ( (int4)GYBok == iIntRet )
  {
    EXEC SQL FETCH crsLectureEmbauche INTO
      :pcOraRef:sIndic;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( ((int4)GYBok != iIntRet) || ((int4)GYBok != sIndic) )
    {
      apcRefext[0] = '\0';
    }
    else
    {
      (void)strcpy(&apcRefext[0],&pcOraRef[0]);
    }
  }
  EXEC SQL close crsLectureEmbauche;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureEmbauche: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  GWTTrace (GWT_NIV_FONCT,
              ("Embauche: %s, %s\n", apcNumcli, apcRefext));

  return( iCodRet );
}


/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureStat
 *
 * But : code statistique
 *
 * Description : Lecture de ref
 *               dans la table GYTtabEStatAn.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureStat(char *apcNumcli, char *apcStat)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1                  indFinFetch = 0;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int4                   iIdx;
  int4                   j;

  EXEC SQL begin declare section;
  char *pcOraCli;
  char pcOraRef[100+1];
  int2 sIndic;
  EXEC SQL VAR pcOraCli IS STRING;
  EXEC SQL VAR pcOraRef IS STRING;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  pcOraCli = apcNumcli;
    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureStat");
    EXEC SQL OPEN crsLectureStat
      USING :pcOraCli;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureStat: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }

  apcStat[0] = '\0';

  if ( (int4)GYBok == iIntRet )
  {
    EXEC SQL FETCH crsLectureStat INTO
      :pcOraRef:sIndic;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( ((int4)GYBok != iIntRet) || ((int4)GYBok != sIndic) )
    {
      apcStat[0] = '\0';
    }
    else
    {
      (void)strcpy(&apcStat[0],&pcOraRef[0]);
    }
 }
  EXEC SQL close crsLectureStat;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureStat: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  GWTTrace (GWT_NIV_FONCT,
              ("Stat: %s, %s\n", apcNumcli, apcStat));

  return( iCodRet );
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givEcritureMotsCles
 *
 * But : cri mots cles
 *
 * Description : criture temre de cri
 *               depuis la table GYTtabMotsClesCri.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givEcritureMotsCles (char **buf_pos_in, GYBrDOCUMENT *doc, int4 iRef, int4 iObj, int4 indice, char* pcBalise)
{
  char *buf_pos;
  int4 iCodRet,iRet = GWCCodeOK;            /* Code retour de la fonction */
  char * pt_debut_liste,* pt_fin_liste,* pcFin;
  int4 lg_write;
  int4 i,j,k,iNbCRC,iDiff;
  char *pt_fin_lst;
  char *pt_debut;
  char *pt_fin;
  GYBrPrioCRCT rPrioCRC;
  GYBstrMClesCriIdT tcIdMCle;
  /* Pointeur sur debut du buffer */
  buf_pos = *buf_pos_in;
  GWTTrace (GWT_NIV_FONCT,("Critère Mot Clé écrit\n"));

  /* Ecriture dans le fichier de sortie */
  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  }

  *buf_pos_in=buf_pos;
    /* conversion du XMLType de GIVBuffInter */
    (void) givConvClob();
    lg_write = giv_ecrit_noeud_simple(buf_pos,pcBalise);
    buf_pos = buf_pos + lg_write;
    strcat(buf_pos, "<annonceur etablissement=\"\" id=\"");
    lg_write = strlen(buf_pos);
    memcpy(buf_pos+lg_write, &(doc+iRef)->value.objets_pub.micro[iObj].id[4],8);
    *(buf_pos+lg_write+8) = '\0';
    strcat(buf_pos, "\">");
    lg_write = strlen(buf_pos);
    *(buf_pos+lg_write) = SEPARE_LIGNE;
    *(buf_pos + (lg_write+1) )= LINE_FEED;
    *(buf_pos + (lg_write+2) )= '\0';
    buf_pos = (buf_pos + lg_write +2);
    lg_write = giv_ecrit_noeud_simple(buf_pos,"listMC");
    buf_pos = buf_pos + lg_write;
    pt_fin_lst = GIVBuffClob + strlen(GIVBuffClob);
    for (pt_debut = GIVBuffClob; pt_debut < pt_fin_lst; )
    {
      pt_fin=strchr(pt_debut, '|');
      if (pt_fin == 0)
      {
        pt_fin = pt_fin_lst;
      }
      /* analyse id */
      memcpy(tcIdMCle, pt_debut, (pt_fin - pt_debut));
      tcIdMCle[(pt_fin - pt_debut)] = '\0';
      GWTTrace (GWT_NIV_FONCT,("Critère Mot Clé écrit %s,%d\n",tcIdMCle,strlen(tcIdMCle)));
      lg_write =  giv_ecrit_element(buf_pos, "idMC", tcIdMCle);
      buf_pos = buf_pos + lg_write;
      pt_debut=pt_fin+1;
    }
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"listMC");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_noeud_simple(buf_pos,"annotation");
    buf_pos = buf_pos + lg_write;
    iNbCRC = giviNbCRC;
    iRet = givAnalyseObjetXML("MO", doc, GIVBuffInter, &buf_pos);
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"annotation");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"annonceur");
    buf_pos = buf_pos + lg_write;
    /* Ecriture dans le fichier de sortie de l'annotation déjà en UTF8 */
    iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
        if (giviNbCRC != iNbCRC)
        {
          iDiff = giviNbCRC - iNbCRC;
          for(i=1; i<indice; i++)
          {
            for(k=0; k<i; k++)
            {
              if (0 == strcmp((doc+i)->value.a_classer.etab,(doc+k)->value.a_classer.etab))
              {
                 break;
              }
            }
            if (k == i)
            {
              for(j=0; j<iDiff; j++)
              {
                (void)strcpy (rPrioCRC.acTpdsob,givrListCRC.trEltList[iNbCRC+j].acTpdsob);
                (void)strcpy (rPrioCRC.acCodan8,givrListCRC.trEltList[iNbCRC+j].acCodan8);
                (void)strcpy (rPrioCRC.acType,givrListCRC.trEltList[iNbCRC+j].acType);
                (void)strcpy (rPrioCRC.acEtab,(doc+i)->value.a_classer.etab);
                (void)strcpy (rPrioCRC.acCRC,givrListCRC.trEltList[iNbCRC+j].acCRC);
                rPrioCRC.iPrioCRC = givrListCRC.trEltList[iNbCRC+j].iPrioCRC;
              	iRet = givAjoutListCRC(rPrioCRC);
              	if ((int4)GIXCodeOK != iRet)
               	{
               		break;
               	}
              }
              if ((int4)GIXCodeOK != iRet)
              {
                break;
              }
            }
          }
        }

  *buf_pos_in=buf_pos;

  return( iCodRet );
}



/*----------------------------------Fonction----------------------------------*
 * Fonction : givEcritureBonPlan
 *
 * But : ref de Bon Plan
 *
 * Description : Lecture de ref
 *               dans la table GYTtabBonPlan.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givEcritureBonPlan(char *apcEtab,char **buf_pos_in)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1                  indFinFetch = 0;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int4                   iIdx,lg_ecr;
  int4                   j;
  char                  *buf_pos;

  EXEC SQL begin declare section;
  char tcEtab[GYBIeinscLgEtab2]; /* etab */
  char tcNumcli[GYBIeinscLgNumcli2]; /* client */
  char datfin[GYBIeinscLgDatmod +1]; /* date fin */
  char tcNb[6]; /* nombre */
  char cTyp;
  GYBrIamicT rOraIamic;
  int2 sIndic;
  EXEC SQL VAR tcEtab IS STRING;
  EXEC SQL VAR tcNb IS STRING;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  (void)strcpy (tcEtab,apcEtab);
  lg_ecr = 0;
  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureBonPlanPub");
    EXEC SQL OPEN crsLectureBonPlanPub
      USING :tcEtab, :tcEtab;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur open crsLectureBonPlanPub: [COD=%d TXT=%s EPJ=%s]\n", iIntRet, vErreurSQL.acDonnees_retour,apcEtab));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* accès via Objet Pub au BonPlan */
     (void)strcpy (vErreurSQL.acOrdre_sql,
                  "fetch crsLectureBonPlanPub");
      EXEC SQL FETCH crsLectureBonPlanPub INTO
      :tcEtab,:datfin:sIndic,:tcNb,:rOraIamic.acTpdsob,:cTyp,:tcNumcli;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        GWTTrace (GWT_NIV_FONCT,
              ("Pas de Bon Plan sur objet pub client : %s\n", tcEtab));
        iCodRet = (int4)GIXCodeKO;
      }
      else
      {
        GWTTrace (GWT_NIV_FONCT,
              ("Bon Plan sur objet pub client : %s,%c,%c\n", tcEtab, tcNb, cTyp));
      }
    }
    EXEC SQL close crsLectureBonPlanPub;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureBonPlanPub: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    }

  if ((int4)GIXCodeKO != iCodRet)
  {
    /* référence de BonPlan */
    if ((int4)GYBok != sIndic)
    {
     (void)strcpy (datfin,"");
    }
    GWTTrace (GWT_NIV_FONCT,
              ("BonPlanPub: %s, %s, %s, %s\n", tcEtab, datfin, tcNb, rOraIamic.acTpdsob));
    lg_ecr = giv_ecrit_balise(buf_pos, "1", "bonplan");
    buf_pos = buf_pos + lg_ecr;
    lg_ecr = giv_ecrit_balise(buf_pos, tcNb, "nb_bonplan");
    buf_pos = buf_pos + lg_ecr;
    lg_ecr = giv_ecrit_balise(buf_pos, datfin, "bonplan_df");
    buf_pos = buf_pos + lg_ecr;
    strcpy (buf_pos, "<offre_bonplan etab=");
    strcat (buf_pos, "\"");
    strcat (buf_pos, tcEtab);
    strcat (buf_pos, "\">");
    strcat (buf_pos, rOraIamic.acTpdsob);
    strcat (buf_pos, "</offre_bonplan>");
    lg_ecr = strlen(buf_pos);
    *(buf_pos + lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + lg_ecr + 1) = LINE_FEED;
    *(buf_pos + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
    buf_pos = (buf_pos + lg_ecr);
    *buf_pos_in=buf_pos;
  }
  return( iCodRet );
}


/*----------------------------------Fonction----------------------------------*
 * Fonction : givServiceEtabSEO
 *
 * But : numcli
 *
 * Description : Lecture de présence
 *               dans la table GYTtabSEOService.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givServiceEtabSEO(GYBrDOCUMENT *doc, char *apInfo, char *apAvis)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrIeinscT    rInscrip;
  char cOraInfo,cOraAvis;
  EXEC SQL end declare section;
  int4 i;
  iCodRet = (int4)GIXCodeKO;
  iIntRet = (int4)GIXCodeOK;

  if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
  {
    return( iCodRet);
  }
  (void)strcpy (rInscrip.acEtab,doc->value.a_classer.etab);

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureSrvSEO");
  EXEC SQL OPEN crsLectureSrvSEO
      USING :rInscrip.acEtab;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureSrvSEO: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureSrvSEO");
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureSrvSEO INTO
        :cOraInfo,:cOraAvis;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
      }
      else
      {
        *apInfo = cOraInfo;
        *apAvis = cOraAvis;
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeOK;
      }
    }

  }

  EXEC SQL close crsLectureSrvSEO;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureSrvSEO: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  return( iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givDnomPrincEtab
 *
 * But : numcli
 *
 * Description : Lecture de meilleure pub via etab
 *               dans la table GYTtabIAMIC.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givDnomPrincEtab(GYBrDOCUMENT *doc, int4 indice)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrIeinscT    rInscrip;
  char * pcVersion;
  char    cDepart[GYBIeinscLgDeppar+1];
  char         rOraTri[38];
  int4     iVolee;
  char tcBlocid[28+1];
  int2 indic;
  EXEC SQL VAR rOraTri IS STRING;
  EXEC SQL VAR tcBlocid IS STRING;
  EXEC SQL end declare section;
  char         rTri[38];
  int4 i,iRang;
  iCodRet = (int4)GIXCodeKO;
  iIntRet = (int4)GIXCodeOK;

  (void)strcpy (rInscrip.acEtab,doc->value.a_classer.etab);
  iRang = -1;
  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureDnomPrinc");
  EXEC SQL OPEN crsLectureDnomPrinc
      USING :rInscrip.acEtab;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureDnomPrinc: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureDnomPrinc");
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureDnomPrinc INTO
        :rOraTri;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
      }
      else
      {
         GWTTrace (GWT_NIV_FONCT,(" DnomPrinc... %s\n",rOraTri));
        indFinFetch = (int1)GIXCodeKO;
        for(i=0; i< indice; i++)
        {
          if (0 != strcmp((doc+i)->value.inscription[0].val_lslo,"0000"))
          {
            (void)strcpy (rTri,"0");
          }
          else
          {
            (void)strcpy (rTri,"1");
          }
          (void)strcpy (rTri,(doc+i)->value.inscription[0].val_num);
          (void)strcat (rTri,(doc+i)->value.inscription[0].val_lols);
          (void)strcat (rTri,(doc+i)->value.inscription[0].val_lslo);
          GWTTrace (GWT_NIV_FONCT,(" DnomPrinc Doc ... %s\n",rTri));
          if (0 == strcmp(&rOraTri[19],rTri))
          {
            break;
          }
        }
        if (indice == i)
        {
  	      iRang = -1;
        }
        else
        {
  	      iRang = i;
        }
        GWTTrace (GWT_NIV_FONCT,(" DnomPrinc Rang ... %s,%d\n",rOraTri,iRang));
      }
    }
  }

  EXEC SQL close crsLectureDnomPrinc;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureDnomPrinc: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if (-1 != iRang)
  {
    indic = -1;
    (void)strcpy (rInscrip.acNumnat,(doc+iRang)->value.inscription[0].val_num);
    (void)strcpy (rInscrip.acNumlo,(doc+iRang)->value.inscription[0].val_lo);
    (void)strcpy (rInscrip.acNumls,(doc+iRang)->value.inscription[0].val_ls);
    (doc+iRang)->value.numero_bloc_parution_ref[0] = '\0';
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "crsVersSeo");
    EXEC SQL open crsVersSEO using :rInscrip.acNumnat, :rInscrip.acNumlo, :rInscrip.acNumls;
    iIntRet = GIVBlocErreur(&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsVersSeo pour blocid principal : [COD=%d TXT=%s],%s,%s,%s\n", iIntRet, vErreurSQL.acDonnees_retour,
                rInscrip.acNumnat, rInscrip.acNumlo, rInscrip.acNumls));
    }
    else
    {
      EXEC SQL fetch crsVersSEO into :tcBlocid:indic;
;
      iIntRet = GIVBlocErreur(&vErreurSQL);
      if ( ((int4)GYBok != iIntRet) || (0 != indic) )
      {
        (doc+iRang)->value.numero_bloc_parution_ref[0] = '\0';
        GWTTrace (GWT_NIV_GRAVE,
                ("Absence de blocidlr pour ippal : %s,%s,%s et epj : %s\n",
                 rInscrip.acNumnat, rInscrip.acNumlo, rInscrip.acNumls, rInscrip.acEtab));
      }
      else
      {
    	  strcpy((doc+iRang)->value.numero_bloc_parution_ref, &tcBlocid[1]);
        if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
        {
          strcat((doc+iRang)->value.numero_bloc_parution_ref,"C0002");
        }
        else
        {
          strcat((doc+iRang)->value.numero_bloc_parution_ref,"C0001");
        }
      }
      EXEC SQL close crsVersSEO;
    }
  }

  return(iRang);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givExtraLocIS
 *
 * But : numcli
 *
 * Description : Lecture de ligne locale via etab, activité
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givExtraLocIS(char *apcEtab, char *apcCodAn8)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrIeinscT    rInscrip;
  GYBrIaprofT  rIaprof;
  EXEC SQL end declare section;
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
  {
    iCodRet = (int4)GIXCodeKO;
    return( iCodRet);
  }
  (void)strcpy (rInscrip.acEtab,apcEtab);
  (void)strcpy (rIaprof.acCodan8,apcCodAn8);

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureExtraLocIS");
  EXEC SQL OPEN crsLectureExtraLocIS
      USING :rIaprof.acCodan8,
            :rInscrip.acEtab,
            :rInscrip.acEtab,
            :rIaprof.acCodan8;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureExtraLocIS %s: [COD=%d TXT=%s]\n", rIaprof.acCodan8, iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureExtraLocIS");
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureExtraLocIS INTO
        :rIaprof.acCodan8;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeKO;
      }
      else
      {
        GWTTrace (GWT_NIV_FONCT,(" ExtraLocIS... %s\n",rIaprof.acCodan8));
        indFinFetch = (int1)GIXCodeKO;
      }
    }

  }
  GWTTrace (GWT_NIV_FONCT,(" ExtraLocIS... %d\n",iCodRet));

  EXEC SQL close crsLectureExtraLocIS;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureExtraLocIS: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  return( iCodRet);
}
int4 givExtraLocInterIS(char *apcEtab, char *apcCodAn8, GYBrDOCUMENT *docIG, int4 indice)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int4 i,j;
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrIeinscT    rInscrip;
  GYBrIaprofT  rIaprof;
  EXEC SQL end declare section;
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
  {
    iCodRet = (int4)GIXCodeKO;
    return( iCodRet);
  }
  (void)strcpy (rInscrip.acEtab,apcEtab);
  (void)strcpy (rIaprof.acCodan8,apcCodAn8);

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureExtraLocInterIS");
  EXEC SQL OPEN crsLectureExtraLocInterIS
      USING :rIaprof.acCodan8,
            :rInscrip.acEtab,
            :rInscrip.acEtab,
            :rIaprof.acCodan8;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureExtraLocInterIS %s: [COD=%d TXT=%s]\n", rIaprof.acCodan8, iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureExtraLocInterIS");
    iCodRet = (int4)GIXCodeKO;
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureExtraLocInterIS INTO
        :rInscrip.acNumnat,
        :rInscrip.acNumlo,
        :rInscrip.acNumls;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
      }
      else
      {
        GWTTrace (GWT_NIV_FONCT,(" ExtraLocInterIS... %s,%s,%s\n",rInscrip.acNumnat,rInscrip.acNumlo,rInscrip.acNumls));

        for(i=0; i< indice; i++)
        {
        GWTTrace (GWT_NIV_FONCT,(" ExtraLocInterIS... %s,%s,%s\n",(docIG+i)->value.inscription[0].val_num,(docIG+i)->value.inscription[0].val_lols,(docIG+i)->value.inscription[0].val_lslo));
            if ((0 == strcmp((docIG+i)->value.inscription[0].val_num,rInscrip.acNumnat)) &&
                (0 == strcmp((docIG+i)->value.inscription[0].val_lols,rInscrip.acNumlo)) &&
                (0 == strcmp((docIG+i)->value.inscription[0].val_lslo,rInscrip.acNumls)))
            {
              /* inscription trouvée dans le bloc */
              break;
            }
        }
        if (indice != i)
        {
           /* inscription trouvée dans le bloc */
           continue;
        }
           /* inscription non trouvée dans le bloc */
           iCodRet = (int4)GIXCodeOK;
           indFinFetch = (int1)GIXCodeKO;
      }
    }

  }
  GWTTrace (GWT_NIV_FONCT,(" ExtraLocInterIS... %d\n",iCodRet));

  EXEC SQL close crsLectureExtraLocInterIS;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureExtraLocInterIS: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }


  return( iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givExtraLocIO
 *
 * But : numcli
 *
 * Description : Lecture de ligne locale via etab, activité
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givExtraLocIO(GYBrDOCUMENT *doc)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrIeinscT    rInscrip;
  GYBrIaprofT  rIaprof;
  EXEC SQL end declare section;
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
  {
    return( iCodRet);
  }
  (void)strcpy (rInscrip.acEtab,doc->value.a_classer.etab);
  (void)strcpy (rInscrip.acNumnat,doc->value.inscription[0].val_num);
  (void)strcpy (rInscrip.acNumlo,doc->value.inscription[0].val_lo);
  (void)strcpy (rInscrip.acNumls,doc->value.inscription[0].val_ls);

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureExtraLocIO");
  EXEC SQL OPEN crsLectureExtraLocIO
      USING :rInscrip.acEtab,
            :rInscrip.acNumnat,
            :rInscrip.acNumlo,
            :rInscrip.acNumls,
            :rInscrip.acEtab,
            :rInscrip.acNumnat,
            :rInscrip.acNumlo,
            :rInscrip.acNumls,
            :rInscrip.acEtab;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureExtraLocIO %s: [COD=%d TXT=%s]\n", rIaprof.acCodan8, iIntRet, vErreurSQL.acDonnees_retour));
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureExtraLocIO");
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureExtraLocIO INTO
        :rIaprof.acCodan8;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
      }
      else
      {
        GWTTrace (GWT_NIV_FONCT,(" ExtraLocIO... %s\n",rIaprof.acCodan8));
        iCodRet = givExtraLocIS (doc->value.a_classer.etab, rIaprof.acCodan8);
        if ((int4)GIXCodeOK == iCodRet)
        {
          /* existence de locale */
          indFinFetch = (int1)GIXCodeKO;
        }
      }
    }

  }
  GWTTrace (GWT_NIV_FONCT,(" ExtraLocIO... %d\n",iCodRet));

  EXEC SQL close crsLectureExtraLocIO;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureExtraLocIO: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeOK;
  }

  return( iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givOppositionPart
 *
 * But : numcli
 *
 * Description : Lecture de la liste d'opposition
 *               d'une référence de partenaire.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givOppositionPart(char **buf, char *val)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrIapartT   rIapart;
  char         rOraOpp[16];
  EXEC SQL VAR rOraOpp IS STRING;
  EXEC SQL end declare section;
  int4 pipe;
  int4 lg_write = 0;
  char *buf_pos;
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  pipe = 0;
  buf_pos = *buf;
  (void)strcpy (rIapart.acOriPart, &val[strlen(val)-4]);
  (void)memcpy (rIapart.acRefPart, val, strlen(val)-4);
  rIapart.acRefPart[strlen(val)-4] = '\0';
  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureOppPart");
  EXEC SQL OPEN crsLectureOppPart
      USING :rIapart.acOriPart,
            :rIapart.acRefPart;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureOppPart %s,%s: [COD=%d TXT=%s]\n", rIapart.acOriPart, rIapart.acRefPart, iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureOppPart");
    GWTTrace (GWT_NIV_FONCT,(" Opposition Partenaire... %s,%s\n",rIapart.acOriPart, rIapart.acRefPart));
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureOppPart INTO
        :rOraOpp;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
      }
      else
      {
        GWTTrace (GWT_NIV_FONCT,("%s\n",rOraOpp));
        lg_write = giv_ecrit_balise(buf_pos, rOraOpp, "opp_part");
        buf_pos = buf_pos + lg_write;
        pipe = 1;
      }
    }

  }
  *buf = buf_pos;

  EXEC SQL close crsLectureOppPart;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureOppPart: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  return(iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givOppositionURLGratuite
 *
 * But : numcli
 *
 * Description : Lecture de l'ooposition sur le fichier GS lié à l'URL Gratuite
 *               dans la table GYTTabURLGrOpp.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givOppositionURLGratuite(char *apcEtab, char *apcCodAn8)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrIeinscT  rInscrip;
  GYBrIaprofT  rIaprof;
  EXEC SQL end declare section;
  int4 i;
  iCodRet = (int4)GIXCodeKO;
  iIntRet = (int4)GIXCodeOK;

  if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
  {
    return( iCodRet);
  }
  (void)strcpy (rInscrip.acEtab,apcEtab);
  (void)strcpy (rIaprof.acCodan8,apcCodAn8);

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureOppURLGr");
  EXEC SQL OPEN crsLectureOppURLGr
      USING :rInscrip.acEtab,
            :rIaprof.acCodan8;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureOppURLGr %s: [COD=%d TXT=%s]\n", rIaprof.acCodan8, iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureOppURLGr");
    GWTTrace (GWT_NIV_FONCT,(" OppURLGr... %s,%s\n",rIaprof.acCodan8,rInscrip.acEtab));
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureOppURLGr INTO
        :rIaprof.acCodan8;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeKO;
      }
      else
      {
        /* sortie sur opposition trouvée */
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeOK;
      }
    }

  }

  EXEC SQL close crsLectureOppURLGr;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureOppURLGr: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  return( iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureBListCRCLR
 *
 * But : numcli
 *
 * Description : Lecture du black-listage en liste réponse
 *               dans la table GYTTabBListCRCLR.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureBListCRCLR(GYBrPrioCRCT * aprPrioCRC)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrPrioCRCT rPrioCRC;
  EXEC SQL end declare section;
  iCodRet = (int4)GIXCodeKO;
  iIntRet = (int4)GIXCodeOK;

  if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
  {
    return( iCodRet);
  }
  /* variables Oracle */
  (void)strcpy (rPrioCRC.acEtab,aprPrioCRC->acEtab);
  (void)strcpy (rPrioCRC.acCodan8,aprPrioCRC->acCodan8);
  (void)strcpy (rPrioCRC.acTpdsob,aprPrioCRC->acTpdsob);
  (void)strcpy (rPrioCRC.acCRC,aprPrioCRC->acCRC);

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureBLCRCLR");
  EXEC SQL OPEN crsLectureBLCRCLR
      USING  :rPrioCRC.acEtab,
      	     :rPrioCRC.acCodan8,
      	     :rPrioCRC.acTpdsob,
      	     :rPrioCRC.acCRC;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureBLCRCLR : [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureBLCRCLR");
    GWTTrace (GWT_NIV_FONCT,(" BLCRCLR... %s,%s,%s,%s\n",rPrioCRC.acCodan8,rPrioCRC.acEtab,
                                                          rPrioCRC.acTpdsob,rPrioCRC.acCRC));
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureBLCRCLR INTO
        :rPrioCRC.acCodan8;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeKO;
      }
      else
      {
        /* sortie sur opposition trouvée */
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeOK;
      }
    }

  }

  EXEC SQL close crsLectureBLCRCLR;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureBLCRCLR: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  return( iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureBListCRCFD
 *
 * But : numcli
 *
 * Description : Lecture du black-listage en fiche détaillée
 *               dans la table GYTTabBListCRCLR.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureBListCRCFD(GYBrPrioCRCT * aprPrioCRC)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrPrioCRCT rPrioCRC;
  EXEC SQL end declare section;
  iCodRet = (int4)GIXCodeKO;
  iIntRet = (int4)GIXCodeOK;

  if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
  {
    return( iCodRet);
  }
  /* variables Oracle */
  (void)strcpy (rPrioCRC.acEtab,aprPrioCRC->acEtab);
  (void)strcpy (rPrioCRC.acCRC,aprPrioCRC->acCRC);
  (void)strcpy (rPrioCRC.acTpdsob,aprPrioCRC->acTpdsob);

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureBLCRCFD");
  EXEC SQL OPEN crsLectureBLCRCFD
      USING  :rPrioCRC.acEtab,
      	     :rPrioCRC.acCRC,
      	     :rPrioCRC.acTpdsob;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureBLCRCFD : [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureBLCRCFD");
    GWTTrace (GWT_NIV_FONCT,(" BLCRCFD... %s,%s,%s,%s\n",rPrioCRC.acCodan8,rPrioCRC.acEtab,
                                                          rPrioCRC.acTpdsob,rPrioCRC.acCRC));
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureBLCRCFD INTO
        :rPrioCRC.acTpdsob;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeKO;
      }
      else
      {
        /* sortie sur opposition trouvée */
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeOK;
      }
    }

  }

  EXEC SQL close crsLectureBLCRCFD;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureBLCRCFD: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  return( iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureBListEPJFD
 *
 * But : numcli
 *
 * Description : Lecture du black-listage en fiche détaillée
 *               dans la table GYTTabBListEPJFD.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureBListEPJFD(char * acEtab)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrPrioCRCT rPrioCRC;
  EXEC SQL end declare section;
  iCodRet = (int4)GIXCodeKO;
  iIntRet = (int4)GIXCodeOK;

  if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
  {
    return( iCodRet);
  }
  /* variables Oracle */
  (void)strcpy (rPrioCRC.acEtab,acEtab);

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureBLEPJFD");
  EXEC SQL OPEN crsLectureBLEPJFD
      USING  :rPrioCRC.acEtab;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureBLEPJFD : [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureBLEPJFD");
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureBLEPJFD INTO
        :rPrioCRC.acEtab;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeKO;
      }
      else
      {
        /* sortie sur opposition trouvée */
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeOK;
      }
    }
    GWTTrace (GWT_NIV_FONCT,(" BLEPJFD... %s,%d\n",rPrioCRC.acEtab,iCodRet));
  }

  EXEC SQL close crsLectureBLEPJFD;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureBLEPJFD: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  return( iCodRet);
}


/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureBListEPJProf
 *
 * But : numcli
 *
 * Description : Lecture du black-listage
 *               dans la table GYTTabBListEPJProf.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureBListEPJProf(char *apcEtab, char *apcCodAn8)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrIeinscT  rInscrip;
  GYBrIaprofT  rIaprof;
  EXEC SQL end declare section;
  iCodRet = (int4)GIXCodeKO;
  iIntRet = (int4)GIXCodeOK;

  if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
  {
    return( iCodRet);
  }
  /* variables Oracle */
  (void)strcpy (rInscrip.acEtab,apcEtab);
  (void)strcpy (rIaprof.acCodan8,apcCodAn8);

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureBLEPJProf");
  EXEC SQL OPEN crsLectureBLEPJProf
      USING  :rInscrip.acEtab,
      	     :rIaprof.acCodan8;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureBLEPJProf : [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureBLEPJProf");
    GWTTrace (GWT_NIV_FONCT,(" BLEPJProf... %s,%s\n",rIaprof.acCodan8,rInscrip.acEtab));
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureBLEPJProf INTO
        :rIaprof.acCodan8;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeKO;
      }
      else
      {
        /* sortie sur opposition trouvée */
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeOK;
      }
    }

  }

  EXEC SQL close crsLectureBLEPJProf;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureBLEPJProf: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  return( iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureBUC
 *
 * But : numcli
 *
 * Description : Lecture de numcli via etab
 *               dans la table GYTtabIEINSC.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureBUC(char *apcEtab, char *acMin, char *acMax)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  char tcEtab[GYBIeinscLgEtab2]; /* etab */
  char tcNumcli[GYBIeinscLgNumcli2]; /* client */
  char OraMin[5],OraMax[5];
  int2 sIndic;
  EXEC SQL VAR tcNumcli IS STRING;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  (void)strcpy (tcEtab,apcEtab);
  (void)strcpy (OraMin,acMin);
  (void)strcpy (OraMax,acMax);
  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureBUC");
  EXEC SQL OPEN crsLectureBUC
      USING :tcEtab,:OraMin,:OraMax;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureBUC: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }
  GWTTrace (GWT_NIV_FONCT,
              ("BUC: %s\n", apcEtab));

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureBUC");
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureBUC INTO
      :tcNumcli:sIndic;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if (( (int4)GYBok != iIntRet ) || ((int4)GYBok != sIndic))
      {
        indFinFetch = (int1)GIXCodeKO;
      }
      else
      {
        if (0 == strlen(buf_concat))
        {
          strcpy(buf_concat, &tcNumcli[4]);
        }
        else
        {
          strcat(buf_concat, "|");
          strcat(buf_concat, &tcNumcli[4]);
        }
        GWTTrace (GWT_NIV_FONCT,(" BUC... %s\n",buf_concat ));
      }
    }

  }

  EXEC SQL close crsLectureBUC;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureBUC: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  return( iCodRet);
}


/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureEvIlo
 *
 * But : ref back office ILO
 *
 * Description : Lecture de ref
 *               dans la table GYTtabEVILO.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureEvIlo(char *apcEtab, char *acEvt, char *acPrg)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1                  indFinFetch = 0;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  char *pcOraEtab;
  char cOraEvt ='\0', cOraPrg ='\0';
  int2 sIndEvt, sIndPrg;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  pcOraEtab = apcEtab;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureEvIlo");
    EXEC SQL OPEN crsLectureEvIlo
      USING :pcOraEtab;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureEvIlo: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }

  *acEvt = '\0';
  *acPrg = '\0';
  if ( (int4)GYBok == iIntRet )
  {
    EXEC SQL FETCH crsLectureEvIlo INTO
      :cOraEvt:sIndEvt,:cOraPrg:sIndPrg;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok == sIndEvt)
    {
      *acEvt = cOraEvt;
    }
    if ((int4)GYBok == sIndPrg)
    {
      *acPrg = cOraPrg;
    }
  }
  EXEC SQL close crsLectureEvIlo;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureEvIlo: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  GWTTrace (GWT_NIV_FONCT,
              ("EvIlo: %s, %c, %c\n", apcEtab, *acEvt, *acPrg));

  return( iCodRet );
}



/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureSIRET
 *
 * But : SIRET de Pages.
 *
 * Description : Lecture du siret
 *               dans la table GYTtabPagesPro.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureSIRET(char *apcSiret)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1                  indFinFetch = 0;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int4                   iIdx;
  int4                   j;

  EXEC SQL begin declare section;
  char tcSiret[GYBIeinscLgSiret2]; /* siret */
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

    (void)strcpy (tcSiret,apcSiret);

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureSIRET");
    EXEC SQL OPEN crsLectureSIRET
      USING :tcSiret;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureSIRET: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }

  if ( (int4)GYBok == iIntRet )
  {
    EXEC SQL FETCH crsLectureSIRET INTO
      :tcSiret;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
        iCodRet = (int4)GIXCodeKO;
    }
  }
  EXEC SQL close crsLectureSIRET;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureSIRET: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  return( iCodRet );
}


/*----------------------------------Fonction----------------------------------*
 * Fonction    :  GIVLectureTabPeEtab ()
 *
 * But         : Lecture d'un tuple dans la table PEETAB
 *
 * Description :
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *  Paramètres         :
 *
 *  Valeurs retournées : -1 : erreur dans le traitement
 *                        0 : acces a la table correct
 *
 *  Erreurs            : erreur SQL sur execution de la requete SELECT
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :    Jun/03/1996  (jli)
 *
 * Modification	(Mar/08/2006 - mb) : Rappel Gratuit
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 GIVLectureTabPeEtab (char *pcEtab)
{
  /* définition et initialisation des données locales */
  int4                iCodRet = 0;	/* Code retour de la fonction */
  int4                iIntRet = 0;	/* Code retour interne */
  int1	indFinFetch;			/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT  rErreurSQL;	/* Traitement des erreurs SQL */
  int4 iQualite;

  /* données d'interface sgbd */
  EXEC SQL begin declare section;
  GYBrIeinscT    *pvInscrip;
  GYBrIndIeinscT *pvIndInscrip;
  GYBrPeadrT    *pvAdr;
  GYBrIndPeadrT *pvIndAdr;
  EXEC SQL end declare section;

  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  /* la lecture se fait dans les vaibles globales */
  /** limite les passages d'argument des 60 champs et assure la cohérence de fiat */
  pvInscrip = &GIVvInscrip;
  pvIndInscrip = &GIVvIndInscrip;
  pvAdr    = &GIVvAdr;
  pvIndAdr = &GIVvIndAdr;

  /* initialisation des éléments de lcé de lecture de la table etab */
  strcpy (pvInscrip->acEtab,pcEtab);
  /* Ouverture curseur SQL (car requete type SELECT) */
  (void)strcpy (rErreurSQL.acOrdre_sql,
                "open crsLecturePeETAB");
  EXEC SQL
    open crsLecturePeEtab
    using :pvInscrip->acEtab;

  iIntRet = GIVBlocErreur (&rErreurSQL);

  if ((int4)GYBok != iIntRet)
  {
    /* Erreur sur declaration curseur SQL */
    GWTTrace (GWT_NIV_GRAVE,
              ("Erreur OPEN crsLecturePeEtab ...\n"));

    iCodRet = (int4)GIXCodeKO;
  }
  else
  {
    /* Execution requete de recherche (FETCH du curseur) */
    (void)strcpy (rErreurSQL.acOrdre_sql,
                  "fetch crsLecturePeEtab");
      pvIndInscrip->sArrondI = (int4)GYBnok;
    EXEC SQL
      fetch crsLecturePeEtab into
      :pvInscrip->acEtab:pvIndInscrip->sEtabI,
      :pvInscrip->acSiret:pvIndInscrip->sSiretI,
      :pvInscrip->acNaf:pvIndInscrip->sNafI,
      :pvInscrip->acDenom:pvIndInscrip->sDenomI,
      :pvInscrip->acCompln:pvIndInscrip->sComplnI,
      :pvInscrip->acCoddep:pvIndInscrip->sCoddepI,
      :pvInscrip->acCodloc:pvIndInscrip->sCodlocI,
      :pvInscrip->acAdrnr:pvIndInscrip->sAdrnrI,
      :pvInscrip->acCodvoi:pvIndInscrip->sCodvoiI,
      :pvInscrip->acTypvoi:pvIndInscrip->sTypvoiI,
      :pvInscrip->acLibvoi:pvIndInscrip->sLibvoiI,
      :pvInscrip->acNovoie:pvIndInscrip->sNovoieI,
      :pvInscrip->acCplnov:pvIndInscrip->sCplnovI,
      :pvAdr->acLongitude:pvIndAdr->sLongitudeI,
      :pvAdr->acLatitude:pvIndAdr->sLatitudeI,
      :pvAdr->acPrec:pvIndAdr->sPrecI;

    iIntRet = GIVBlocErreur (&rErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_BIZAR,
                ("Erreur execute LecturePeETAB : [COD=%d TXT=%s]\n", iIntRet, rErreurSQL.acDonnees_retour));
      if ((int4)GYBnodata == iIntRet)
      {
        GWTTrace (GWT_NIV_BIZAR,
                  ("pas de donnée dans PeEtab : [COD=%d TXT=%s]\n", iIntRet, rErreurSQL.acDonnees_retour));
      }
      iCodRet = (int4)GIXCodeKO;
    }
    /* Fermeture du curseur */
    (void)strcpy (rErreurSQL.acOrdre_sql,
                  "close crsLecturePeEtab");
    EXEC SQL close crsLecturePeEtab;

    iIntRet = GIVBlocErreur (&rErreurSQL);

    if ((int4)GYBok != iIntRet)
    {
      /* Erreur sur fermeture curseur SQL */
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur CLOSE crsLecturePeEtab ...\n"));

      iCodRet = (int4)GIXCodeKO;
    }
  }

  /* support et parution par défaut */
  GIVvIndInscrip.sInsuppI = 0;
  GIVvInscrip.acInsupp[0] = 1;
  GIVvIndInscrip.sInparuI = 0;
  strcpy(GIVvInscrip.acInparu,"0000");

  /* Tester la validité du géocodage */
  if (-1 == GIVvIndAdr.sPrecI)
  {
    iQualite = 99;
    snprintf(GIVvGeocod.tcQualite,GIVGeocodLgQualite+1,"%2d",99);
  }
  else
  {
    iQualite = atoi(GIVvAdr.acPrec);
    snprintf(GIVvGeocod.tcQualite,GIVGeocodLgQualite+1,"%2s",GIVvAdr.acPrec);
  }

  switch(iQualite)
  {
    case 96:
      GIVvGeocod.iStatus = GIVGeocodSEnvXY;
      break;

    case 97:
      GIVvGeocod.iStatus = GIVGeocodSEnvIndic;
      break;

    case 98:
      GIVvGeocod.iStatus = GIVGeocodSEnvXY;
      break;

    case 99:
      GIVvGeocod.iStatus = GIVGeocodSEnvRien;
      break;

    default:
      GIVvGeocod.iStatus = GIVGeocodSEnvXYQ;
      break;
  }

  if (-1 == GIVvIndAdr.sLongitudeI)
  { GIVvGeocod.tcLongitude[0] = '\0'; }
  else
  { snprintf(GIVvGeocod.tcLongitude,GIVGeocodLgLongitude+1,"%s",GIVvAdr.acLongitude); }

  if (-1 == GIVvIndAdr.sLatitudeI)
  { GIVvGeocod.tcLatitude[0] = '\0'; }
  else
  { snprintf(GIVvGeocod.tcLatitude,GIVGeocodLgLatitude+1,"%s",GIVvAdr.acLatitude); }

  /* Sortie de la fonction */
  return (iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction    :  givLectureTabZU ()
 *
 * But         :  Recherche de la zone urbaine
 *
 * Description :
 *
 *
 *
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres         :
 *
 *	Valeurs retournées : -1 : erreur dans le traitement
 *                            0 : pas de tuple trouve
 *
 *
 *	Erreurs            : erreur SQL sur execution de la requete SELECT
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Jan/17/2006  (mb)
 *
 * Modification	(MM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureTabZU (char *pcDep, char *pcLoc)

{

  int4			iCodRet;	/* Code retour de la fonction */
  int4			iIntRet;	/* Code retour des appels internes */
  int1			indFinFetch;	/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT	vErreurSQL;   /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrPelzuT    *pvPole;
  GYBrIndPelzuT *pvIndPole;
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givLectureZU\n"));

  if (0 == strcmp (givcLocFictive,pcLoc))
  {
    iCodRet = (int4)GIXCodeKO;
    /* appael inutile pour LF */
    return (iCodRet);
  }

  iIntRet = givPreparerLectureZU();

  if ((int4)GYBok != iIntRet)
  {
    /* Erreur sur prepare curseur SQL */
    GWTTrace (GWT_NIV_GRAVE,
              ("Erreur  crsLectureZU ...\n"));

    iCodRet = (int4)GIXCodeKO;
  }
  else
  {

    /* Initialisation des variables locales */
    iCodRet = (int4)GIXCodeOK;
    iIntRet = (int4)GIXCodeOK;
    indFinFetch = (int1)GIXCodeOK;

    /* Valorisation du pointeur vers la structure de description de la table PAYS */
    pvPole    = &GIVvPole;
    pvIndPole = &GIVvIndPole;

    /* Valorisation du pointeur vers la structure de description */
    /*   du tableau de recuperation des correspondances AN8/AN9 */

    (void)strcpy ((char *)pvPole->acDepart,
                  (const char *)pcDep);
    (void)strcpy ((char *)pvPole->acNumloc,
                  (const char *)pcLoc);

    /* Ouverture curseur SQL (car requete type SELECT) */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureZU");
    EXEC SQL
      open crsLectureZU
      using :pvPole->acDepart,
      :pvPole->acNumloc;

    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      /* Erreur sur declaration curseur SQL */
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur OPEN crsLectureZU ...\n"));

      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Execution requete de denombrement (FETCH du curseur) */
      indFinFetch = (int1)GIXCodeOK;

      while ((int1)GIXCodeOK == indFinFetch)
      {
        (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureZU");
        EXEC SQL
          fetch crsLectureZU into
          :pvPole->acDepPole:pvIndPole->sDepPoleI,
          :pvPole->acLocPole:pvIndPole->sLocPoleI
          ;

        iIntRet = GIVBlocErreur (&vErreurSQL);

        /* Analyse du code retour SQL */
        switch (iIntRet)
        {
          case (int4)GYBok :
          {
            indFinFetch = (int1)GIXCodeKO;
            iCodRet = (int4)GIXCodeOK;
            break;
          }

          case (int4)GYBnodata :
          {
            /* la localite n'existe pas */
            /* generer une signalisation */

            indFinFetch = (int1)GIXCodeKO;
            iCodRet = (int4)GIXCodeKO;
            break;
          }

          default :
          {
            /* la consultation de la base s'est mal passee */
            GWTTrace (GWT_NIV_GRAVE,
                      ("Erreur execute rqtLectureZU : [COD=%d TXT=%s]\n",
                       iIntRet,
                       vErreurSQL.acDonnees_retour));
            indFinFetch = (int1)GIXCodeKO;
            iCodRet = (int4)GIXCodeKO;
            break;
          }
        }
      }

      /* Fermeture du curseur */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "close crsLectureZU");
      EXEC SQL
        close crsLectureZU;

      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur fermeture curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur CLOSE crsLectureZU ...\n"));
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("GIVLectureZU\n"));

  return (iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction    :  givLectureTabLocFus ()
 *
 * But         :  Recherche de la localité fusionnée
 *
 * Description :
 *
 *
 *
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres         :
 *
 *	Valeurs retournées : -1 : erreur dans le traitement
 *                            0 : pas de tuple trouve
 *
 *
 *	Erreurs            : erreur SQL sur execution de la requete SELECT
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Nov/17/2016  (mb)
 *
 * Modification	(MM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureTabLocFus (char *pcDep, char *pcLoc)

{

  int4			iCodRet;	/* Code retour de la fonction */
  int4			iIntRet;	/* Code retour des appels internes */
  int1			indFinFetch;	/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT	vErreurSQL;   /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrPelzuT    *pvPole;
  GYBrIndPelzuT *pvIndPole;
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givLectureLocFus\n"));

  if (0 == strcmp (givcLocFictive,pcLoc))
  {
    iCodRet = (int4)GIXCodeKO;
    /* appael inutile pour LF */
    return (iCodRet);
  }

  iIntRet = givPreparerLectureLocFus();

  if ((int4)GYBok != iIntRet)
  {
    /* Erreur sur prepare curseur SQL */
    GWTTrace (GWT_NIV_GRAVE,
              ("Erreur  crsLectureLocFus ...\n"));

    iCodRet = (int4)GIXCodeKO;
  }
  else
  {

    /* Initialisation des variables locales */
    iCodRet = (int4)GIXCodeOK;
    iIntRet = (int4)GIXCodeOK;
    indFinFetch = (int1)GIXCodeOK;

    /* Valorisation du pointeur vers la structure de description de la table PAYS */
    pvPole    = &GIVvPole;
    pvIndPole = &GIVvIndPole;

    /* Valorisation du pointeur vers la structure de description */
    /*   du tableau de recuperation des correspondances AN8/AN9 */

    (void)strcpy ((char *)pvPole->acDepart,
                  (const char *)pcDep);
    (void)strcpy ((char *)pvPole->acNumloc,
                  (const char *)pcLoc);

    /* Ouverture curseur SQL (car requete type SELECT) */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureLocFus");
    EXEC SQL
      open crsLectureLocFus
      using :pvPole->acDepart,
      :pvPole->acNumloc;

    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      /* Erreur sur declaration curseur SQL */
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur OPEN crsLectureLocFus ...\n"));

      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Execution requete de denombrement (FETCH du curseur) */
      indFinFetch = (int1)GIXCodeOK;

      while ((int1)GIXCodeOK == indFinFetch)
      {
        (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureLocFus");
        EXEC SQL
          fetch crsLectureLocFus into
          :pvPole->acDepPole:pvIndPole->sDepPoleI,
          :pvPole->acLocPole:pvIndPole->sLocPoleI
          ;

        iIntRet = GIVBlocErreur (&vErreurSQL);

        /* Analyse du code retour SQL */
        switch (iIntRet)
        {
          case (int4)GYBok :
          {
            indFinFetch = (int1)GIXCodeKO;
            iCodRet = (int4)GIXCodeOK;
            break;
          }

          case (int4)GYBnodata :
          {
            /* la localite n'existe pas */
            /* generer une signalisation */

            indFinFetch = (int1)GIXCodeKO;
            iCodRet = (int4)GIXCodeKO;
            break;
          }

          default :
          {
            /* la consultation de la base s'est mal passee */
            GWTTrace (GWT_NIV_GRAVE,
                      ("Erreur execute rqtLectureLocFus : [COD=%d TXT=%s]\n",
                       iIntRet,
                       vErreurSQL.acDonnees_retour));
            indFinFetch = (int1)GIXCodeKO;
            iCodRet = (int4)GIXCodeKO;
            break;
          }
        }
      }

      /* Fermeture du curseur */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "close crsLectureLocFus");
      EXEC SQL
        close crsLectureLocFus;

      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur fermeture curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur CLOSE crsLectureLocFus ...\n"));
      }
    }
  }

  /* Sortie de la fonction */

  return (iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction    :  GIVLectureTabRegion ()
 *
 * But         :  Recherche de la région
 *
 * Description :
 *
 *
 *
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres         :
 *
 *	Valeurs retournées : -1 : erreur dans le traitement
 *                            0 : pas de tuple trouve
 *
 *
 *	Erreurs            : erreur SQL sur execution de la requete SELECT
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Jan/25/2006  (mb)
 *
 * Modification	(MM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureTabRegion (char *pcDep)

{

  int4			iCodRet;	/* Code retour de la fonction */
  int4			iIntRet;	/* Code retour des appels internes */
  int1			indFinFetch;	/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT	vErreurSQL;   /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrLjdeptT    *pvRegion;
  GYBrIndLjdeptT *pvIndRegion;
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givLectureRegion\n"));

  iIntRet = givPreparerLectureRegion();

  if ((int4)GYBok != iIntRet)
  {
    /* Erreur sur prepare curseur SQL */
    GWTTrace (GWT_NIV_GRAVE,
              ("Erreur  crsLectureRegion ...\n"));

    iCodRet = (int4)GIXCodeKO;
  }
  else
  {

    /* Initialisation des variables locales */
    iCodRet = (int4)GIXCodeOK;
    iIntRet = (int4)GIXCodeOK;
    indFinFetch = (int1)GIXCodeOK;

    /* Valorisation du pointeur vers la structure de description de la table PAYS */
    pvRegion    = &GIVvRegion;
    pvIndRegion = &GIVvIndRegion;

    /* Valorisation du pointeur vers la structure de description */
    /*   du tableau de recuperation des correspondances AN8/AN9 */

    (void)strcpy ((char *)pvRegion->acDepart,
                  (const char *)pcDep);

    /* Ouverture curseur SQL (car requete type SELECT) */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureRegion");
    EXEC SQL
      open crsLectureRegion
      using :pvRegion->acDepart;

    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      /* Erreur sur declaration curseur SQL */
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur OPEN crsLectureRegion ...\n"));

      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Execution requete de denombrement (FETCH du curseur) */
      indFinFetch = (int1)GIXCodeOK;

      while ((int1)GIXCodeOK == indFinFetch)
      {
        (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureRegion");
        if (0 == strcmp(givtcRegCECI, "NON"))
        {
          EXEC SQL
          fetch crsLectureRegion into
          :pvRegion->acRegion:pvIndRegion->sRegionI;

          (void)strcpy (pvRegion->acAncReg,pvRegion->acRegion);
        }
        else
        {
          EXEC SQL
          fetch crsLectureRegion into
          :pvRegion->acRegion:pvIndRegion->sRegionI,
          :pvRegion->acAncReg
          ;
        }

        iIntRet = GIVBlocErreur (&vErreurSQL);

        /* Analyse du code retour SQL */
        switch (iIntRet)
        {
          case (int4)GYBok :
          {
            indFinFetch = (int1)GIXCodeKO;
            iCodRet = (int4)GIXCodeOK;
            break;
          }

          case (int4)GYBnodata :
          {
            /* la localite n'existe pas */
            /* generer une signalisation */

            indFinFetch = (int1)GIXCodeKO;
            iCodRet = (int4)GIXCodeKO;
            break;
          }

          default :
          {
            /* la consultation de la base s'est mal passee */
            GWTTrace (GWT_NIV_GRAVE,
                      ("Erreur execute rqtLectureRegion : [COD=%d TXT=%s]\n",
                       iIntRet,
                       vErreurSQL.acDonnees_retour));
            indFinFetch = (int1)GIXCodeKO;
            iCodRet = (int4)GIXCodeKO;
            break;
          }
        }
      }

      /* Fermeture du curseur */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "close crsLectureRegion");
      EXEC SQL
        close crsLectureRegion;

      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur fermeture curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur CLOSE crsLectureRegion ...\n"));
      }
    }
  }

  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("GIVLectureRegion\n"));

  return (iCodRet);
}



/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_balise ()                                             */
/*                                                                            */
/* But       : ecrit une balise avec le nom des noeud et la valeur            */
/*             correspondante entre les balises.                              */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, le contenu et le nom des balises                    */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 giv_ecrit_balise (char *buf, char *contenu, char *nom_balise)
{

  int4 lg_ecr;
  lg_ecr = 0;

/* debut des methodes d'ecriture de balise simple*/
  if ((strlen(contenu) > 0) || (0 == strcmp("ippal",nom_balise)))
  {
    strcpy (buf, "<");
    strcat (buf, nom_balise);
    if (0 == strcmp("ippal",nom_balise))
    {
      strcat (buf, " ");
      strcat (buf, "blocidlr");
      strcat (buf, "=");
      strcat (buf, "\"");
      strcat (buf, contenu);
      strcat (buf, "\"");
    	strcat (buf, ">");
      strcat (buf, "true");
    }
    else
    {
    	strcat (buf, ">");
      strcat (buf, contenu);
    }
    strcat (buf, "</");
    strcat (buf, nom_balise);
    strcat (buf, ">");
    lg_ecr = strlen(buf);
    *(buf + lg_ecr) = SEPARE_LIGNE;
    *(buf + lg_ecr + 1) = LINE_FEED;
    *(buf + lg_ecr + 2) = '\0';
    lg_ecr += 2;
  }
  else if (0 == strcmp("bonplan_df",nom_balise))
  {
    strcpy (buf, "<");
    strcat (buf, nom_balise);
    strcat (buf, ">");
    strcat (buf, "</");
    strcat (buf, nom_balise);
    strcat (buf, ">");
    lg_ecr = strlen(buf);
    *(buf + lg_ecr) = SEPARE_LIGNE;
    *(buf + lg_ecr + 1) = LINE_FEED;
    *(buf + lg_ecr + 2) = '\0';
    lg_ecr += 2;
  }
  return(lg_ecr);

} /* fin des methodes d'ecriture de balise simple   */


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_balise_epj ()                                        */
/*                                                                            */
/* But       : ecrit une balise avec le nom des noeud et la valeur            */
/*             correspondante entre les balises avec traitement &,>,<         */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, le contenu et le nom des balises                    */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 giv_ecrit_balise_epj (char **buf_pos_in, char *contenu, char *nom_balise)
{
  char *buf_pos;
  int4 lg_ecr,i,j,iLg;
  int4  iCodRet = GWCCodeOK;
  lg_ecr = 0;
  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;
  iLg = strlen(contenu);
  if (strlen(contenu) > 0)
  {
    j = 0;
    for(i=0; i<iLg; i++)
    {
      if ( '<' == contenu[i])
      {
      	GIVBuffInter[j] = '\0';
      	strcat(GIVBuffInter,"&lt;");
        j = strlen(GIVBuffInter);
      }
      else if ( '>' == contenu[i])
      {
      	GIVBuffInter[j] = '\0';
      	strcat(GIVBuffInter,"&gt;");
        j = strlen(GIVBuffInter);
      }
      else if ( '"' == contenu[i])
      {
      	GIVBuffInter[j] = '\0';
      	strcat(GIVBuffInter,"&quot;");
        j = strlen(GIVBuffInter);
      }
      else if ( '&' == contenu[i])
      {
      	GIVBuffInter[j] = '\0';
      	strcat(GIVBuffInter,givTrad);
        j = strlen(GIVBuffInter);
      }
      else
      {
        GIVBuffInter[j] = contenu[i];
        j++;
      }
    }
    GIVBuffInter[j] = '\0';
    /* conversion du XMLType */
    (void) givConvClob();
    if (0 != strlen (nom_balise))
    {
      strcpy (buf_pos, "<");
      strcat (buf_pos, nom_balise);
      strcat (buf_pos, ">");
    }
    strcat (buf_pos, GIVBuffInter);
    if (0 != strlen (nom_balise))
    {
      strcat (buf_pos, "</");
      strcat (buf_pos, nom_balise);
      strcat (buf_pos, ">");
      lg_ecr = strlen(buf_pos);
      *(buf_pos + lg_ecr) = SEPARE_LIGNE;
      *(buf_pos + lg_ecr + 1) = LINE_FEED;
      *(buf_pos + lg_ecr + 2) = '\0';
      lg_ecr += 2;
    }
    /* Ecriture dans le fichier de sortie sans changement de format */
    iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
  }
  *buf_pos_in=buf_pos;

  return(lg_ecr);

}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_balise_iso ()                                        */
/*                                                                            */
/* But       : ecrit une balise avec le nom des noeud et la valeur            */
/*             correspondante entre les balises avec traitement &,>,<         */
/*             et traduction ASCIAE Iso                                       */
/*                                                                            */
/* Entree(s) : un buffer, le contenu et le nom des balises                    */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 giv_ecrit_balise_iso (char *buf_pos_in, char *contenu, char *nom_balise)
{
  char *buf_pos;
  int4 lg,lg_ecr,i,j;
  int4  iCodRet = GWCCodeOK;
  size_t lgInter, lg_in;
  iconv_t iConv;
  char * buf_in;
  char * buf_out;
  lg_ecr = 0;
  /* Initialisation pointeur */
  buf_pos = buf_pos_in;

  lg = strlen(contenu);
  if (lg > 0)
  {
    strcpy(GIVBuffInter, contenu);
    j = 0;
    for(i=0; i<lg; i++)
    {
      if ( '<' == GIVBuffInter[i])
      {
      	GIVBuffClob[j] = '\0';
      	strcat(GIVBuffClob,"&lt;");
        j = strlen(GIVBuffClob);
      }
      else if ( '>' == GIVBuffInter[i])
      {
      	GIVBuffClob[j] = '\0';
      	strcat(GIVBuffClob,"&gt;");
        j = strlen(GIVBuffClob);
      }
      else if ( '&' == GIVBuffInter[i])
      {
      	GIVBuffClob[j] = '\0';
      	strcat(GIVBuffClob,givTrad);
        j = strlen(GIVBuffClob);
      }
      else
      {
        GIVBuffClob[j] = GIVBuffInter[i];
        j++;
      }
    }
    GIVBuffClob[j] = '\0';
    /* Traduction UTF8 */
    iConv = iconv_open ("UTF-8","ISO8859-1");
    buf_in = GIVBuffClob;
    lg_in = strlen(GIVBuffClob)+1;
    buf_out = GIVBuffInter;
    lgInter = sizeof(GIVBuffInter);
    if ((iconv_t)(-1) != iConv)
    {
      iconv(iConv, &buf_in, (size_t *)&lg_in, &buf_out, (size_t *)&lgInter);
      iconv_close(iConv);
    }
    GWTTrace(GWT_NIV_FONCT,("libellé iso: <%s>,%d\n", GIVBuffInter, lg ));
    strcpy (buf_pos, "<");
    strcat (buf_pos, nom_balise);
    strcat (buf_pos, ">");
    strcat (buf_pos, GIVBuffInter);
    strcat (buf_pos, "</");
    strcat (buf_pos, nom_balise);
    strcat (buf_pos, ">");
    lg_ecr = strlen(buf_pos);
    *(buf_pos + lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + lg_ecr + 1) = LINE_FEED;
    *(buf_pos + lg_ecr + 2) = '\0';
    lg_ecr += 2;
    /* Pas d'Ecriture dans le fichier de sortie sans changement de format */
  }
  GWTTrace(GWT_NIV_FONCT,("Buffer iso: <%s>,%d\n", buf_pos, lg ));

  return(lg_ecr);

}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_noeud_simple ()                                      */
/*                                                                            */
/* But       : ecrit un noeud avec le nom du  noeud                           */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, le nom du noeud                                     */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 giv_ecrit_noeud_simple (char *buf, char *nom_noeud)
{
  int4 lg_ecr;

  if (strlen(nom_noeud) == 0)
  {
  	  return(0);
  }
  if (strlen(nom_noeud) > 0)
  {
    strcpy (buf, "<");
    strcat (buf, nom_noeud);
    strcat (buf, ">");
  }

  lg_ecr = strlen(buf);
  *(buf + lg_ecr) = SEPARE_LIGNE;
  *(buf + lg_ecr + 1) = LINE_FEED;
  *(buf + lg_ecr + 2) = '\0';

  return(lg_ecr + 2);

} /* Fin ecrire noeud simple */

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_noeud_attr ()                                      */
/*                                                                            */
/* But       : ecrit un noeud avec le nom du  noeud                           */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, le nom du noeud                                     */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 giv_ecrit_noeud_attr (char *buf, char *nom_noeud, char *val)
{
  int4 lg_ecr;

  if ((0 == strcmp(nom_noeud,"equipe")) && (0 != strlen(val)))
  {
  	strcpy (buf, "<");
    strcat (buf, nom_noeud);
    strcat (buf, " cle=\"");
    strcat (buf, val);
  	strcat (buf, "\">");
  }
  else if ((0 == strcmp(nom_noeud,"services")) && (0 != strlen(val)))
  {
  	strcpy (buf, "<");
    strcat (buf, nom_noeud);
    strcat (buf, " cle=\"");
    strcat (buf, val);
  	strcat (buf, "\">");
  }
  else if ((0 == strcmp(nom_noeud,"cle")) && (0 != strlen(val)))
  {
  	strcpy (buf, "<");
    strcat (buf, nom_noeud);
    strcat (buf, " type=\"PJDOC\">");
    strcat (buf, val);
  	strcat (buf, "</");
    strcat (buf, nom_noeud);
    strcat (buf, ">");
 }
  else if (strlen(nom_noeud) > 0)
  {
    strcpy (buf, "<");
    strcat (buf, nom_noeud);
    strcat (buf, ">");
  }

  lg_ecr = strlen(buf);
  *(buf + lg_ecr) = SEPARE_LIGNE;
  *(buf + lg_ecr + 1) = LINE_FEED;
  *(buf + lg_ecr + 2) = '\0';

  return(lg_ecr + 2);

} /* Fin ecrire noeud simple */

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_fin_noeud ()                                         */
/*                                                                            */
/* But       : ecrit la fin d'un noeud avec le nom du  noeud                  */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, le nom du noeud                                     */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 giv_ecrit_fin_noeud (char **buf_pos_in, char *nom_noeud)
{
  int4 lg_ecr;
  char *buf_pos;
  int4  iIntRet = GWCCodeOK;            /* Code retour de la fonction */
  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  if (strlen(nom_noeud) == 0)
  {
  	  return(0);
  }

  if (0 == strcmp("document",nom_noeud))
  {

    strcpy (buf_pos, "</");
    strcat (buf_pos, "blocepj");
    strcat (buf_pos, ">");
    lg_ecr = strlen(buf_pos);
    *(buf_pos + lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + lg_ecr + 1) = LINE_FEED;
    *(buf_pos + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
    buf_pos = (buf_pos + lg_ecr);

    /* Ecriture dans le fichier de sortie */
    iIntRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);

    strcpy (buf_pos, "</");
    strcat (buf_pos, "CONTENT");
    strcat (buf_pos, ">");
    lg_ecr = strlen(buf_pos);
    *(buf_pos + lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + lg_ecr + 1) = LINE_FEED;
    *(buf_pos + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
    buf_pos = (buf_pos + lg_ecr);
    strcpy (buf_pos, "</");
    strcat (buf_pos, "OPERATION");
    strcat (buf_pos, ">");
    lg_ecr = strlen(buf_pos);
    *(buf_pos + lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + lg_ecr + 1) = LINE_FEED;
    *(buf_pos + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
    buf_pos = (buf_pos + lg_ecr);
  }
  else if (0 == strcmp("documents",nom_noeud))
  {
    strcpy (buf_pos, "</");
    strcat (buf_pos, "OPERATIONS");
    strcat (buf_pos, ">");
    lg_ecr = strlen(buf_pos);
    *(buf_pos + lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + lg_ecr + 1) = LINE_FEED;
    *(buf_pos + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
  }
  else
  {
    if (strlen(nom_noeud) > 0)
    {
      strcpy (buf_pos, "</");
      strcat (buf_pos, nom_noeud);
      strcat (buf_pos, ">");
    }
    lg_ecr = strlen(buf_pos);
    *(buf_pos + lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + lg_ecr + 1) = LINE_FEED;
    *(buf_pos + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
  }

  *buf_pos_in=buf_pos;

  return(lg_ecr);

} /* Fin ecrire fin noeud  */


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_noeud ()                                             */
/*                                                                            */
/* But       : ecrit un noeud avec le nom du noeud et son contenu             */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, contenu du noeud, le nom du noeud, denomination     */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 giv_ecrit_noeud (char *buf, char *contenu_noeud, char *nom_noeud, char *name)
{
  int4 lg_ecr;

  if ((0 == memcmp("aff", contenu_noeud, strlen("aff"))) || (0 == memcmp("anot", contenu_noeud, strlen("anot"))))
  {
    strcpy (buf, "<");
    strcat (buf, contenu_noeud);
    strcat (buf, ">");
  }
  else if (strlen(name) > 0)
  {
    strcpy (buf, "<");
    strcat (buf, nom_noeud);
    strcat (buf, " ");
    strcat (buf, name);
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, contenu_noeud);
    strcat (buf, "\"");
    strcat (buf, ">");
  }
  else
  {
    strcpy (buf, "<");
    strcat (buf, nom_noeud);
    strcat (buf, ">");
  }

  lg_ecr = strlen(buf);
  *(buf + lg_ecr) = SEPARE_LIGNE;
  *(buf + lg_ecr + 1) = LINE_FEED;
  *(buf + lg_ecr + 2) = '\0';
  return(lg_ecr + 2);

} /* Fin ecrire noeud */


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_element ()                                           */
/*                                                                            */
/* But       : ecrit un element avec le nom de l'element et                   */
/*             une balise simple suivi de son contenu                         */
/*                                                                            */
/* Entree(s) : un buffer, le nom d'element, valeur                            */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 giv_ecrit_element (char *buf, char *nom, char *valeur)
{

  int4 lg_ecr, lg_write, lg_bal, lg_cpy;
  char *buf_bis = buf;
  char *buf_be = buf;
  int4 iRet;

  lg_ecr = 0;
  /* S'il y a un mot a ecrire */
  if ((strlen(nom) > 0) && (strlen(valeur) > 0))
  {

    /* Ecrire la balise */
    if ( (0 == memcmp("pjdep",nom,strlen("pjdep"))) || (0 == memcmp("pjreg",nom,strlen("pjreg"))) || (0 == memcmp("ipjdep",nom,strlen("ipjdep"))) || (0 == memcmp("ipjreg",nom,strlen("ipjreg"))) || (NULL != strstr(nom,"crc")) || (0 == memcmp("pjmotsrubriques",nom,strlen("pjmotsrubriques")))  || (0 == memcmp("pjmotcontenus",nom,strlen("pjmotcontenus"))) || (0 == memcmp("pjmotscontenusnormalise",nom,strlen("pjmotscontenusnormalise"))) || (0 == memcmp("pjmotscles",nom,strlen("pjmotscles"))))
    {
      /* suppression des doubles géographiques/an9 */
      iRet = supprimer_doublon(valeur, '|');
    }
    else if (0 == memcmp("pjrubriques",nom,strlen("pjrubriques")))
    {
      /* suppression des doubles géographiques/an9 */
      iRet = supprimer_doublon(valeur, '|');
    }
    lg_ecr = giv_ecrit_balise(buf_bis, valeur, nom);
  }

  return(lg_ecr);

} /* Fin ecrire element */


/*----------------------------------Fonction----------------------------------*
 * Fonction : givEcritureEtab
 *
 * But : champs du siret.
 *
 * Description : Lecture
 *               dans la table GYTtabPeeatb.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givEcritureEtab(GYBrDOCUMENT *doc, char **buf_pos_in, int4 *apiDeb)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int4 lg_ecr;
  char *buf_pos;

  EXEC SQL begin declare section;
  GYBrPeEtabT rEtab;
  GYBrIndPeEtabT rIndEtab;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  (void)strcpy (rEtab.acEtab, doc->value.a_classer.etab);
  lg_ecr = 0;
  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;
  doc->value.a_classer.opphoto = '\0';
  doc->value.a_classer.parinsee = '0';

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureEtab");
  EXEC SQL OPEN crsLectureEtab
    USING :rEtab.acEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    EXEC SQL FETCH crsLectureEtab INTO
      :rEtab.acDenom:rIndEtab.sDenomI,
      :rEtab.acNomDirgt:rIndEtab.sNomDirgtI,
      :rEtab.acParInsee,
      :rEtab.acRS:rIndEtab.sRSI,
      :rEtab.acRSCompl:rIndEtab.sRSComplI,
      :rEtab.acEnsgne:rIndEtab.sEnsgneI,
      :rEtab.acSigle:rIndEtab.sSigleI,
      :rEtab.acOppPhoto;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok == iIntRet)
    {
    	doc->value.a_classer.opphoto = rEtab.acOppPhoto;
      doc->value.a_classer.parinsee = rEtab.acParInsee;
      if (1 == *apiDeb)
      {
        *apiDeb = 0;
      }
      if ('1' != rEtab.acParInsee)
      {
      	/* opposition sur les données Insee */
      	rIndEtab.sRSI = (int4)GYBnok;
      	rIndEtab.sEnsgneI = (int4)GYBnok;
      	rIndEtab.sSigleI = (int4)GYBnok;
      	rIndEtab.sRSComplI = (int4)GYBnok;
      }
      strcpy (buf_pos, "<intitulesiret etab=\"");
      strcat (buf_pos, doc->value.a_classer.etab);
      strcat (buf_pos, "\">");
      lg_ecr = strlen(buf_pos);
      *(buf_pos + lg_ecr) = SEPARE_LIGNE;
      *(buf_pos + lg_ecr + 1) = LINE_FEED;
      *(buf_pos + lg_ecr + 2) = '\0';
      lg_ecr = lg_ecr + 2;
      buf_pos = (buf_pos + lg_ecr);
      iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
      if ((int4)GYBok == rIndEtab.sNomDirgtI)
      {
        lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acNomDirgt, "nomdirigeant");
      }
      if ((int4)GYBok == rIndEtab.sRSI)
      {
        lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acRS, "siretrs");
      }
      if ((int4)GYBok == rIndEtab.sRSComplI)
      {
        lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acRSCompl, "siretrscompl");
      }
      if ((int4)GYBok == rIndEtab.sEnsgneI)
      {
        lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acEnsgne, "siretenseigne");
      }
      if ((int4)GYBok == rIndEtab.sSigleI)
      {
      	lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acSigle, "siretsigle");
      }
      lg_ecr = giv_ecrit_fin_noeud(&buf_pos, "intitulesiret");
      buf_pos = buf_pos + lg_ecr;
    }
    *buf_pos_in=buf_pos;
  }
  EXEC SQL close crsLectureEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  return(iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givEcritureDenomEtab
 *
 * But : champs de dénominations secondaires.
 *
 * Description : Lecture
 *               dans la table GYTtabDenomsEtab.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givEcritureDenomEtab(GYBrDOCUMENT *doc, char **buf_pos_in, int4 *apiDeb)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int4 lg_ecr,i,j;
  char *buf_pos;
  EXEC SQL begin declare section;
  GYBrPeEtabT rEtab;
  EXEC SQL end declare section;
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  (void)strcpy (rEtab.acEtab, doc->value.a_classer.etab);
  lg_ecr = 0;
  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;
  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureDenomEtab");
  EXEC SQL OPEN crsLectureDenomEtab
    USING :rEtab.acEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureDenomEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  /* écriture utf8 */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);

  while ((int4)GYBok == iIntRet)
  {
    EXEC SQL FETCH crsLectureDenomEtab INTO
      :rEtab.acParInsee,
      :rEtab.acDenom;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok == iIntRet)
    {
      if ('6' != rEtab.acParInsee)
      {
      	/* seul libref traité */
      	continue;
      }
      if (1 == *apiDeb)
      {
        strcpy (buf_pos, "<intitulelibref etab=\"");
        strcat (buf_pos, rEtab.acEtab);
        strcat (buf_pos, "\">");
        lg_ecr = strlen(buf_pos);
        *(buf_pos + lg_ecr) = SEPARE_LIGNE;
        *(buf_pos + lg_ecr + 1) = LINE_FEED;
        *(buf_pos + lg_ecr + 2) = '\0';
        lg_ecr = lg_ecr + 2;
        buf_pos = (buf_pos + lg_ecr);
        /* écriture utf8 */
        iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
        *apiDeb = 0;
      }
      lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acDenom, "denomlibref");
    }
  }
  EXEC SQL close crsLectureDenomEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureDenomEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }
  if (0 == *apiDeb)
  {
    lg_ecr = giv_ecrit_fin_noeud(&buf_pos, "intitulelibref");
    buf_pos = buf_pos + lg_ecr;
  }
  *buf_pos_in=buf_pos;

  GWTTrace (GWT_NIV_FONCT,
              ("crsLectureDenomEtab: <%s> <%c>]\n", doc->value.a_classer.etab, doc->value.a_classer.parinsee));

  return(iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureObjetsEtab
 *
 * But : champs des objets pub de l'établissement.
 *
 * Description : Lecture
 *               dans la table GYTtabPeeatb.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureObjetsEtab(char *apcEtab, GYBrDOCUMENT *doc, int4 iNb)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  char *pcOraEtab;
  GYBrIamicT rIamicEtab;
  GYBrIamicT rIamicClient;
  GYBrIndIamicT  rIndIamic;
  EXEC SQL VAR pcOraEtab IS STRING;
  EXEC SQL end declare section;
  time_t date;
  int4 i,j,x,y,z,iRef;
  GYBrIapartT   rIapart;
  int4 iPJDC, iCHRO;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;
  iPJDC = -1;
  iCHRO = GIXCodeKO;

  pcOraEtab = apcEtab;

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLecturePubEtab");
  EXEC SQL OPEN crsLecturePubEtab
    USING :pcOraEtab,
    	    :pcOraEtab,
    	    :pcOraEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLecturePubEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  while ((int4)GYBok == iIntRet)
  {
    EXEC SQL FETCH crsLecturePubEtab INTO
      :rIamicEtab.acNumobj:rIndIamic.sNumobjI,
      :rIamicEtab.acTpdsob,
      :rIamicEtab.acStobj,
      :rIamicClient.acNumobj:rIndIamic.sNumobjI,
      :rIamicEtab.acDatact:rIndIamic.sDatactI;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok == iIntRet)
    {
        nb_micro = doc->value.objets_pub.nb_micro;
        if ((0 == strcmp(rIamicEtab.acTpdsob,giv_sCHRO)) && (0 == strcmp(rIamicEtab.acStobj,giv_ssCHRO))
        	&& (NULL == strstr(givtcFourPart,giv_CHRO)))
  	    {
  	    	/* protection car LC-CH remplacé par le partenaire CHRONORESTO */
  	    	continue;
  	    }
        if ((0 == strcmp(rIamicEtab.acTpdsob,giv_sPJDC)) && (0 == strcmp(rIamicEtab.acStobj,giv_ssPJDC))
        	&& (NULL == strstr(givtcFourPart,giv_PJDC)))
  	    {
  	    	/* protection car LP-CR remplacé par le partenaire PJDOC */
  	    	iPJDC = nb_micro;
  	    }
        if (-1 == rIndIamic.sDatactI)
        {
        	rIamicEtab.acDatact[0] = '\0';
        }
        if (-1 == rIndIamic.sNumobjI)
        {
        	strcpy(rIamicEtab.acNumobj,"0002");
        	strcat(rIamicEtab.acNumobj,apcEtab);
        	strcat(rIamicEtab.acNumobj,"0001");
          date = time(NULL);
          (void)strftime(rIamicEtab.acDatact, sizeof(rIamicEtab.acDatact), "%Y%m%d", localtime(&date));
        }
        strcpy(doc->value.objets_pub.micro[nb_micro].type, "X");
        strcpy(doc->value.objets_pub.micro[nb_micro].stype, rIamicEtab.acTpdsob);
        strcpy(doc->value.objets_pub.micro[nb_micro].sstype, rIamicEtab.acStobj);
        strcpy(doc->value.objets_pub.micro[nb_micro].id, rIamicEtab.acNumobj);
        strcpy(doc->value.objets_pub.micro[nb_micro].tcdatact, rIamicEtab.acDatact);
        doc->value.objets_pub.micro[nb_micro].valeur[0] ='\0';
        doc->value.objets_pub.micro[nb_micro].iCVI = 0;
        doc->value.objets_pub.micro[nb_micro].stypcvi[0] = '\0';
        strcpy(doc->value.objets_pub.micro[nb_micro].stypint, rIamicEtab.acTpdsob);
        GWTTrace (GWT_NIV_FONCT,
                ("Objet etab : %s,%s,%s\n", rIamicEtab.acTpdsob,rIamicEtab.acStobj,rIamicEtab.acNumobj));
        nb_micro++;
        doc->value.objets_pub.nb_micro = nb_micro;
    }
  }
  EXEC SQL close crsLecturePubEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLecturePubEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  /* ajout de l'objet LC-CH pour le partenaire CHRONORESTO */
  for(x=0; x< iNb; x++)
  {
   for(i=0; i< (doc+x)->value.a_classer.iNbPart; i++)
   {
  	iRef = strlen((doc+x)->value.a_classer.trpart[i].rpart);
    (void)strcpy (rIapart.acOriPart,&(doc+x)->value.a_classer.trpart[i].rpart[iRef-4]);
    if ( ((0 == strcmp(rIapart.acOriPart,giv_CHRO)) && (NULL == strstr(givtcFourPart,rIapart.acOriPart))
   	    	 && (GIXCodeKO == iCHRO))
        || ((0 == strcmp(rIapart.acOriPart,giv_PJDC)) && (NULL == strstr(givtcFourPart,rIapart.acOriPart))
   	    	 && (-1 == iPJDC)) )
  	{
      nb_micro = doc->value.objets_pub.nb_micro;
      strcpy(doc->value.objets_pub.micro[nb_micro].type, "X");
      strcpy(rIamicEtab.acNumobj,"0002");
      strcat(rIamicEtab.acNumobj,apcEtab);
      strcat(rIamicEtab.acNumobj,"0001");
      date = time(NULL);
      (void)strftime(rIamicEtab.acDatact, sizeof(rIamicEtab.acDatact), "%Y%m%d", localtime(&date));
      if (0 == strcmp(rIapart.acOriPart,giv_CHRO))
      {
        strcpy(doc->value.objets_pub.micro[nb_micro].stype, giv_sCHRO);
        strcpy(doc->value.objets_pub.micro[nb_micro].sstype, giv_ssCHRO);
        doc->value.objets_pub.micro[nb_micro].valeur[0] = '\0';
        iCHRO = GIXCodeOK;
      }
      else
      {
        strcpy(doc->value.objets_pub.micro[nb_micro].stype, giv_sPJDC);
        strcpy(doc->value.objets_pub.micro[nb_micro].sstype, giv_ssPJDC);
        iRef -= 4;
        for ( y = 0 ;( y < iRef && 0 == isdigit((doc+x)->value.a_classer.trpart[i].rpart[y]) ); y++);
        for ( z = y ;( z < iRef && 0 != isdigit((doc+x)->value.a_classer.trpart[i].rpart[z]) ); z++);
        (void)memcpy (doc->value.objets_pub.micro[nb_micro].valeur,&(doc+x)->value.a_classer.trpart[i].rpart[y],z-y);
 	  	  doc->value.objets_pub.micro[nb_micro].valeur[z-y] = '\0';
        iPJDC = nb_micro;
      }
      strcpy(doc->value.objets_pub.micro[nb_micro].id, rIamicEtab.acNumobj);
      strcpy(doc->value.objets_pub.micro[nb_micro].tcdatact, rIamicEtab.acDatact);
      doc->value.objets_pub.micro[nb_micro].iCVI = 0;
      doc->value.objets_pub.micro[nb_micro].stypcvi[0] = '\0';
      strcpy(doc->value.objets_pub.micro[nb_micro].stypint, doc->value.objets_pub.micro[nb_micro].stype);
      nb_micro++;
      doc->value.objets_pub.nb_micro = nb_micro;
    }
    else if ((0 == strcmp(rIapart.acOriPart,giv_PJDC)) && (NULL == strstr(givtcFourPart,rIapart.acOriPart))
   	    	 && (-1 != iPJDC))
 	  {
      GWTTrace (GWT_NIV_FONCT,("LP CR modifié pour PJDC %d, %s\n",iPJDC,(doc+x)->value.a_classer.trpart[i].rpart));
      strcpy(rIamicEtab.acNumobj,"0002");
      strcat(rIamicEtab.acNumobj,apcEtab);
      strcat(rIamicEtab.acNumobj,"0001");
      strcpy(doc->value.objets_pub.micro[iPJDC].id, rIamicEtab.acNumobj);
      iRef -= 4;
      for ( y = 0 ;( y < iRef && 0 == isdigit((doc+x)->value.a_classer.trpart[i].rpart[y]) ); y++);
      for ( z = y ;( z < iRef && 0 != isdigit((doc+x)->value.a_classer.trpart[i].rpart[z]) ); z++);
      (void)memcpy (doc->value.objets_pub.micro[nb_micro].valeur,&(doc+x)->value.a_classer.trpart[i].rpart[y],z-y);
 	  	doc->value.objets_pub.micro[nb_micro].valeur[z-y] = '\0';
    }
   }
   if ((GIXCodeOK == iCHRO) && (-1 != iPJDC))
   {
   	 break;
   }
  }
  for( i=0; (i< iNb && -1 != iPJDC); i++)
  {
 		/* recherche de l'existence d'une rubrique de type santé pour PJDOC */
    for( j = 0 ; (j < (doc+i)->value.rubriques.iNban9 && '0' == (doc+i)->value.rubriques.Tan9[j].dnex); j++);
    if ((doc+i)->value.rubriques.iNban9 != j)
    {
    	break;
    }
  }
  if ((-1 != iPJDC) && (iNb != i))
 	{
 		/* ajout du produit fictif de ranking PJDOC */
    nb_micro = doc->value.objets_pub.nb_micro;
    strcpy(doc->value.objets_pub.micro[nb_micro].type, "X");
    strcpy(rIamicEtab.acNumobj,"0001");
    strcat(rIamicEtab.acNumobj,apcEtab);
    strcat(rIamicEtab.acNumobj,"0001");
    date = time(NULL);
    (void)strftime(rIamicEtab.acDatact, sizeof(rIamicEtab.acDatact), "%Y%m%d", localtime(&date));
    strcpy(doc->value.objets_pub.micro[nb_micro].stype, giv_sRKPJDC);
    strcpy(doc->value.objets_pub.micro[nb_micro].sstype, giv_sRKPJDC);
    doc->value.objets_pub.micro[nb_micro].valeur[0] = '\0';
    strcpy(doc->value.objets_pub.micro[nb_micro].id, rIamicEtab.acNumobj);
    strcpy(doc->value.objets_pub.micro[nb_micro].tcdatact, rIamicEtab.acDatact);
    doc->value.objets_pub.micro[nb_micro].iCVI = 0;
    doc->value.objets_pub.micro[nb_micro].stypcvi[0] = '\0';
    strcpy(doc->value.objets_pub.micro[nb_micro].stypint, doc->value.objets_pub.micro[nb_micro].stype);
    nb_micro++;
    doc->value.objets_pub.nb_micro = nb_micro;
  }

  return(iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLecturePhotosEtab
 *
 * But : champs des photos de l'établissement.
 *
 * Description : Lecture
 *               dans la table GYTtabPhotoEtab.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLecturePhotosEtab(GYBrDOCUMENT *doc, char **buf_pos_in, int4 *apiDeb)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int1			indFinFetch;	/* Indicateur de fin de balayage du curseur */
  int4 lg_ecr;
  char *buf_pos;
  int4 iDeb;

  EXEC SQL begin declare section;
  GYBrPhotosEtabT rPhoto;
  GYBrIndPhotosEtabT rIndPhoto;
  OCIClobLocator * pClob;
  int2 sIndI;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  (void)strcpy (rPhoto.acEtab, doc->value.a_classer.etab);
  GWTTrace (GWT_NIV_FONCT,
              ("Photos pour Etab: %s\n", rPhoto.acEtab));
  lg_ecr = 0;
  iDeb = 0;
  GIVBuffInter[0] = '\0';
  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLecturePhotosEtab");
  EXEC SQL OPEN crsLecturePhotosEtab
    USING :rPhoto.acEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_GRAVE,
                ("Erreur open crsLecturePhotosEtab: [COD=%d TXT=%s] -%s-\n", iIntRet, vErreurSQL.acDonnees_retour,rPhoto.acEtab));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    /* Execution requete de denombrement (FETCH du curseur) */
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy(vErreurSQL.acOrdre_sql,"Allocate de CLOB");
    EXEC SQL ALLOCATE :pClob;
    EXEC SQL LOB CREATE TEMPORARY :pClob;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    GWTTrace (GWT_NIV_FONCT, ("Allocation CLOB pour GYTtabPhotosEtab\n"));
    /* Analyse du code resultat SQL */
    if ((int4)GWCCodeOK != iIntRet)
    {
      EXEC SQL close crsLecturePhotosEtab;
      iCodRet = iIntRet;
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur : [COD=%d TXT=%s]\n",
                 iCodRet,
                 vErreurSQL.acOrdre_sql));
      return( iCodRet );
    }
  	while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLecturePhotosEtab INTO
      :rPhoto.acPhoto:rIndPhoto.sPhotoI,
      :rPhoto.acTitre:rIndPhoto.sTitreI,
      :rPhoto.acCteUtil:rIndPhoto.sCteUtilI,
      :rPhoto.acOri:rIndPhoto.sOriI,
      :pClob:sIndI;

      iIntRet = GIVBlocErreur (&vErreurSQL);
      GWTTrace (GWT_NIV_FONCT,
              ("Photos pour Etab: %d,%d\n", iIntRet, sIndI));
      if (1 == *apiDeb)
      {
        lg_ecr = giv_ecrit_noeud_simple(buf_pos, "affugc");
        buf_pos = buf_pos + lg_ecr;
        *apiDeb = 0;
      }
      if (0 == iDeb)
      {
	      if (((int4)GYBnodata == iIntRet) && ('1' != doc->value.a_classer.opphoto))
	      {
	        /* Etab sans photo et sans opposition photo : on n'écrit pas le bloc <ugcetab> */
	        break;
	      }
        strcpy (buf_pos, "<ugcetab id=\"");
        strcat (buf_pos, doc->value.a_classer.etab);
        strcat (buf_pos, "\">");
        lg_ecr = strlen(buf_pos);
        *(buf_pos + lg_ecr) = SEPARE_LIGNE;
        *(buf_pos + lg_ecr + 1) = LINE_FEED;
        *(buf_pos + lg_ecr + 2) = '\0';
        lg_ecr = lg_ecr + 2;
        buf_pos = (buf_pos + lg_ecr);
        strcpy (buf_pos, "<oppphotos>");
        if ('1' == doc->value.a_classer.opphoto)
        {
          strcat (buf_pos, "ugc");
        }
        strcat (buf_pos, "</oppphotos>");
        lg_ecr = strlen(buf_pos);
        *(buf_pos + lg_ecr) = SEPARE_LIGNE;
        *(buf_pos + lg_ecr + 1) = LINE_FEED;
        *(buf_pos + lg_ecr + 2) = '\0';
        lg_ecr = lg_ecr + 2;
        buf_pos = (buf_pos + lg_ecr);
        lg_ecr = giv_ecrit_noeud_simple(buf_pos, "ugcphotos");
        buf_pos = buf_pos + lg_ecr;
      }
      if ((int4)GYBok == iIntRet)
      {
        lg_ecr = giv_ecrit_noeud_simple(buf_pos, "photo");
        buf_pos = buf_pos + lg_ecr;
        if ((int4)GYBok != rIndPhoto.sPhotoI)
        {
      	  rPhoto.acPhoto[0] = '\0';
        }
        if ((int4)GYBok != rIndPhoto.sTitreI)
        {
      	  rPhoto.acTitre[0] = '\0';
        }
        if ((int4)GYBok != rIndPhoto.sCteUtilI)
        {
      	  rPhoto.acCteUtil[0] = '\0';
        }
        if ((int4)GYBok != rIndPhoto.sOriI)
        {
      	  rPhoto.acOri[0] = '\0';
        }
      	rPhoto.acLongitude[0] = '\0';
      	rPhoto.acLatitude[0] = '\0';
        iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
        lg_ecr = giv_ecrit_balise_epj(&buf_pos, rPhoto.acPhoto, "identifiantphoto");
        lg_ecr = giv_ecrit_balise_epj(&buf_pos, rPhoto.acTitre, "legende");
        lg_ecr = giv_ecrit_balise_epj(&buf_pos, rPhoto.acOri, "origine");
        lg_ecr = giv_ecrit_balise_epj(&buf_pos, rPhoto.acCteUtil, "uid");
        if ((int4)GYBok == sIndI)
        {
   	      EXEC SQL LOB OPEN :pClob READ ONLY;
          /* lecture des données xmltype */
          givLectClob(pClob,doc->value.a_classer.etab,"",giv_PHO,giv_PHO);
          /* conversion du XMLType */
          (void) givConvClob();
          if (0 != strlen(GIVBuffInter))
          {
            strcpy(buf_pos, GIVBuffInter);
            lg_ecr = strlen(buf_pos);
            buf_pos = (buf_pos + lg_ecr);
          }
          EXEC SQL LOB CLOSE :pClob;
        }
        lg_ecr = giv_ecrit_fin_noeud(&buf_pos, "photo");
        buf_pos = buf_pos + lg_ecr;
        iDeb = 1;
      }
      else
      {
        /* fin de boucle */
        indFinFetch = (int1)GIXCodeKO;
        lg_ecr = giv_ecrit_fin_noeud(&buf_pos, "ugcphotos");
        buf_pos = buf_pos + lg_ecr;
        lg_ecr = giv_ecrit_fin_noeud(&buf_pos, "ugcetab");
        buf_pos = buf_pos + lg_ecr;
        iDeb = 1;
      }
    }
    EXEC SQL close crsLecturePhotosEtab;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLecturePhotosEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
     GWTTrace (GWT_NIV_FONCT, ("Liberation CLOB pour GYTtabPhotosEtab\n"));
    /* liberation CLOB */
    (void)strcpy(vErreurSQL.acOrdre_sql,"Liberation de CLOB");
    EXEC SQL LOB FREE TEMPORARY :pClob;
    EXEC SQL FREE :pClob;

        iIntRet = GIVBlocErreur (&vErreurSQL);

         /* Analyse du code resultat SQL */
        if ((int4)GYBok != iIntRet)
        {
          GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur : [COD=%d TXT=%s]\n",
                   iIntRet,
                   vErreurSQL.acOrdre_sql));
          GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur libération Clob PhotosEtab\n"));

        }
  }
  *buf_pos_in=buf_pos;

  return(iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givExtractPartEtab
 *
 * But : champs du calendrier et des photos du partenaire.
 *
 * Description : extract
 *               dans la table GYTtabPartEtab.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givExtractPartEtab(GYBrIapartT   *aprPart, char **buf_pos_in, char *apcType)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int1			indFinFetch;	/* Indicateur de fin de balayage du curseur */
  int4 lg_ecr;
  char *buf_pos;
  int4 iDeb;
  int4			iLgBuffer;
  int4			iLgRequete;

  EXEC SQL begin declare section;
  char cRequete[giv_LG_REQUETE*4];
  GYBrIapartT   rPart;
  static OCIClobLocator * pClob;
  int2 sIndI;
  EXEC SQL end declare section;
  static int4 iDejaPrepare = (int4)GWCCodeKO;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  (void)strcpy (rPart.acOriPart, aprPart->acOriPart);
  (void)strcpy (rPart.acRefPart, aprPart->acRefPart);
  lg_ecr = 0;
  iDeb = 0;
  GIVBuffInter[0] = '\0';
  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  /* Execution requete de denombrement (FETCH du curseur) */
  indFinFetch = (int1)GIXCodeOK;
  if ( (int4)GWCCodeOK != iDejaPrepare )
  {
  /* Controle de la longueur du texte de la requete */
  iLgRequete = strlen (GIV_RQ_SELECT_CALEND_PART);
  iLgBuffer = sizeof (cRequete);
  GWTTrace (GWT_NIV_FONCT,
            ("Longueurs : (requete -> %d  buffer -> %d)\n",
             iLgRequete,
             iLgBuffer));

  if (iLgBuffer <= iLgRequete)
  {
    /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */
    iCodRet = (int4)GIXCodeKO;
  }

  /* Construction du texte de la requete */
  if ((int4)GIXCodeOK == iCodRet)
  {
    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_PHOTO_PART);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLecturePhotoPart
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLecturePhotoPart");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLecturePhotoPart : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLecturePhotoPart");
      EXEC SQL
      declare crsLecturePhotoPart cursor for rqtLecturePhotoPart;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLecturePhotoPart ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }

    (void)sprintf (cRequete,
                   GIV_RQ_SELECT_CALEND_PART);

    GWTTrace (GWT_NIV_FONCT,
              ("Requetee SQL : %s\n",
               cRequete));

    /* Controle et parsing de la requete SQL */
    EXEC SQL
    prepare rqtLectureCalendPart
       from :cRequete;

    /* Traitement des erreurs SQL */
    (void)strcpy (vErreurSQL.acOrdre_sql,
                  "prepare rqtLectureCalendPart");

    iIntRet = GYBErreur (&vErreurSQL);
    if ((int4)GYBok != iIntRet)
    {
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur prepare rqtLectureCalendPart : [COD=%d TXT=%s]\n",
                 iIntRet,
                 vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
    else
    {
      /* Declaration curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "declare crsLectureCalendPart");
      EXEC SQL
      declare crsLectureCalendPart cursor for rqtLectureCalendPart;

      iIntRet = GYBErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur DECLARE crsLectureCalendPart ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
    }

  }

    (void)strcpy(vErreurSQL.acOrdre_sql,"Allocate de CLOB");
    EXEC SQL ALLOCATE :pClob;
    EXEC SQL LOB CREATE TEMPORARY :pClob;
   	/* EXEC SQL LOB OPEN :pClob READ ONLY; */
    iIntRet = GIVBlocErreur (&vErreurSQL);
    GWTTrace (GWT_NIV_FONCT, ("Allocation CLOB pour GYTtabPhotoPart\n"));
    /* Analyse du code resultat SQL */
    if ((int4)GWCCodeOK != iIntRet)
    {
      iCodRet = iIntRet;
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur : [COD=%d TXT=%s]\n",
                 iCodRet,
                 vErreurSQL.acOrdre_sql));
      return( iCodRet );
    }
  	iDejaPrepare = (int4)GWCCodeOK;
  }

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLecturePhotoPart");
  GWTTrace (GWT_NIV_FONCT,
              ("Appel PhotoPart: %s,%s\n",
               rPart.acOriPart,rPart.acRefPart));

  if (0 == strcmp(giv_PHO, apcType))
  {
    EXEC SQL OPEN crsLecturePhotoPart
    USING :rPart.acOriPart,
          :rPart.acRefPart;
  }
  else
  {
    EXEC SQL OPEN crsLectureCalendPart
    USING :rPart.acOriPart,
          :rPart.acRefPart;
  }
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_GRAVE,
                ("Erreur open crsLecturePhotoPart: [COD=%d TXT=%s] -%s-\n", iIntRet, vErreurSQL.acDonnees_retour,rPart.acRefPart));
    iCodRet = (int4)GIXCodeKO;
  }

  	while ((int1)GIXCodeOK == indFinFetch)
    {
      if (0 == strcmp(giv_PHO, apcType))
      {
        EXEC SQL FETCH crsLecturePhotoPart INTO
        :pClob:sIndI;
      }
      else
      {
        EXEC SQL FETCH crsLectureCalendPart INTO
        :pClob:sIndI;
      }

      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ((int4)GYBok == iIntRet)
      {
        if ((int4)GYBok == sIndI)
        {
          /* lecture des données xmltype */
          givLectClob(pClob,"",aprPart->acRefPart,apcType,apcType);
          /* conversion du XMLType */
          (void) givConvClob();
          if (0 != strlen(GIVBuffInter))
          {
            strcpy(buf_pos, GIVBuffInter);
            lg_ecr = strlen(buf_pos);
            buf_pos = (buf_pos + lg_ecr);
          }
        }
        /* fin de boucle */
        indFinFetch = (int1)GIXCodeKO;
      }
      else
      {
        /* fin de boucle */
        indFinFetch = (int1)GIXCodeKO;
      }
    }
    if (0 == strcmp(giv_PHO, apcType))
    {
      EXEC SQL close crsLecturePhotoPart;
    }
    else
    {
      EXEC SQL close crsLectureCalendPart;
    }
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLecturePhotoPart: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }
  *buf_pos_in=buf_pos;

  return(iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureLvsSeoEtab
 *
 * But : champs des liens vers les sites issus de SEO.
 *
 * Description : Lecture
 *               dans la table GYTtabLvsSeoEtab.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureLvsSeoEtab(GYBrDOCUMENT *doc, char **buf_pos_in, int4 *apiDeb)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int1			indFinFetch;	/* Indicateur de fin de balayage du curseur */
  int4 lg_ecr;
  char *buf_pos;
  int4 iDeb;

  EXEC SQL begin declare section;
  GYBrLvsSeoEtabT rLvs;
  GYBrIndLvsSeoEtabT rIndLvs;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  (void)strcpy (rLvs.acEtab, doc->value.a_classer.etab);
  lg_ecr = 0;
  iDeb = 0;
  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureLvsSeoEtab");
  EXEC SQL OPEN crsLectureLvsSeoEtab
    USING :rLvs.acEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_GRAVE,
                ("Erreur open crsLectureLvsSeoEtab: [COD=%d TXT=%s] -%s-\n", iIntRet, vErreurSQL.acDonnees_retour,rLvs.acEtab));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    /* Execution requete de denombrement (FETCH du curseur) */
    indFinFetch = (int1)GIXCodeOK;
  	while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureLvsSeoEtab INTO
       :rLvs.acIdstat:rIndLvs.sIdstatI,
       :rLvs.acPartseo:rIndLvs.sPartseoI,
       :rLvs.acUrlseo:rIndLvs.sUrlseoI,
       :rLvs.acAncre:rIndLvs.sAncreI,
       :rLvs.acFollow:rIndLvs.sFollowI,
       :rLvs.acOrdre:rIndLvs.sOrdreI;

      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ((int4)GYBok == iIntRet)
      {
        if (1 == *apiDeb)
        {
          lg_ecr = giv_ecrit_noeud_simple(buf_pos, "lvsparts");
          buf_pos = buf_pos + lg_ecr;
          *apiDeb = 0;
        }
        strcpy (buf_pos, "<lvspart etab=\"");
        strcat (buf_pos, doc->value.a_classer.etab);
        strcat (buf_pos, "\">");
        lg_ecr = strlen(buf_pos);
        *(buf_pos + lg_ecr) = SEPARE_LIGNE;
        *(buf_pos + lg_ecr + 1) = LINE_FEED;
        *(buf_pos + lg_ecr + 2) = '\0';
        lg_ecr = lg_ecr + 2;
        buf_pos = (buf_pos + lg_ecr);
        if ((int4)GYBok != rIndLvs.sIdstatI)
        {
      	  rLvs.acIdstat[0] = '\0';
        }
        if ((int4)GYBok != rIndLvs.sPartseoI)
        {
      	  rLvs.acPartseo[0] = '\0';
        }
        if ((int4)GYBok != rIndLvs.sUrlseoI)
        {
      	  rLvs.acUrlseo[0] = '\0';
        }
        if ((int4)GYBok != rIndLvs.sAncreI)
        {
      	  rLvs.acAncre[0] = '\0';
        }
        if ((int4)GYBok != rIndLvs.sFollowI)
        {
      	  rLvs.acFollow[0] = '\0';
        }
        if ((int4)GYBok != rIndLvs.sOrdreI)
        {
      	  rLvs.acOrdre[0] = '\0';
        }
        lg_ecr = giv_ecrit_balise(buf_pos, rLvs.acIdstat, "idstat");
        buf_pos = buf_pos + lg_ecr;
        iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
        if ((int4)GYBok == rIndLvs.sPartseoI)
        {
          lg_ecr = giv_ecrit_balise_epj(&buf_pos, rLvs.acPartseo, "partenaire");
        }
        if ((int4)GYBok == rIndLvs.sUrlseoI)
        {
          iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
          (void)strcpy(GIVBuffInter,rLvs.acUrlseo);
          (void) givConvClob();
          (void)strcpy(buf_concat,"<![CDATA[");
          (void)strcat(buf_concat,GIVBuffInter);
          (void)strcat(buf_concat,"]]>");
           GWTTrace (GWT_NIV_FONCT,
              ("URL DATA: %s\n", buf_concat));
          lg_ecr = giv_ecrit_balise(buf_pos, buf_concat, "url");
          buf_pos = buf_pos + lg_ecr;
          iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
        }
        if ((int4)GYBok == rIndLvs.sAncreI)
        {
          iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
          (void)strcpy(GIVBuffInter,rLvs.acAncre);
          (void) givConvClob();
          (void)strcpy(buf_concat,"<![CDATA[");
          (void)strcat(buf_concat,GIVBuffInter);
          (void)strcat(buf_concat,"]]>");
           GWTTrace (GWT_NIV_FONCT,
              ("ANCRE DATA: %s\n", buf_concat));
          lg_ecr = giv_ecrit_balise(buf_pos, buf_concat, "ancre");
          buf_pos = buf_pos + lg_ecr;
          iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
        }
        lg_ecr = giv_ecrit_balise(buf_pos, rLvs.acFollow, "follow");
        buf_pos = buf_pos + lg_ecr;
        lg_ecr = giv_ecrit_balise(buf_pos, rLvs.acOrdre, "ordre");
        buf_pos = buf_pos + lg_ecr;
        lg_ecr = giv_ecrit_fin_noeud(&buf_pos, "lvspart");
        buf_pos = buf_pos + lg_ecr;
      }
      else
      {
        /* fin de boucle */
        indFinFetch = (int1)GIXCodeKO;
      }
    }
    EXEC SQL close crsLectureLvsSeoEtab;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureLvsSeoEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }

    /* ecriture */
    iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);

  }
  *buf_pos_in=buf_pos;

  return(iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureLiensEtab
 *
 * But : champs des liens par epj.
 *
 * Description : Lecture
 *               dans la table GYTtabLvsEtab.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureLiensEtab(GYBrDOCUMENT *doc, char **buf_pos_in, int4 *apiDeb, int4 iNb)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */
  int1			indFinFetch;	/* Indicateur de fin de balayage du curseur */
  int4 lg_ecr;
  char *buf_pos;
  int4 iDeb,iRef;
  GYBrIapartT   rIapart;
  int4 i,k,kk,x;
  int4 iRang,iObj;

  EXEC SQL begin declare section;
  GYBrLienEtabT rLien;
  GYBrIndLienEtabT rIndLien;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  (void)strcpy (rLien.acEtab, doc->value.a_classer.etab);
  lg_ecr = 0;
  iDeb = 0;
  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureLiensEtab");
  EXEC SQL OPEN crsLectureLiensEtab
    USING :rLien.acEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_GRAVE,
                ("Erreur open crsLectureLiensEtab: [COD=%d TXT=%s] -%s-\n", iIntRet, vErreurSQL.acDonnees_retour,rLien.acEtab));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    /* Execution requete de denombrement (FETCH du curseur) */
    indFinFetch = (int1)GIXCodeOK;
  	while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureLiensEtab INTO
       :rLien.acTpdsob,
       :rLien.acStobj,
       :rLien.acNumobj,
       :rLien.acCle:rIndLien.sCleI,
       :rLien.acValeur:rIndLien.sValeurI;

      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ((int4)GYBok == iIntRet)
      {
        if ((0 == strcmp(rLien.acTpdsob,giv_sCHRO)) && (0 == strcmp(rLien.acStobj,giv_ssCHRO))
        	&& (NULL == strstr(givtcFourPart,giv_CHRO)))
  	    {
          for(x=0; x< iNb; x++)
          {
      	   for(i=0; i< (doc+x)->value.a_classer.iNbPart; i++)
           {
  	        /* ajout de LC-CH si partenaire CHRONORESTO */
  	        iRef = strlen((doc+x)->value.a_classer.trpart[i].rpart);
            (void)strcpy (rIapart.acOriPart,&(doc+x)->value.a_classer.trpart[i].rpart[iRef-4]);
            if (0 == strcmp(rIapart.acOriPart,giv_CHRO))
            {
            	break;
            }
  	    	 }
           if ((doc+x)->value.a_classer.iNbPart != i)
  	       {
  	    	  break;
  	    	 }
  	    	}
          if (iNb == x)
  	      {
  	    	  /* LC-CH non remplacé par le partenaire CHRONORESTO */
  	    	  continue;
  	    	}
  	    }

        if (1 == *apiDeb)
        {
          lg_ecr = giv_ecrit_noeud_simple(buf_pos, "elementsproduits");
          buf_pos = buf_pos + lg_ecr;
          *apiDeb = 0;
        }
        if ((int4)GYBok != rIndLien.sCleI)
        {
      	  rLien.acCle[0] = '\0';
        }
        buf_concat[0] = '\0';
        if ((int4)GYBok != rIndLien.sValeurI)
        {
      	  rLien.acValeur[0] = '\0';
        }
        else
        {
        	givConvURL(rLien.acValeur);
        }
        iRang = -1;
        for(i=0; i<givrListObj.iNbr; i++)
        {
          k = givrListObj.trEltRangListObj[i];
          kk = givrListObj.trEltListObj[k].iRgLigne;
          iObj = givrListObj.trEltListObj[k].iRgObj;
          if (iRang != givrListObj.trEltListObj[k].iRangTri)
          {
    	      iRang = givrListObj.trEltListObj[k].iRangTri;
            if ( 0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,rLien.acTpdsob) &&
          	0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype,rLien.acStobj) &&
          	0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].id,rLien.acNumobj) )
          	{
          		if ((0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,giv_sPJDC))
        		    && (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype,giv_ssPJDC))
        		    && (0 != strlen((doc+kk)->value.objets_pub.micro[iObj].valeur)))
          	  {
          		   /* si LP-CR pour PJDC */
          		   /* garder valeur du partenaire */
           	  }
           	  else
           	  {
          		  strcpy((doc+kk)->value.objets_pub.micro[iObj].valeur, buf_concat);
          		  break;
          	  }
          	}
          }
        }
        strcpy (buf_pos, "<reference id=\"");
        strcat (buf_pos, rLien.acNumobj);
        strcat (buf_pos, "\" pjproduits=\"X");
        strcat (buf_pos, rLien.acTpdsob);
        strcat (buf_pos, rLien.acStobj);
        strcat (buf_pos, "\">");
        lg_ecr = strlen(buf_pos);
        *(buf_pos + lg_ecr) = SEPARE_LIGNE;
        *(buf_pos + lg_ecr + 1) = LINE_FEED;
        *(buf_pos + lg_ecr + 2) = '\0';
        lg_ecr = lg_ecr + 2;
        buf_pos = (buf_pos + lg_ecr);
        strcpy (buf_pos, "<clevaleur cle=\"");
        strcat (buf_pos, rLien.acCle);
        strcat (buf_pos, "\">");
        strcat (buf_pos, buf_concat);
        strcat (buf_pos, "</clevaleur>");
        lg_ecr = strlen(buf_pos);
        *(buf_pos + lg_ecr) = SEPARE_LIGNE;
        *(buf_pos + lg_ecr + 1) = LINE_FEED;
        *(buf_pos + lg_ecr + 2) = '\0';
        lg_ecr = lg_ecr + 2;
        buf_pos = (buf_pos + lg_ecr);
        lg_ecr = giv_ecrit_fin_noeud(&buf_pos, "reference");
        buf_pos = buf_pos + lg_ecr;
      }
      else
      {
        /* fin de boucle */
        indFinFetch = (int1)GIXCodeKO;
      }
    }
    EXEC SQL close crsLectureLiensEtab;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ( (int4)GYBok != iIntRet )
    {
      GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureLiensEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
      iCodRet = (int4)GIXCodeKO;
    }

    /* ecriture */
    iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);

  }
  *buf_pos_in=buf_pos;

  return(iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureObjetsGCpt
 *
 * But : champs des objets pub d'un établissement Grand Compte
 *
 * Description : Lecture
 *               dans la table GYTtabURLGCpt.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureObjetsGCpt(char *apcEtab, GYBrDOCUMENT *doc, int4 aiIndic)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int4 i,j;
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  char *pcOraEtab;
  GYBrIamicT rIamicEtab;
  GYBrIndIamicT  rIndIamic;
  EXEC SQL VAR pcOraEtab IS STRING;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeKO;
  iIntRet = (int4)GIXCodeOK;

  pcOraEtab = apcEtab;

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLecturePubGCpt");
  EXEC SQL OPEN crsLecturePubGCpt
    USING :pcOraEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLecturePubGCpt: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  EXEC SQL FETCH crsLecturePubGCpt INTO
      :rIamicEtab.acLibUrl:rIndIamic.sLibUrlI;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ((int4)GYBok == iIntRet)
  {
    /* URL Grand Compte */
    GWTTrace (GWT_NIV_FONCT,
              ("URL Grand Compte: %s, %s\n", apcEtab, rIamicEtab.acLibUrl));
    strcpy(doc->value.objets_pub.libUrlGCpt, rIamicEtab.acLibUrl);
    iCodRet = (int4)GIXCodeOK;
    iIntRet = (int4)GIXCodeKO;
    for(i = 0; i < aiIndic; i++)
    {
      for(j = 0; j < (doc+i)->value.objets_pub.nb_micro; j++)
      {
        if ( ((doc+i)->value.objets_pub.micro[j].type[0] == 'X') &&
           (0 == strcmp((doc+i)->value.objets_pub.micro[j].stype, " U")) &&
           ( (0 == strcmp((doc+i)->value.objets_pub.micro[j].sstype, "PV")) ||
             (0 == strcmp((doc+i)->value.objets_pub.micro[j].sstype, "FS")) ) )
        {
          /* toujours objet U/PV */
          strcpy((doc+i)->value.objets_pub.micro[j].sstype, "PV");
          iIntRet = (int4)GIXCodeOK;
        }
      }
    }
    if ((int4)GIXCodeOK != iIntRet)
    {
      /* ajout objet U/PV */
      nb_micro = doc->value.objets_pub.nb_micro;
      strcpy(doc->value.objets_pub.micro[nb_micro].type, "X");
      strcpy(doc->value.objets_pub.micro[nb_micro].stype, " U");
      strcpy(doc->value.objets_pub.micro[nb_micro].sstype, "PV");
      strcpy(doc->value.objets_pub.micro[nb_micro].id, "0001");
      strcat(doc->value.objets_pub.micro[nb_micro].id, apcEtab);
      strcat(doc->value.objets_pub.micro[nb_micro].id, "0001");
      doc->value.objets_pub.micro[nb_micro].iCVI = 0;
      doc->value.objets_pub.micro[nb_micro].stypcvi[0] = '\0';
      strcpy(doc->value.objets_pub.micro[nb_micro].stypint, " U");
      GWTTrace (GWT_NIV_FONCT,
                ("Objet U/PV : %s\n", doc->value.objets_pub.micro[nb_micro].id));
      nb_micro++;
      doc->value.objets_pub.nb_micro = nb_micro;
    }
    iIntRet = (int4)GIXCodeKO;
    for(i = 0; i < aiIndic; i++)
    {
      for(j = 0; j < (doc+i)->value.objets_pub.nb_micro; j++)
      {
        if ( ((doc+i)->value.objets_pub.micro[j].type[0] == 'X') &&
           (0 == strcmp((doc+i)->value.objets_pub.micro[j].stype, " U")) &&
           (0 == strcmp((doc+i)->value.objets_pub.micro[j].sstype, "SR")) )
        {
          iIntRet = (int4)GIXCodeOK;
        }
      }
    }
    if ((int4)GIXCodeOK != iIntRet)
    {
      /* ajout objet U/SR */
      nb_micro = doc->value.objets_pub.nb_micro;
      strcpy(doc->value.objets_pub.micro[nb_micro].type, "X");
      strcpy(doc->value.objets_pub.micro[nb_micro].stype, " U");
      strcpy(doc->value.objets_pub.micro[nb_micro].sstype, "SR");
      strcpy(doc->value.objets_pub.micro[nb_micro].id, "0001");
      strcat(doc->value.objets_pub.micro[nb_micro].id, apcEtab);
      strcat(doc->value.objets_pub.micro[nb_micro].id, "0001");
      doc->value.objets_pub.micro[nb_micro].iCVI = 0;
      doc->value.objets_pub.micro[nb_micro].stypcvi[0] = '\0';
      strcpy(doc->value.objets_pub.micro[nb_micro].stypint, " U");
      GWTTrace (GWT_NIV_FONCT,
                ("Objet U/PV : %s\n", doc->value.objets_pub.micro[nb_micro].id));
      nb_micro++;
      doc->value.objets_pub.nb_micro = nb_micro;
    }
  }
  EXEC SQL close crsLecturePubGCpt;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLecturePubGCpt: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
  }

  return(iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureTypeContEtab
 *
 * But : champs des types de contenu d'un epj
 *
 * Description : Lecture
 *               dans la table GYTtabContenusEtab.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureTypeContEtab (char *apcEtab)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int4 i;
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  char *pcOraEtab;
  GYBrIamicT rObjEtab;
  GYBrIndIamicT  rIndObj;
  EXEC SQL VAR pcOraEtab IS STRING;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeKO;
  iIntRet = (int4)GIXCodeOK;

  pcOraEtab = apcEtab;

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureTypContEtab");
  EXEC SQL OPEN crsLectureTypContEtab
    USING :pcOraEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureTypContEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  while ((int4)GYBok == iIntRet)
  {
    EXEC SQL FETCH crsLectureTypContEtab INTO
    :rObjEtab.acTpdsob:rIndObj.sTpdsobI,:rObjEtab.acTypobj:rIndObj.sTypobjI;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok == iIntRet)
    {
    	if (MAX_LIST_CONT == giviNbContEtab)
    	{
        GWTTrace (GWT_NIV_GRAVE,("Nombre de type de contenus des epj atteint %d\n",giviNbContEtab ));
    		break;
    	}
	    strcpy(givrListContEtab[giviNbContEtab].tcEtab, pcOraEtab);
	    strcpy(givrListContEtab[giviNbContEtab].tcType, rObjEtab.acTpdsob);
	    if ((int4)GYBok !=  rIndObj.sTypobjI)
	    {
	      strcpy(givrListContEtab[giviNbContEtab].tcThm, "");
	    }
	    else
	    {
	      strcpy(givrListContEtab[giviNbContEtab].tcThm, rObjEtab.acTypobj);
	    }
      giviNbContEtab++;
    }
  }

  EXEC SQL close crsLectureTypContEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureTypContEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
  }

  return(iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureContProfEtab
 *
 * But : liens eta-prof pour les contenus
 *
 * Description : Lecture
 *               dans la table GYTtabProfEtab.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureContProfEtab (char *apcEtab)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int4 i,j;
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  char *pcOraEtab;
  char acCodan8[GYBIaprofLgCodan8 + 1];   /* code AN8 */
  int2 sCodan8I;
  char cIndic;
  char datmaj[GYBIeinscLgDatmod +1]; /* date fin */
  int2 sIndic;
  char tcType[3]; /* type */
  EXEC SQL VAR pcOraEtab IS STRING;
  EXEC SQL end declare section;

  iCodRet = (int4)GIXCodeKO;
  iIntRet = (int4)GIXCodeOK;

  pcOraEtab = apcEtab;

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureContProfEtab");
  EXEC SQL OPEN crsLectureContProfEtab
    USING :pcOraEtab,:pcOraEtab,:pcOraEtab,:pcOraEtab,:pcOraEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureContProfEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  while ((int4)GYBok == iIntRet)
  {
    EXEC SQL FETCH crsLectureContProfEtab INTO
    :cIndic,:tcType,:acCodan8:sCodan8I,:datmaj:sIndic;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok == iIntRet)
    {
    	if (MAX_LIST_CONT == giviNbProfEtab)
    	{
        GWTTrace (GWT_NIV_GRAVE,("Nombre de type de contenus des epj atteint %d\n",giviNbContEtab ));
    		break;
    	}
	    strcpy(givrListProfEtab[giviNbProfEtab].tcEtab, pcOraEtab);
	    if (0 == sCodan8I)
	    {
        for(i=0; i<givrListParu.iNbrTot; i++)
        {
          j= givrListParu.trEltRangList[i];
          if (0 == strcmp(givrListParu.trEltList[j].rubinit, acCodan8))
          {
            break;
          }
        }
        if (givrListParu.iNbrTot == i)
        {
        	/* code an8 absent du bloc */
        	continue;
        }
	      strcpy(givrListProfEtab[giviNbProfEtab].tcAn8, acCodan8);
	    }
	    else
	    {
	      givrListProfEtab[giviNbProfEtab].tcAn8[0] = '\0';
	    }
	    strcpy(givrListProfEtab[giviNbProfEtab].tcType, tcType);
	    givrListProfEtab[giviNbProfEtab].cIndic = cIndic;
      giviNbProfEtab++;
    }
  }

  EXEC SQL close crsLectureContProfEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureContProfEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
  }

  return(iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givLectureOldEtab
 *
 * But : champs des anciens établissements.
 *
 * Description : Lecture
 *               dans la table GYTtabLiensEtab.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureOldEtab(char **buf_pos_in, char *apcEtab)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  char *pcOraEtab;
  char tcEtab[GYBIeinscLgEtab2]; /* etab */
  char cType; /* type */
  char tcDatLien[GYBIeinscLgDatmod +1]; /* date */
  EXEC SQL VAR pcOraEtab IS STRING;
  EXEC SQL VAR tcEtab IS STRING;
  EXEC SQL end declare section;
  char *buf;
  char tcType[2];
  int4 pipe;
  int4 lg_ecr = 0;

  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;

  pcOraEtab = apcEtab;
  buf = *buf_pos_in;
  pipe = 0;

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureOldEtab");
  EXEC SQL OPEN crsLectureOldEtab
    USING :pcOraEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureOldEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  while ((int4)GYBok == iIntRet)
  {
    EXEC SQL FETCH crsLectureOldEtab INTO
      :tcEtab,:cType,:tcDatLien;
    iIntRet = GIVBlocErreur (&vErreurSQL);
    if ((int4)GYBok == iIntRet)
    {
        tcType[0] = cType;
        tcType[1] = '\0';
    	if (0 == pipe)
    	{
    	  pipe = 1;
          strcpy (buf, "<etab_repris type=\"");
        }
        else
        {
          strcat (buf, "<etab_repris type=\"");
        }
        strcat (buf, tcType);
        strcat (buf, "\"");
        strcat (buf, " date_reprise=\"");
        strcat (buf, tcDatLien);
        strcat (buf, "\">");
        if ('I' == cType)
        {
          strcat (buf, apcEtab);
        }
        else
        {
          strcat (buf, tcEtab);
        }
        strcat (buf, "</etab_repris>");
        lg_ecr = strlen(buf);
        *(buf + lg_ecr) = SEPARE_LIGNE;
        *(buf + lg_ecr + 1) = LINE_FEED;
        *(buf + lg_ecr + 2) = '\0';
        buf = buf + lg_ecr + 2;
    }
  }
  EXEC SQL close crsLectureOldEtab;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureOldEtab: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  *buf_pos_in = buf;

  return(iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_partie_3_obj       ()                                */
/*                                                                            */
/* But       : ecrit la partie trois par objet                                */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 giv_ecrit_partie_3_obj (char **buf_pos_in, GYBrDOCUMENT *docClone)
{


  int4 lg;                             /* Logueur du champ à traiter */
  int4 lg_write;
  char *buf_pos;
  int4  iCodRet;                      /* Code retour de la fonction */
  int4 pipe;                          /* Flag pour ajout pipe */
  int4 i,j,k,p,q,l;
  int4 iIntRet = GWCCodeOK;
  int4 iRgLigne, iObj;
  int4 iRg, iAlpha, iAn9, iNbGeoTri;
  char *pt_fin_lst;
  char *pt_debut;
  char *pt_fin;
  char tcRub[GYBIaprofLgCodan8 + GYBPaprofLgCodan9 + 1];

  iCodRet = GWCCodeOK;

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;
  for(i=0; i<givrListObj.iNbrTri; i++)
  {
    iAlpha = -1;
    pipe = 0;
    for(j=0; j<givrListObj.iNbr; j++)
    {
      k = givrListObj.trEltRangListObj[j];
      if (i != givrListObj.trEltListObj[k].iRangTri)
      {
        continue;
      }
      iRgLigne = givrListObj.trEltListObj[k].iRgLigne;
      iObj = givrListObj.trEltListObj[k].iRgObj;

      for(p=0; p<givrListParu.iNbrTot;p++)
      {
        q = givrListParu.trEltRangList[p];
        if (iRgLigne != givrListParu.trEltList[q].iRgLigne)
        {
          continue;
        }
        if (0 == strcmp((docClone+iRgLigne)->value.objets_pub.micro[iObj].stype, "DV"))
        {
          for(l=0; l<giviNbProfEtab; l++)
          {
        	  if (('V' == givrListProfEtab[l].cIndic)
        	  	&& (0 == strcmp(givrListProfEtab[l].tcType,"DV"))
        	  	&& (0 == strcmp(givrListProfEtab[l].tcAn8,givrListParu.trEltList[q].rubinit)))
        	  {
        	  	break;
        	  }
          }
          if (giviNbProfEtab == l)
          {
          	continue;
          }
        }
        if (0 == strcmp(givrListParu.trEltList[q].rub, givcR00000000))
        {
          iAn9 = 1;
        }
        else if (pipe == 0)
        {
          lg_write = giv_ecrit_noeud_simple(buf_pos,"objetrubrique");
          buf_pos = buf_pos + lg_write;
          iIntRet = giv_ecrit_objet_pub (&buf_pos, docClone, iRgLigne, iObj,"objetrub");
          strcpy(buf_concat, givrListParu.trEltList[q].rubinit);
          strcat(buf_concat, givrListParu.trEltList[q].rub);
          pipe = 1;
        }
        else
        {
          strcpy(tcRub, givrListParu.trEltList[q].rubinit);
          strcat(tcRub, givrListParu.trEltList[q].rub);
          if ((0 == strstr(buf_concat, tcRub)) && ((int4)strlen(buf_concat) < ((int4)sizeof(buf_concat) - (int4)strlen(givcR000000) - (int4)strlen(givcR000000))))
          {
            strcat(buf_concat, "|");
            strcat(buf_concat, givrListParu.trEltList[q].rubinit);
            strcat(buf_concat, givrListParu.trEltList[q].rub);
          }
        }
      }

    }
    if (1 == pipe)
    {
      iIntRet = supprimer_doublon(buf_concat, '|');
      pt_fin_lst = buf_concat + strlen(buf_concat);
      for (pt_debut = buf_concat; pt_debut < pt_fin_lst; )
      {
        pt_fin=strchr(pt_debut, '|');
        if (pt_fin == 0)
        {
          pt_fin = pt_fin_lst;
        }
        /* analyse rub */
        memcpy(tcRub, pt_debut, GYBIaprofLgCodan8);
        tcRub[GYBIaprofLgCodan8] = '\0';
        lg_write =  giv_ecrit_element(buf_pos, "objetan8", tcRub);
        buf_pos = buf_pos + lg_write;
        memcpy(tcRub, pt_debut+GYBIaprofLgCodan8, GYBPaprofLgCodan9);
        tcRub[GYBPaprofLgCodan9] = '\0';
        lg_write =  giv_ecrit_element(buf_pos, "objetan9", tcRub);
        buf_pos = buf_pos + lg_write;
        pt_debut=pt_fin+1;
      }
      lg_write = giv_ecrit_fin_noeud(&buf_pos,"objetrubrique");
      buf_pos = buf_pos + lg_write;
    }

  }

  *buf_pos_in=buf_pos;

  return(iCodRet);

}

int4 givInclusionRubrique (char *atcRub, GYBrDOCUMENT *doc, int4 aiRef)
{

  int4  iCodRet;                      /* Code retour de la fonction */
  int4 i,j,k,p,q;
  int4 iIntRet = GWCCodeOK;
  int4 iRang, iRgLigne;

  iCodRet = (int4)GWCCodeKO;
  iRang = doc->value.objets_pub.micro[aiRef].iRgObj;
  GWTTrace (GWT_NIV_FONCT,(" Rang objet-rub %d-%s\n",iRang,atcRub));
    for(j=0; j<givrListObj.iNbr; j++)
    {
      k = givrListObj.trEltRangListObj[j];
      if (iRang != givrListObj.trEltListObj[k].iRangTri)
      {
        continue;
      }
      iRgLigne = givrListObj.trEltListObj[k].iRgLigne;
  GWTTrace (GWT_NIV_FONCT,(" Rang ligne %d\n",iRgLigne));
      for(p=0; p<givrListParu.iNbrTot;p++)
      {
        q = givrListParu.trEltRangList[p];
        if (iRgLigne != givrListParu.trEltList[q].iRgLigne)
        {
          continue;
        }
  GWTTrace (GWT_NIV_FONCT,(" Rubrique %s\n",givrListParu.trEltList[q].rubinit));
        if (0 == strcmp(givrListParu.trEltList[q].rubinit, atcRub))
        {
          iCodRet = (int4)GWCCodeOK;
  GWTTrace (GWT_NIV_FONCT,(" Rubrique trouvée %s\n",givrListParu.trEltList[q].rubinit));
        }
      }
    }

  return(iCodRet);

}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_partie_3_ins       ()                                    */
/*                                                                            */
/* But       : ecrit la partie trois par inscription                                */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 giv_ecrit_partie_3_ins (char **buf_pos_in, GYBrDOCUMENT *docClone, int4 indice)
{


  char *buf_pos;
  int4  iCodRet,iRet;                      /* Code retour de la fonction */
  int4 m;
  int4 jRef;
  int4 lg_write;
  iCodRet = GWCCodeOK;

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  if (0 == strcmp(givtcParuInscEpj, "OUI"))
  {
    /* parution géographique par inscription */
    lg_write = giv_ecrit_noeud_simple(buf_pos,"iparution");
    buf_pos = buf_pos + lg_write;

    jRef = 0;
    m = 0;
    /* géopgaphie du moyen de communication */
    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_ARR, giv_ARR, "ipjdeplocarr");
    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_ARR, giv_LOC, "ipjdeplocarrextra");
    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_LOC, giv_LOC, "ipjdeploc");
    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_LOC, giv_ZU, "ipjdeploczoneurbaine");
    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_LOC, giv_DEPT, "ipjdeplocextraloc");
    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_ARR, giv_DEPT, "ipjdeplocarrextraloc");
    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_LOC, giv_EXTL, "ipjdeplocextradep");
    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_ARR, giv_EXTL, "ipjdeplocarrextradep");
    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_DEPT, giv_DEPT, "ipjdep");
    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_DEPT, giv_EXTL, "ipjdepextra");
    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_REG, giv_REG, "ipjreg");
    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_REG, giv_EXTL, "ipjregextra");


    lg_write = giv_ecrit_fin_noeud(&buf_pos,"iparution");
    buf_pos = buf_pos + lg_write;
  }

  /* Fin de l'entité inscription */
  lg_write = giv_ecrit_fin_noeud(&buf_pos,"inscription");
  buf_pos = buf_pos + lg_write;

  *buf_pos_in=buf_pos;

  return(iCodRet);

} /* Fin ecrit partie_3_ins  */



/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_noeud_rubriques ()                                   */
/*                                                                            */
/* But       : ecrit rubrique avec les codes an9 an8 si ceux ci sont fournis  */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, les differents codes                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/


static int4 giv_ecrit_noeud_rubriques (char *buf, char *val_codan8, char *val_codan9, char orig, char sante)
{
  int4 lg_ecr;
  int4 i,k;
  char *pt_fin_liste;
  char *pt_debut_element;
  char *pt_fin_element;
  int4 lg_element;
  int4 iIntRet;

  GIVBuffInter[0] = '\0';
  if ( 0 == strlen(buf) )
  {
    strcpy (buf, "<");
  }
  else
  {
    strcat (buf, "<");
  }
  strcat (buf, "rubrique");
  strcat (buf, " ");
  strcat (buf, "origine");
  strcat (buf, "=");
  strcat (buf, "\"");
  if ('4' == orig)
  {
    strcat (buf, "4");
  }
  else if ('6' == orig)
  {
    strcat (buf, "6");
  }
  else if ('7' == orig)
  {
    strcat (buf, "7");
  }
  else
  {
    strcat (buf, "1");
  }
  strcat (buf, "\"");
  strcat (buf, " ");
  strcat (buf, "codan8");
  strcat (buf, "=");
  strcat (buf, "\"");
  strcat (buf, val_codan8);
  strcat (buf, "\"");
  strcat (buf, " ");
  strcat (buf, "codan9");
  strcat (buf, "=");
  strcat (buf, "\"");
  strcat (buf, val_codan9);
  strcat (buf, "\"");
  strcat (buf, " ");
  strcat (buf, "sante");
  strcat (buf, "=");
  strcat (buf, "\"");
  if ('1' == sante)
  {
    strcat (buf, "1");
  }
  else
  {
    strcat (buf, "0");
  }
  strcat (buf, "\"");
  strcat (buf, ">");
  if (0 != strcmp(val_codan9, givcR00000000))
  {
    /* Afficher le texte de la rubrique (uniquement le premier) */
    /* Appel a la fonction de lecture du libelle de rubrique */
    iIntRet =  givLectureLibRub(val_codan9);
  }
  strcat (buf, GIVBuffInter);
  strcat (buf, "</");
  strcat (buf, "rubrique");
  strcat (buf, ">");

  lg_ecr = strlen(buf);
  *(buf + lg_ecr) = SEPARE_LIGNE;
  *(buf + lg_ecr + 1) = LINE_FEED;
  *(buf + lg_ecr + 2) = '\0';
  lg_ecr = lg_ecr + 2;

  return(lg_ecr);

}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_noeud_partenaire ()                                   */
/*                                                                            */
/* But       : ecrit origine et ref de partenaire                             */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, les differents codes                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/


static int4 giv_ecrit_noeud_partenaire (char **buf_in, char *val, char *blocid, char *etab)
{
  int4 lg_ecr,iIntRet;
  char * buf;

  buf = *buf_in;
  if ( 0 == strlen(buf) )
  {
    strcpy (buf, "<");
  }
  else
  {
    strcat (buf, "<");
  }
  strcat (buf, "info_part");
  strcat (buf, " ");
  strcat (buf, "source");
  strcat (buf, "=");
  strcat (buf, "\"");
  strcat (buf, &val[strlen(val)-4]);
  strcat (buf, "\"");
  strcat (buf, " ");
  strcat (buf, "ref");
  strcat (buf, "=");
  strcat (buf, "\"");
  lg_ecr = strlen(buf);
  memcpy (&buf[lg_ecr], val, strlen(val)-4);
  *(buf + lg_ecr + strlen(val)-4) = '\0';
  strcat (buf, "\"");
  strcat (buf, " ");
  strcat (buf, "id");
  strcat (buf, "=");
  strcat (buf, "\"");
  strcat (buf, blocid);
  strcat (buf, "\"");
  strcat (buf, " ");
  strcat (buf, "etab");
  strcat (buf, "=");
  strcat (buf, "\"");
  strcat (buf, etab);
  strcat (buf, "\"");
  strcat (buf, " />");
  lg_ecr = strlen(buf);
  *(buf + lg_ecr) = SEPARE_LIGNE;
  *(buf + lg_ecr + 1) = LINE_FEED;
  *(buf + lg_ecr + 2) = '\0';
  lg_ecr = lg_ecr + 2;
  buf = buf + lg_ecr;

  iIntRet = givOppositionPart(&buf, val);
  *buf_in = buf;
  iIntRet = GWCCodeOK;
  return(iIntRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_element_partenaire ()                                */
/*                                                                            */
/* But       : ecrit origine et ref de partenaire pour mutualisation          */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, les differents codes                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/


static int4 giv_ecrit_element_partenaire (char *nom_balise, char *buf, char *val, char *etab, char *parent)
{
  int4 lg_ecr;

  if ( 0 == strlen(buf) )
  {
    strcpy (buf, "<");
  }
  else
  {
    strcat (buf, "<");
  }
  if (0 != strcmp(givtcPartInsc, "OUI"))
  {
    strcat (buf, nom_balise);
    strcat (buf, " id=");
    strcat (buf, "\"");
    strcat (buf, val);
    strcat (buf, "\"");
    strcat (buf, " ");
  }
  else
  {
    strcat (buf, nom_balise);
    strcat (buf, " ");
    strcat (buf, "source");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, &val[strlen(val)-4]);
    strcat (buf, "\"");
    strcat (buf, " ");
    strcat (buf, "id");
    strcat (buf, "=");
    strcat (buf, "\"");
    lg_ecr = strlen(buf);
    memcpy (&buf[lg_ecr], val, strlen(val)-4);
    *(buf + lg_ecr + strlen(val)-4) = '\0';
    strcat (buf, "\"");
    strcat (buf, " ");
    if ((0 == strcmp(giv_PJDC, &val[strlen(val)-4])) && (0 != strlen(parent)))
    {
      strcat (buf, "parentId");
      strcat (buf, "=");
      strcat (buf, "\"");
      strcat (buf, parent);
      strcat (buf, "\"");
      strcat (buf, " ");
    }
  }
  strcat (buf, "etab");
  strcat (buf, "=");
  strcat (buf, "\"");
  strcat (buf, etab);
  strcat (buf, "\"");
  strcat (buf, ">");

  lg_ecr = strlen(buf);
  *(buf + lg_ecr) = SEPARE_LIGNE;
  *(buf + lg_ecr + 1) = LINE_FEED;
  *(buf + lg_ecr + 2) = '\0';
  lg_ecr = lg_ecr + 2;

  return(lg_ecr);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : GIV_ecrit_element_parent ()                                    */
/*                                                                            */
/* But       : ecrit parnet de partenaire                                     */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, les differents codes                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/


int4 GIV_ecrit_element_parent (char **buf_pos_in, GYBrIapartT   *prPart)
{
  int4 iRet;
  int4 lg_ecr = 0;
  char *buf;
  char tcIntl [GYBIeinscLgDenom2 + GYBIeinscLgPrenom2];

  /* Initialisation pointeur */
  buf = *buf_pos_in;
  if (giv_cPJDC == prPart->acTypeRefPart[0])
  {
    if ( 0 == strlen(buf) )
    {
      strcpy (buf, "<");
    }
    else
    {
      strcat (buf, "<");
    }
    strcat (buf, "cabinet");
    strcat (buf, " ");
    strcat (buf, "epj");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, prPart->acEtab);
    strcat (buf, "\">");
    lg_ecr = strlen(buf);
    *(buf + lg_ecr) = SEPARE_LIGNE;
    *(buf + lg_ecr + 1) = LINE_FEED;
    *(buf + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
    buf = buf + lg_ecr;
    /* Ecriture dans le fichier de sortie */
    iRet = giv_sortie (&buf, GIVfDescFicBloc);
    if (0 == strcmp(givtcInvDenPn,"NON"))
    {
      strcpy(tcIntl, prPart->acDenom);
      if (0 != strlen(prPart->acPrenom))
      {
        strcat(tcIntl, " ");
        strcat(tcIntl, prPart->acPrenom);
      }
    }
    else
    {
  	  /* inversion de l'ordre de la denomination-prénom */
      if (0 != strlen(prPart->acPrenom))
      {
        strcpy(tcIntl, prPart->acPrenom);
        strcat(tcIntl, " ");
        strcat(tcIntl, prPart->acDenom);
      }
      else
      {
        strcpy(tcIntl, prPart->acDenom);
      }
    }
    lg_ecr = giv_ecrit_balise_epj(&buf, tcIntl, "denom");
    strcat (buf, "</cabinet>");
    lg_ecr = strlen(buf);
    *(buf + lg_ecr) = SEPARE_LIGNE;
    *(buf + lg_ecr + 1) = LINE_FEED;
    *(buf + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
  }
  else if (giv_prPJDC == prPart->acTypeRefPart[0])
  {
    if ( 0 == strlen(buf) )
    {
      strcpy (buf, "<");
    }
    else
    {
      strcat (buf, "<");
    }
    strcat (buf, "medecin");
    strcat (buf, " ");
    strcat (buf, "id");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, prPart->acIdMed);
    strcat (buf, "\"");
    strcat (buf, " ");
    strcat (buf, "epj");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, prPart->acEtab);
    strcat (buf, "\"");
    strcat (buf, " ");
    strcat (buf, "ref");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, prPart->acRefPart);
    strcat (buf, "\"");
    strcat (buf, " ");
    strcat (buf, "estDoc");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, prPart->acIsDoc);
    strcat (buf, "\">");
    lg_ecr = strlen(buf);
    *(buf + lg_ecr) = SEPARE_LIGNE;
    *(buf + lg_ecr + 1) = LINE_FEED;
    *(buf + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
    buf = buf + lg_ecr;
    /* Ecriture dans le fichier de sortie */
    iRet = giv_sortie (&buf, GIVfDescFicBloc);
    if (0 == strcmp(givtcInvDenPn,"NON"))
    {
      strcpy(tcIntl, prPart->acDenom);
      if (0 != strlen(prPart->acPrenom))
      {
        strcat(tcIntl, " ");
        strcat(tcIntl, prPart->acPrenom);
      }
    }
    else
    {
  	  /* inversion de l'ordre de la denomination-prénom */
      if (0 != strlen(prPart->acPrenom))
      {
        strcpy(tcIntl, prPart->acPrenom);
        strcat(tcIntl, " ");
        strcat(tcIntl, prPart->acDenom);
      }
      else
      {
        strcpy(tcIntl, prPart->acDenom);
      }
    }
    lg_ecr = giv_ecrit_balise_epj(&buf, tcIntl, "denom");
    iRet =  givExtractPartEtab(prPart, &buf, giv_PHO);
    /* Ecriture dans le fichier de sortie */
    iRet = (int4)giv_sortie ( &buf, GIVfDescFicBloc );
    strcpy (buf, "<rubrique");
    strcat (buf, " ");
    strcat (buf, "an9");
    strcat (buf, "=\"");
    strcat (buf, prPart->acCodan9);
    strcat (buf, "\">");
    if (0 != strlen(prPart->acCodan9))
    {
      /* Afficher le texte de la rubrique (uniquement le premier) */
      /* Appel a la fonction de lecture du libelle de rubrique */
      iRet =  givLectureLibRub(prPart->acCodan9);
      strcat (buf, GIVBuffInter);
    }
    strcat (buf, "</");
    strcat (buf, "rubrique");
    strcat (buf, ">");
    lg_ecr = strlen(buf);
    *(buf + lg_ecr) = SEPARE_LIGNE;
    *(buf + lg_ecr + 1) = LINE_FEED;
    *(buf + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
    strcat (buf, "</medecin>");
    lg_ecr = strlen(buf);
    *(buf + lg_ecr) = SEPARE_LIGNE;
    *(buf + lg_ecr + 1) = LINE_FEED;
    *(buf + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
    /* Ecriture dans le fichier de sortie */
    iRet = (int4)giv_sortie_ISO ( &buf, GIVfDescFicBloc );
    lg_ecr = 0;
  }
  else
  {
  	GWTTrace (GWT_NIV_GRAVE, ("WARNING : type de référence de partenaire erroné : <%c> epj <%s>\n",prPart->acTypeRefPart[0],prPart->acEtab));
  }
  *buf_pos_in = buf;

  return(lg_ecr);

}

int4 giv_ecrit_elements_nav (char **buf_pos_in, GYBrIapartT   *prPart)
{
  int4 iRet;
  int4 lg_ecr = 0;
  char *buf;
  char tcIntl [GYBIeinscLgDenom2 + GYBIeinscLgPrenom2];

  /* Initialisation pointeur */
  buf = *buf_pos_in;
  if (giv_prPJDC == prPart->acTypeRefPart[0])
  {
    if ( 0 == strlen(buf) )
    {
      strcpy (buf, "<");
    }
    else
    {
      strcat (buf, "<");
    }
    strcat (buf, "medecin");
    strcat (buf, " ");
    strcat (buf, "id");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, prPart->acIdMed);
    strcat (buf, "\"");
    strcat (buf, " ");
    strcat (buf, "ref");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, prPart->acRefPart);
    strcat (buf, "\"");
    strcat (buf, " ");
    strcat (buf, "epj");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, prPart->acEtab);
    strcat (buf, "\"");
    strcat (buf, " ");
    strcat (buf, "estDoc");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, prPart->acIsDoc);
    strcat (buf, "\"");
    strcat (buf, " ");
    strcat (buf, "paruLR");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, prPart->acParuLR);
    strcat (buf, "\">");
    lg_ecr = strlen(buf);
    *(buf + lg_ecr) = SEPARE_LIGNE;
    *(buf + lg_ecr + 1) = LINE_FEED;
    *(buf + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
    buf = buf + lg_ecr;
    /* Ecriture dans le fichier de sortie */
    iRet = giv_sortie (&buf, GIVfDescFicBloc);
    if (0 == strcmp(givtcInvDenPn,"NON"))
    {
      strcpy(tcIntl, prPart->acDenom);
      if (0 != strlen(prPart->acPrenom))
      {
        strcat(tcIntl, " ");
        strcat(tcIntl, prPart->acPrenom);
      }
    }
    else
    {
  	  /* inversion de l'ordre de la denomination-prénom */
      if (0 != strlen(prPart->acPrenom))
      {
        strcpy(tcIntl, prPart->acPrenom);
        strcat(tcIntl, " ");
        strcat(tcIntl, prPart->acDenom);
      }
      else
      {
        strcpy(tcIntl, prPart->acDenom);
      }
    }
    lg_ecr = giv_ecrit_balise_epj(&buf, tcIntl, "denom");
    strcat (buf, "<rubrique");
    strcat (buf, " ");
    strcat (buf, "an9");
    strcat (buf, "=\"");
    strcat (buf, prPart->acCodan9);
    strcat (buf, "\">");
    if (0 != strlen(prPart->acCodan9))
    {
      /* Afficher le texte de la rubrique (uniquement le premier) */
      /* Appel a la fonction de lecture du libelle de rubrique */
      iRet =  givLectureLibRub(prPart->acCodan9);
      strcat (buf, GIVBuffInter);
    }
    strcat (buf, "</");
    strcat (buf, "rubrique");
    strcat (buf, ">");
    lg_ecr = strlen(buf);
    *(buf + lg_ecr) = SEPARE_LIGNE;
    *(buf + lg_ecr + 1) = LINE_FEED;
    *(buf + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
    /* Ecriture dans le fichier de sortie */
    iRet = (int4)giv_sortie_ISO ( &buf, GIVfDescFicBloc );
    iRet =  givExtractPartEtab(prPart, &buf, giv_PHO);
    /* Ecriture dans le fichier de sortie */
    iRet = (int4)giv_sortie ( &buf, GIVfDescFicBloc );
    strcpy (buf, "</medecin>");
    lg_ecr = strlen(buf);
    *(buf + lg_ecr) = SEPARE_LIGNE;
    *(buf + lg_ecr + 1) = LINE_FEED;
    *(buf + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
    /* Ecriture dans le fichier de sortie */
    iRet = (int4)giv_sortie_ISO ( &buf, GIVfDescFicBloc );
    lg_ecr = 0;
  }
  else if ((giv_orPJDC == prPart->acTypeRefPart[0]) ||
  	        (giv_svPJDC == prPart->acTypeRefPart[0]) ||
  	        (giv_cPJDC == prPart->acTypeRefPart[0]))
  {
    if ( 0 == strlen(buf) )
    {
      strcpy (buf, "<");
    }
    else
    {
      strcat (buf, "<");
    }
    if (giv_orPJDC == prPart->acTypeRefPart[0])
    {
      strcat (buf, "organisation");
    }
    else if (giv_svPJDC == prPart->acTypeRefPart[0])
    {
      strcat (buf, "service");
      if (0 == strlen(prPart->acParentRefPart))
      {
        strcat (buf, " ");
        strcat (buf, "ref");
        strcat (buf, "=");
        strcat (buf, "\"");
        strcat (buf, prPart->acRefPart);
        strcat (buf, "\"");
      }
    }
    else
    {
      strcat (buf, "cabinet");
    }
    strcat (buf, " ");
    strcat (buf, "epj");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, prPart->acEtab);
    strcat (buf, "\">");
    lg_ecr = strlen(buf);
    *(buf + lg_ecr) = SEPARE_LIGNE;
    *(buf + lg_ecr + 1) = LINE_FEED;
    *(buf + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
    buf = buf + lg_ecr;
    /* Ecriture dans le fichier de sortie */
    iRet = giv_sortie (&buf, GIVfDescFicBloc);
    if (0 == strcmp(givtcInvDenPn,"NON"))
    {
      strcpy(tcIntl, prPart->acDenom);
      if (0 != strlen(prPart->acPrenom))
      {
        strcat(tcIntl, " ");
        strcat(tcIntl, prPart->acPrenom);
      }
    }
    else
    {
  	  /* inversion de l'ordre de la denomination-prénom */
      if (0 != strlen(prPart->acPrenom))
      {
        strcpy(tcIntl, prPart->acPrenom);
        strcat(tcIntl, " ");
        strcat(tcIntl, prPart->acDenom);
      }
      else
      {
        strcpy(tcIntl, prPart->acDenom);
      }
    }
    lg_ecr = giv_ecrit_balise_epj(&buf, tcIntl, "denom");
    if ((giv_svPJDC == prPart->acTypeRefPart[0]) && (0 == strlen(prPart->acParentRefPart)))
    {
    	/* calendrier d'un service d'une organisation */
      iRet = givExtractPartEtab(prPart, &buf, giv_CAL);
      /* Ecriture dans le fichier de sortie */
      iRet = (int4)giv_sortie ( &buf, GIVfDescFicBloc );
    }
    iRet = givExtractPartEtab(prPart, &buf, giv_PHO);
    /* Ecriture dans le fichier de sortie */
    iRet = (int4)giv_sortie ( &buf, GIVfDescFicBloc );
    if (giv_orPJDC == prPart->acTypeRefPart[0])
    {
      strcpy (buf, "</organisation>");
    }
    else if (giv_svPJDC == prPart->acTypeRefPart[0])
    {
      strcpy (buf, "</service>");
    }
    else
    {
      strcpy (buf, "</cabinet>");
    }
    lg_ecr = strlen(buf);
    *(buf + lg_ecr) = SEPARE_LIGNE;
    *(buf + lg_ecr + 1) = LINE_FEED;
    *(buf + lg_ecr + 2) = '\0';
    lg_ecr = lg_ecr + 2;
  }
  else
  {
  	GWTTrace (GWT_NIV_GRAVE, ("WARNING : type de référence de partenaire erroné : <%c> epj <%s>\n",prPart->acTypeRefPart[0],prPart->acEtab));
  }
  *buf_pos_in = buf;

  return(lg_ecr);

}
int4 giv_ecrit_navigation (char **buf_pos_in, int4 aiRgParent, int4 aiNbParent, char pcTypeRef, GYBrIapartT *prPart, char *pcCleRef)
{
  int4 iCodRet;
  char *buf_pos;
  int4 lg_write = 0;
  int4 i;

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  if (giv_orPJDC == pcTypeRef)
  {
    lg_write = giv_ecrit_noeud_simple(buf_pos,"navOrganisation");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_noeud_attr(buf_pos,"services",pcCleRef);
    buf_pos = buf_pos + lg_write;

    for(i=aiRgParent; i< (aiRgParent+aiNbParent); i++)
    {
      /* référence de parent inutile : attribut ref de navigation présent */
      givtrPart[i].acParentRefPart[0] = '\0';
      lg_write = giv_ecrit_elements_nav (&buf_pos, &givtrPart[i]);
      buf_pos = buf_pos + lg_write;
    }

    lg_write = giv_ecrit_fin_noeud(&buf_pos,"services");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"navOrganisation");
    buf_pos = buf_pos + lg_write;
  }
  else if (giv_svPJDC == pcTypeRef)
  {
    lg_write = giv_ecrit_noeud_simple(buf_pos,"navService");
    buf_pos = buf_pos + lg_write;
    for(i=aiRgParent; (i< (aiRgParent+aiNbParent) && giv_orPJDC != givtrPart[i].acTypeRefPart[0]) ; i++);
    if ((aiRgParent+aiNbParent) != i)
    {
      lg_write = giv_ecrit_elements_nav (&buf_pos, &givtrPart[i]);
      buf_pos = buf_pos + lg_write;
    }
    lg_write = giv_ecrit_noeud_attr(buf_pos,"equipe",pcCleRef);
    buf_pos = buf_pos + lg_write;
    for(i=aiRgParent; i< (aiRgParent+aiNbParent); i++)
    {
    	if (giv_prPJDC == givtrPart[i].acTypeRefPart[0])
    	{
        lg_write = giv_ecrit_elements_nav (&buf_pos, &givtrPart[i]);
        buf_pos = buf_pos + lg_write;
      }
    }
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"equipe");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"navService");
    buf_pos = buf_pos + lg_write;
  }
  else if (giv_cPJDC == pcTypeRef)
  {
    lg_write = giv_ecrit_noeud_simple(buf_pos,"navCabinet");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_noeud_attr(buf_pos,"equipe",pcCleRef);
    buf_pos = buf_pos + lg_write;
    for(i=aiRgParent; i< (aiRgParent+aiNbParent); i++)
    {
      lg_write = giv_ecrit_elements_nav (&buf_pos, &givtrPart[i]);
      buf_pos = buf_pos + lg_write;
    }
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"equipe");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"navCabinet");
    buf_pos = buf_pos + lg_write;
  }
  else if ((giv_prPJDC == pcTypeRef) && (0 != giviNbParentPart))
  {
    lg_write = giv_ecrit_noeud_simple(buf_pos,"navMedecin");
    buf_pos = buf_pos + lg_write;
    for(i=aiRgParent; (i< (aiRgParent+aiNbParent) && giv_cPJDC != givtrPart[i].acTypeRefPart[0]) ; i++);
    if ((aiRgParent+aiNbParent) != i)
    {
      lg_write = giv_ecrit_elements_nav (&buf_pos, &givtrPart[i]);
      buf_pos = buf_pos + lg_write;
    }
    else
    {
      for(i=aiRgParent; (i< (aiRgParent+aiNbParent) && giv_orPJDC != givtrPart[i].acTypeRefPart[0]) ; i++);
      if ((aiRgParent+aiNbParent) != i)
      {
        lg_write = giv_ecrit_elements_nav (&buf_pos, &givtrPart[i]);
        buf_pos = buf_pos + lg_write;
      }
      for(i=aiRgParent; (i< (aiRgParent+aiNbParent) && giv_svPJDC != givtrPart[i].acTypeRefPart[0]) ; i++);
      if ((aiRgParent+aiNbParent) != i)
      {
        lg_write = giv_ecrit_elements_nav (&buf_pos, &givtrPart[i]);
        buf_pos = buf_pos + lg_write;
      }
    }
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"navMedecin");
    buf_pos = buf_pos + lg_write;
  }
  else
  {
  	GWTTrace (GWT_NIV_GRAVE, ("WARNING : type de référence de partenaire erroné : <%c> epj <%s>\n",prPart->acTypeRefPart[0],prPart->acEtab));
  }

  *buf_pos_in = buf_pos;

  return(iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : GIV_ecrit_denom_parent ()                                      */
/*                                                                            */
/* But       : ecrit denomination de parent de partenaire                     */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, les differents codes                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/


int4 giv_init_denom_parent (char *buf, char *apcEtab, int4 *apiDeb)
{
  int4 lg_ecr;

  strcpy (buf, "<intitulelibpjdc etab=\"");
  strcat (buf, apcEtab);
  strcat (buf, "\">");
  lg_ecr = strlen(buf);
  *(buf + lg_ecr) = SEPARE_LIGNE;
  *(buf + lg_ecr + 1) = LINE_FEED;
  *(buf + lg_ecr + 2) = '\0';
  lg_ecr = lg_ecr + 2;
  *apiDeb = 0;

  return(lg_ecr);

}
int4 GIV_ecrit_denom_parent (char *buf, char *aprDenom, char *aprPrenom, int4 *apiDeb)
{
  int4 iRet;
  int4 lg_ecr = 0;

    if ( 0 == strlen(buf) )
    {
      strcpy (buf, "<");
    }
    else
    {
      strcat (buf, "<");
    }
    strcat (buf, "denomlibpjdc");
    strcat (buf, ">");
    lg_ecr = strlen(buf);
    iRet = giv_sortie_ISO (&buf, GIVfDescFicBloc);
    if (0 == strcmp(givtcInvDenPn,"NON"))
    {
      strcpy(buf_concat, aprDenom);
      if (0 != strlen(aprPrenom))
      {
        strcat(buf_concat, " ");
        strcat(buf_concat, aprPrenom);
      }
    }
    else
    {
  	  /* inversion de l'ordre de la denomination-prénom */
      if (0 != strlen(aprPrenom))
      {
        strcpy(buf_concat, aprPrenom);
        strcat(buf_concat, " ");
        strcat(buf_concat, aprDenom);
      }
      else
      {
        strcpy(buf_concat, aprDenom);
      }
    }
    lg_ecr = giv_ecrit_balise_epj(&buf, buf_concat, "");
    lg_ecr = giv_ecrit_fin_noeud(&buf, "denomlibpjdc");
    buf = buf + lg_ecr;

  return(lg_ecr);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_noeud_inscription ()                                 */
/*                                                                            */
/* But       : ecrit une inscription avec tous les champs                     */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, numero, lo ls grp, seq                              */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                             */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 giv_ecrit_noeud_inscription (char *buf, GYBrDOCUMENT *doc, int4 i)
{
  int4 lg_ecr;
  int4 iCodRet = (int4)GWCCodeOK;
  if (strlen(doc->value.inscription[i].val_num) > 0)
  {

    strcpy (buf, "<");
    strcat (buf, "inscription");
    strcat (buf, " ");
    strcat (buf, "num");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, doc->value.inscription[i].val_num);
    strcat (buf, "\"");
    strcat (buf, " ");
    strcat (buf, "lo");
    strcat (buf, "=");
    strcat (buf, "\"");
    iCodRet = GIVCodeClient (doc->value.inscription[i].val_lols,(int4)strlen(doc->value.inscription[i].val_lols));
    strcat (buf, GIVtcClientDecode);
    strcat (buf, "\"");
    strcat (buf, " ");
    strcat (buf, "ls");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, doc->value.inscription[i].val_lslo);
    strcat (buf, "\"");

    if (strlen(doc->value.inscription[i].val_grp) > 0)
    {
      strcat (buf, " ");
      strcat (buf, "grp");
      strcat (buf, "=");
      strcat (buf, "\"");
      iCodRet = GIVCodeClient (doc->value.inscription[i].val_grp,(int4)strlen(doc->value.inscription[i].val_grp));
      strcat (buf, GIVtcClientDecode);
      strcat (buf, "\"");
    }
    else
    {
      strcat (buf, " ");
      strcat (buf, "grp");
      strcat (buf, "=");
      strcat (buf, "\"");
      strcat (buf, "\"");
    }
    strcat (buf, " ");
    strcat (buf, "seq");
    strcat (buf, "=");
    strcat (buf, "\"");
    strcat (buf, doc->value.inscription[i].val_seq);
    strcat (buf, "\"");
    strcat (buf, ">");
  } /* Fin if ins  */
  else
  {
    strcpy (buf, "<");
    strcat (buf, "inscription");
    strcat (buf, ">");
  }
  lg_ecr = strlen(buf);
  *(buf + lg_ecr) = SEPARE_LIGNE;
  *(buf + lg_ecr + 1) = LINE_FEED;
  *(buf + lg_ecr + 2) = '\0';
  return(lg_ecr + 2);

} /* Fin noeud inscription */

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_noeud_objets_pub ()                                  */
/*                                                                            */
/* But       : ecrit les objets pub avec les champs fournis                   */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, id, type, stype                                     */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 giv_ecrit_noeud_objets_pub (char **buf_pos_in, GYBrDOCUMENT *doc, int4 aindice, char *pcCleTri)
{
  int4         iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_ecr_noyau = 0;
  int4 lg_ecr_module = 0;
  int4 lg_ecr_micro = 0;
  int4 lg_ecr = 0;
  int4 i,k,kk = 0;
  int4 j,jk,jkk = 0;
  char *buf;
  int4 iRang,iObj;

  GWTTrace (GWT_NIV_FONCT,
            (" No_noyau : ... %d\n", nb_noyau));

  GWTTrace (GWT_NIV_FONCT,
            (" No_micro : ... %d\n", nb_micro));

  GWTTrace (GWT_NIV_FONCT,
            (" No_module : ... %d\n", nb_module));
  /* Initialisation pointeur */
  buf = *buf_pos_in;
  iRang = -1;
  for(i=0; i<givrListObj.iNbr; i++)
  {
    k = givrListObj.trEltRangListObj[i];
    kk = givrListObj.trEltListObj[k].iRgLigne;
    iObj = givrListObj.trEltListObj[k].iRgObj;
    if (iRang != givrListObj.trEltListObj[k].iRangTri)
    {
    	iRang = givrListObj.trEltListObj[k].iRangTri;
        if ( i == 0 )
        {
          strcpy (buf, "<");
        }
        else
        {
          strcat (buf, "<");
        }
        strcat (buf, "objet");
        strcat (buf, " ");
        strcat (buf, "id");
        strcat (buf, "=");
        strcat (buf, "\"");
        strcat (buf, (doc+kk)->value.objets_pub.micro[iObj].id);
        strcat (buf, "\"");
        strcat (buf, " type=");
        strcat (buf, "\"");
        strcat (buf, (doc+kk)->value.objets_pub.micro[iObj].type);
        strcat (buf, "\"");
        strcat (buf, " stype=");
        strcat (buf, "\"");
        strcat (buf, (doc+kk)->value.objets_pub.micro[iObj].stype);
        strcat (buf, "\"");
        strcat (buf, " sstype=");
        strcat (buf, "\"");
        strcat (buf, (doc+kk)->value.objets_pub.micro[iObj].sstype);
        strcat (buf, "\"");
        strcat (buf, " dmaj=");
        strcat (buf, "\"");
        strcat (buf, (doc+kk)->value.objets_pub.micro[iObj].tcdatact);
        strcat (buf, "\"");
        strcat (buf, " onumcli=");
        strcat (buf, "\"");
        strcat (buf, (doc+kk)->value.numero_client);
        strcat (buf, "\"");
        for(j=0; j<givrListObj.iNbr; j++)
        {
          jk = givrListObj.trEltRangListObj[j];
          jkk = givrListObj.trEltListObj[jk].iRgLigne;
          if ((iRang == givrListObj.trEltListObj[jk].iRangTri) &&
              (doc->value.intitule.iRgPrinc == jkk))
          {
            strcat (buf, " obpal=");
            strcat (buf, "\"");
            strcat (buf, "true");
            strcat (buf, "\"");
            break;
          }
        }
        strcat (buf, "> </objet>");
        if ( (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].type, "M")) &&
             (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, " T")) )
        {
          /* module PJI trouvé */
          (void)strcpy (pcCleTri, "0");
        }
        lg_ecr = strlen(buf);
        *(buf + lg_ecr) = SEPARE_LIGNE;
        *(buf + lg_ecr + 1) = LINE_FEED;
        *(buf + lg_ecr + 2) = '\0';
        buf = buf + lg_ecr + 2;
    }
  }
  *buf_pos_in = buf;

  return(iCodRet);

} /* Fin ecrire objets pub */
/*-----------------------------Fin de la fonction---------------*/
static int4 giv_ecrit_objet_pub (char **buf_pos_in, GYBrDOCUMENT *doc, int4 iDoc, int4 iObj, char *pcBalise)
{
  int4         iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_ecr = 0;
  char *buf;

  /* Initialisation pointeur */
  buf = *buf_pos_in;
        strcpy (buf, "<");
        strcat (buf, pcBalise);
        strcat (buf, " ");
        strcat (buf, "id");
        strcat (buf, "=");
        strcat (buf, "\"");
        strcat (buf, (doc+iDoc)->value.objets_pub.micro[iObj].id);
        strcat (buf, "\"");
        strcat (buf, " type=");
        strcat (buf, "\"");
        strcat (buf, (doc+iDoc)->value.objets_pub.micro[iObj].type);
        strcat (buf, "\"");
        strcat (buf, " stype=");
        strcat (buf, "\"");
        strcat (buf, (doc+iDoc)->value.objets_pub.micro[iObj].stype);
        strcat (buf, "\"");
        strcat (buf, " sstype=");
        strcat (buf, "\"");
        strcat (buf, (doc+iDoc)->value.objets_pub.micro[iObj].sstype);
        strcat (buf, "\"");
        strcat (buf, " onumcli=");
        strcat (buf, "\"");
        strcat (buf, (doc+iDoc)->value.numero_client);
        strcat (buf, "\">");
        if (! (0 == strcmp("objetpub",pcBalise) &&
             ( ((0 == strcmp ("SC", (doc+iDoc)->value.objets_pub.micro[iObj].stype)) &&
                 ( (0 == strcmp ("PV", (doc+iDoc)->value.objets_pub.micro[iObj].sstype)) ||
                  (0 == strcmp ("SR", (doc+iDoc)->value.objets_pub.micro[iObj].sstype)) )) ||
               ((0 != strlen ((doc+iDoc)->value.objets_pub.micro[iObj].stypcvi)) &&
                  (0 != strcmp ("MO", (doc+iDoc)->value.objets_pub.micro[iObj].stype))) ) ) )
       	{
          strcat (buf, " </");
          strcat (buf, pcBalise);
          strcat (buf, ">");
        }
        lg_ecr = strlen(buf);
        *(buf + lg_ecr) = SEPARE_LIGNE;
        *(buf + lg_ecr + 1) = LINE_FEED;
        *(buf + lg_ecr + 2) = '\0';
        buf = buf + lg_ecr + 2;
  *buf_pos_in = buf;

  return(iCodRet);

} /* Fin ecrire objet pub */


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_noeud_objets_pvi ()                                  */
/*                                                                            */
/* But       : ecrit les liens entre PVI et Video                             */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, id, type, stype                                     */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 giv_ecrit_noeud_objets_pvi (char **buf_pos_in, GYBrDOCUMENT *doc, int4 aindice)
{
  int4         iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_ecr = 0;
  int4 i,k,j,l = 0;
  char *buf;
  int4 iRang,iObj,iLig;
  int4 iVRang,iVObj,iVLig;

  /* Initialisation pointeur */
  buf = *buf_pos_in;
  iRang = -1;
  for(i=0; i<givrListObj.iNbr; i++)
  {
    k = givrListObj.trEltRangListObj[i];
    iLig = givrListObj.trEltListObj[k].iRgLigne;
    iObj = givrListObj.trEltListObj[k].iRgObj;
    if ( (0 != strcmp((doc+iLig)->value.objets_pub.micro[iObj].stype, "SC")) ||
         (0 != strcmp((doc+iLig)->value.objets_pub.micro[iObj].sstype, "PV")) )
    {
    	continue;
    }
    for(j=0; (j<givrListObj.iNbr && iRang != givrListObj.trEltListObj[k].iRangTri) ; j++)
    {
    	if (-1 == givrListObj.trEltListObj[j].iOrdTri)
    	{
    	  givrListObj.trEltListObj[j].iOrdTri = 0;
    	}
    }
    iVRang = -1;
    for(j=0; j<givrListObj.iNbr; j++)
    {
      l = givrListObj.trEltRangListObj[j];
      iVLig = givrListObj.trEltListObj[l].iRgLigne;
      iVObj = givrListObj.trEltListObj[l].iRgObj;
      if ( (0 != strcmp((doc+iVLig)->value.objets_pub.micro[iVObj].stype, "FI")) &&
           (0 != strcmp((doc+iVLig)->value.objets_pub.micro[iVObj].stype, "IN")) &&
           (0 != strcmp((doc+iVLig)->value.objets_pub.micro[iVObj].stype, "VI")) )
      {
        iVRang = -1;
    	  continue;
      }
    GWTTrace (GWT_NIV_FONCT,
            (" Tri objet : ... %d,%d,%d,%d,%d,%s,%s,%s,%s\n",j,l,
            givrListObj.trEltListObj[l].iRangTri,
            givrListObj.trEltListObj[l].iOrdTri,
            iVLig,
            (doc+iVLig)->value.objets_pub.micro[iVObj].type,
            (doc+iVLig)->value.objets_pub.micro[iVObj].stype,
            (doc+iVLig)->value.objets_pub.micro[iVObj].sstype,
            (doc+iVLig)->value.objets_pub.micro[iVObj].id));
      if ((iLig == iVLig) &&
      	 (-1 != givrListObj.trEltListObj[givrListObj.trEltRangListObj[j-givrListObj.trEltListObj[l].iOrdTri]].iOrdTri))
      {
      	/* association validée */
        iVRang = givrListObj.trEltListObj[l].iRangTri;
        givrListObj.trEltListObj[givrListObj.trEltRangListObj[j-givrListObj.trEltListObj[l].iOrdTri]].iOrdTri = -1;
        if (buf == *buf_pos_in)
        {
          lg_ecr = giv_ecrit_noeud_simple(buf, "lienspvivideo");
          buf = buf + lg_ecr;
        }
        lg_ecr = giv_ecrit_noeud_simple(buf, "lienpvivideo");
        buf = buf + lg_ecr;
        strcat (buf, "<");
        strcat (buf, "lienpvi");
        strcat (buf, " ");
        strcat (buf, "id");
        strcat (buf, "=");
        strcat (buf, "\"");
        strcat (buf, (doc+iVLig)->value.objets_pub.micro[iVObj].id);
        strcat (buf, "\"");
        strcat (buf, " type=");
        strcat (buf, "\"");
        strcat (buf, (doc+iVLig)->value.objets_pub.micro[iVObj].type);
        strcat (buf, "\"");
        strcat (buf, " stype=");
        strcat (buf, "\"");
        strcat (buf, (doc+iVLig)->value.objets_pub.micro[iVObj].stype);
        strcat (buf, "\"");
        strcat (buf, " sstype=");
        strcat (buf, "\"");
        strcat (buf, (doc+iVLig)->value.objets_pub.micro[iVObj].sstype);
        strcat (buf, "\"");
        strcat (buf, " dmaj=");
        strcat (buf, "\"");
        strcat (buf, (doc+iVLig)->value.objets_pub.micro[iVObj].tcdatact);
        strcat (buf, "\"");
        strcat (buf, "> </lienpvi>");
        lg_ecr = strlen(buf);
        *(buf + lg_ecr) = SEPARE_LIGNE;
        *(buf + lg_ecr + 1) = LINE_FEED;
        *(buf + lg_ecr + 2) = '\0';
        buf = buf + lg_ecr + 2;
        strcat (buf, "<");
        strcat (buf, "lienvideo");
        strcat (buf, " ");
        strcat (buf, "id");
        strcat (buf, "=");
        strcat (buf, "\"");
        strcat (buf, (doc+iLig)->value.objets_pub.micro[iObj].id);
        strcat (buf, "\"");
        strcat (buf, " type=");
        strcat (buf, "\"");
        strcat (buf, (doc+iLig)->value.objets_pub.micro[iObj].type);
        strcat (buf, "\"");
        strcat (buf, " stype=");
        strcat (buf, "\"");
        strcat (buf, (doc+iLig)->value.objets_pub.micro[iObj].stype);
        strcat (buf, "\"");
        strcat (buf, " sstype=");
        strcat (buf, "\"");
        strcat (buf, (doc+iLig)->value.objets_pub.micro[iObj].sstype);
        strcat (buf, "\"");
        strcat (buf, " dmaj=");
        strcat (buf, "\"");
        strcat (buf, (doc+iLig)->value.objets_pub.micro[iObj].tcdatact);
        strcat (buf, "\"");
        strcat (buf, "> </lienvideo>");
        lg_ecr = strlen(buf);
        *(buf + lg_ecr) = SEPARE_LIGNE;
        *(buf + lg_ecr + 1) = LINE_FEED;
        *(buf + lg_ecr + 2) = '\0';
        buf = buf + lg_ecr + 2;
        lg_ecr = giv_ecrit_fin_noeud(&buf,"lienpvivideo");
        buf = buf + lg_ecr;
      }
      else
      {
         if (iLig == iVLig)
         {
         		/* association déjà traitée */
         	  GWTTrace (GWT_NIV_FONCT,
            (" Tri objet déjà traité : ... %d,%d,%s\n",
              j-givrListObj.trEltListObj[l].iOrdTri,
              givrListObj.trEltListObj[givrListObj.trEltRangListObj[j-givrListObj.trEltListObj[l].iOrdTri]].iOrdTri,
              (doc+givrListObj.trEltListObj[givrListObj.trEltRangListObj[j-givrListObj.trEltListObj[l].iOrdTri]].iRgLigne)->value.objets_pub.micro[givrListObj.trEltListObj[givrListObj.trEltRangListObj[j-givrListObj.trEltListObj[l].iOrdTri]].iRgObj].id));
         }
        iVRang = -1;
      }
    }
   	iRang = givrListObj.trEltListObj[k].iRangTri;
  }
  if (buf != *buf_pos_in)
  {
    lg_ecr = giv_ecrit_fin_noeud(&buf,"lienspvivideo");
    buf = buf + lg_ecr;
 	}

  *buf_pos_in = buf;

  return(iCodRet);

} /* Fin ecrire objets pvi */


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_noeud_objets_url ()                                  */
/*                                                                            */
/* But       : ecrit les libellés d'URL                                       */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, id, type, stype                                     */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 giv_ecrit_noeud_objets_url (char **buf_pos_in, GYBrDOCUMENT *doc, int4 aindice)
{
	int4         iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_ecr = 0;
  int4 x,i,j,k,kk = 0;
  char *buf;
  int4 iRang,iObj;
  int4 iLg = 0;
  int4 iIntRet;
  GYBrIamicT     rIamic;
  GYBrIndIamicT  rIndIamic;
  GYBrIapartT rIapart;

    /* Initialisation pointeur */
  buf = *buf_pos_in;
  iRang = -1;
  buf_concat[0] = '\0';
  for(i=0; i<givrListObj.iNbr; i++)
  {
    iIntRet = (int4)GIXCodeKO;
    buf_concat[0] = '\0';
    k = givrListObj.trEltRangListObj[i];
    kk = givrListObj.trEltListObj[k].iRgLigne;
    iObj = givrListObj.trEltListObj[k].iRgObj;
    if (iRang != givrListObj.trEltListObj[k].iRangTri)
    {
    	iRang = givrListObj.trEltListObj[k].iRangTri;
        if ( ((doc+kk)->value.objets_pub.micro[iObj].type[0] == 'X') &&
             ( (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, " U")) ||
               ( (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,  "SC")) &&
                 (0 != strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype, "PV")) ) ||
               (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "SO")) ||
               (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "LC")) ||
               (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "LD")) ||
               (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "LP")) ||
               (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "LR")) ||
               (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "LE")) ||
               (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "LF")) ||
               (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "LT")) ||
               (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "LB")) ) )
        {
          (void)strcpy(rIamic.acNumobj,(doc+kk)->value.objets_pub.micro[iObj].id);
          (void)strcpy(rIamic.acTypobj,"M");
          /* utilisation du sous-type interne */
          (void)strcpy(rIamic.acTpdsob,(doc+kk)->value.objets_pub.micro[iObj].stypint);
  GWTTrace (GWT_NIV_FONCT,
            (" type_micro : ... %s,%s,%s\n", (doc+kk)->value.objets_pub.micro[iObj].type,(doc+kk)->value.objets_pub.micro[iObj].stype,(doc+kk)->value.objets_pub.micro[iObj].stypint));
          if ((0 != strlen((doc+kk)->value.objets_pub.libUrlGCpt)) &&
                (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,  " U")) &&
                 ((0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype, "PV")) ||
                 (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype, "SR"))))
          {
            (void)strcpy(buf_concat, (doc+kk)->value.objets_pub.libUrlGCpt);
            iIntRet = (int4)GIXCodeOK;
          }
          else  if ( (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,  "LP") &&
                 0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype, "CR")) ||
                   (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,  "LR") &&
                 0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype, "LG")) ||
                   (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,  "LC") &&
                 0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype, "CH")) )
          {
              /* remplacement par l'url EPJ */
            if (0 != strlen((doc+kk)->value.objets_pub.micro[iObj].valeur))
            {
              (void)strcpy(buf_concat,(doc+kk)->value.objets_pub.micro[iObj].valeur);
              iIntRet = (int4)GIXCodeOK;
            }
          }
          else
          {
            iIntRet = givLectureTypeURL(&rIamic, &rIndIamic);
          }
          if ((int4)GIXCodeOK == iIntRet)
          {
            if ( (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype,  "SC")) &&
                 (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype, "PB")) )
            {
              /* pas de remplacement de l'url EPJ par l'url site présence */
              /* (void)strcpy((doc+kk)->value.objets_pub.libUrlSite,buf_concat); */
            }
            if ( *buf_pos_in == buf )
            {
              strcpy (buf, "<");
            }
            else
            {
              strcat (buf, "<");
            }
            strcat (buf, "lienurl");
            strcat (buf, " ");
            strcat (buf, "ct");
            strcat (buf, "=");
            strcat (buf, "\"");
            strcat (buf, buf_concat);
            strcat (buf, "\"");
            strcat (buf, " typ_lienurl=");
            strcat (buf, "\"");
            /* HAL, OA12 : on prend le sous-type dans l'inscription car il n'est pas toujours connu dans PemicURL */
            if ( (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype,  "SR")) &&
                 (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, " U")) )
            {
              strcat (buf, &(doc+kk)->value.objets_pub.micro[iObj].stype[1]);
            }
            else if ( (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype,  "SR")) &&
                 ((0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "SC")) ||
                  (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "SO"))) )
            {
              strcat (buf, (doc+kk)->value.objets_pub.micro[iObj].stype);
            }
            strcat (buf, (doc+kk)->value.objets_pub.micro[iObj].sstype);
            strcat (buf, "\"");
            strcat (buf, " id=");
            strcat (buf, "\"");
            strcat (buf, (doc+kk)->value.objets_pub.micro[iObj].id);
            strcat (buf, "\"");
            strcat (buf, "> </lienurl>");
            lg_ecr = strlen(buf);
            *(buf + lg_ecr) = SEPARE_LIGNE;
            *(buf + lg_ecr + 1) = LINE_FEED;
            *(buf + lg_ecr + 2) = '\0';
            buf_concat[0] = '\0';
            buf = buf + lg_ecr + 2;
          }
        }
    }
  }

  for(i=0; i< aindice; i++)
  {
    for(j=0; j< (doc+i)->value.a_classer.iNbPart; j++)
    {
      iLg = strlen ((doc+i)->value.a_classer.trpart[j].rpart) -4;
  	  (void)strcpy (rIapart.acOriPart,&(doc+i)->value.a_classer.trpart[j].rpart[iLg]);
      memcpy (rIapart.acRefPart, (doc+i)->value.a_classer.trpart[j].rpart, iLg);
      rIapart.acRefPart[iLg] = '\0';
      if ((0 == strcmp(rIapart.acOriPart,giv_PJDC))
   	    	 && (GIXCodeOK == (doc+i)->value.a_classer.trpart[j].iForPJDC)
   	    	 && (0 != strlen((doc+i)->value.a_classer.etab)))
 	    {
        /* ajout pour forçage LP-CR pour PJDC */
        strcat (buf, "<lienurl");
        strcat (buf, " ");
        strcat (buf, "ct");
        strcat (buf, "=");
        strcat (buf, "\"");
        iLg = strlen(rIapart.acRefPart);
        for ( x = 0 ;( x < iLg && 0 != isdigit(rIapart.acRefPart[x]) ); x++);
        if (x < iLg)
        {
          rIapart.acRefPart[x] = '\0';
        }
         strcat (buf, rIapart.acRefPart);
        strcat (buf, "\"");
        strcat (buf, " typ_lienurl=");
        strcat (buf, "\"");
        strcat (buf, giv_ssPJDC);
        strcat (buf, "\"");
        strcat (buf, " id=");
        strcat (buf, "\"");
        strcat (buf, "0002");
        strcat (buf, (doc+i)->value.a_classer.etab);
        strcat (buf, "0001");
        strcat (buf, "\"");
        strcat (buf, "> </lienurl>");
        lg_ecr = strlen(buf);
        *(buf + lg_ecr) = SEPARE_LIGNE;
        *(buf + lg_ecr + 1) = LINE_FEED;
        *(buf + lg_ecr + 2) = '\0';
      }
    }
  }



  *buf_pos_in = buf;

  return(iCodRet);


} /* Fin ecrire objets url */


/* giv_ecrit_tabIeBloc : inserer le resultat dans la table de blocs ou  supprimer une ligne de la table ou enfin mettre à jour plusieurs lignes
   --------------------------------------------------------------------------------------------------------------------------------*/
static int4 giv_ecrit_tabIeBloc (GYBrDOCUMENT *doc)
{
  EXEC SQL begin declare section;
  GYBrBlocT BlocLocal;
  int2           indicatrice_acNogrou;
  int2           indicatrice_acNoselo;
  int2           indicatrice_acNosels;
  int2           indicatrice_acEtab;
  char            tcEtab[GYBIeinscLgEtab2]; /* etab */
  char tcRequete[800];
  char  *pcVersion = NULL;
  EXEC SQL end declare section ;
  static int4 iDejaPrepare = (int4)GWCCodeKO;

  int4 iCodRet     = (int4)GWCCodeOK;  /* Code retour de la fonction */
  int4 iIntRet       = (int4)GWCCodeOK;  /* Code retour des appels internes */
  GYBrParam_erreurT     vErreurSQL;             /* Traitement des erreurs SQL */
  time_t date;
  date = time(NULL);
  (void)strftime(BlocLocal.acDatemodbloc, sizeof(BlocLocal.acDatemodbloc), "%Y%m%d", localtime(&date));
  strcpy( BlocLocal.acDepart,GIXcDepartement);

  /* version du bloc */
  pcVersion = strchr(pcVersionInsFour[0], (char)'.');
  pcVersion++;

  if (0 == strlen(doc->value.a_classer.etab_dc))
  {
    indicatrice_acEtab = (int2)-1;
  }
  else
  {
    indicatrice_acEtab = (int2)0;
    strcpy(tcEtab,doc->value.a_classer.etab_dc);
  }

  if (0 != strcmp(GIVtcGeneIeBloc,"OUI"))
  {
    /* Sortie de la fonction */
    return (iCodRet);
  }

  GWTTrace (GWT_NIV_FONCT, ("TABLE BLOCS DE PARUTIONS ...\n"));
  strcpy( BlocLocal.acNumnat,doc->value.inscription[0].val_num);
  strcpy( BlocLocal.acNumlo,doc->value.inscription[0].val_lo);
  strcpy( BlocLocal.acNumls,doc->value.inscription[0].val_ls);
  strcpy( BlocLocal.acNogrou,doc->value.inscription[0].val_grp);
  strcpy( BlocLocal.acNoselo,doc->value.inscription[0].val_seqLO);
  strcpy( BlocLocal.acNosels,doc->value.inscription[0].val_seqLS);
  strcpy( BlocLocal.acBlocid,nom_bloc_ref);

  /* dump des données en cours de traitement */
  /* pour investigation en cas de plantage dur */
  GWTTrace(GWT_NIV_FONCT,("Depart=%s,Numnat=%s,Numlo=%s,Numls=%s,Blocid=%s,Nogrou=%s,Noselo=%s,Nosels=%s,Datemodbloc=%s\n",
                          BlocLocal.acDepart,
                          BlocLocal.acNumnat,
                          BlocLocal.acNumlo,
                          BlocLocal.acNumls,
                          BlocLocal.acBlocid,
                          BlocLocal.acNogrou,
                          BlocLocal.acNoselo,
                          BlocLocal.acNosels,
                          BlocLocal.acDatemodbloc));

    if ( (int4)GWCCodeOK != iDejaPrepare )
  {
    (void)sprintf ( tcRequete, GIV_CRE_IS, GIXcNomDest );

    EXEC SQL
      prepare rqtCre from :tcRequete;
      (void)sprintf ( tcRequete, GIV_CRE_IG, GIXcNomDest );

      EXEC SQL
        prepare rqtCreG from :tcRequete;
  	iDejaPrepare = (int4)GWCCodeOK;
  }

  if (0 == strlen(BlocLocal.acNogrou))
  {
    indicatrice_acNogrou = (int2)-1;
    indicatrice_acNoselo = (int2)-1;
    indicatrice_acNosels = (int2)-1;

      (void)strcpy(vErreurSQL.acOrdre_sql,"Insert IS GYTtabIeBloc");

      EXEC SQL
        execute rqtCre
        using
        :BlocLocal.acDepart,
        :BlocLocal.acNumnat,
        :BlocLocal.acNumlo,
        :BlocLocal.acNumls,
        :BlocLocal.acBlocid,
        :tcEtab:indicatrice_acEtab,
        :BlocLocal.acNogrou:indicatrice_acNogrou,
        :BlocLocal.acNoselo:indicatrice_acNoselo,
        :BlocLocal.acNosels:indicatrice_acNosels,
        :BlocLocal.acDatemodbloc,
        :pcVersion;

      iIntRet = GIVBlocErreur (&vErreurSQL);

      /* Analyse du code resultat SQL */
      if ((int4)GWCCodeOK != iIntRet)
      {
        GWTTrace (GWT_NIV_BIZAR,
                  ("Erreur : [COD=%d TXT=%s]\n",
                   iIntRet,
                   vErreurSQL.acOrdre_sql));
      }
  }

  else
  {
    indicatrice_acNogrou = (int2)0;
    indicatrice_acNoselo = (int2)0;
    indicatrice_acNosels = (int2)0;

      (void)strcpy(vErreurSQL.acOrdre_sql,"Insert IM GYTtabIeBloc");
      EXEC SQL
        execute rqtCreG
        using
        :BlocLocal.acDepart,
        :BlocLocal.acNumnat,
        :BlocLocal.acNumlo,
        :BlocLocal.acNumls,
        :BlocLocal.acBlocid,
        :tcEtab:indicatrice_acEtab,
        :BlocLocal.acNogrou:indicatrice_acNogrou,
        :BlocLocal.acNoselo:indicatrice_acNoselo,
        :BlocLocal.acNosels:indicatrice_acNosels,
        :BlocLocal.acDatemodbloc,
        :pcVersion;
      iIntRet = GIVBlocErreur (&vErreurSQL);

      /* Analyse du code resultat SQL */
      if ((int4)GWCCodeOK != iIntRet)
      {
        GWTTrace (GWT_NIV_BIZAR,
                  ("Erreur : [COD=%d TXT=%s]\n",
                   iIntRet,
                   vErreurSQL.acOrdre_sql));
      }
  }


  return (iCodRet);
}



/*-----------------------------Fin de la fonction---------------*/


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givInitConfGXX                                                 */
/*                                                                            */
/* But       : lesture de la configuration externe CG                         */
/*                                                                            */
/* Entree(s) : néant                                                          */
/*                                                                            */
/* Sortie(s) : néant                                                          */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static void givInitConfGXX()
{
  int4 iIntRet = (int4)GWCCodeOK ;
  char nom_test[50+1];                        /* Nom du test                */
  char          conf[50];
  int4 i;

    /* constitution du nom du fichier Bloc */
    (void) sprintf(conf, "%s_%s_%s","GIV_PATH_BLOC",GIXcNomDest,GIXcDepartement);
    iIntRet = GWTLireConf(conf,givcCheminBloc);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givcCheminBloc, "/DATA/DEPT/CD2G");
      GWTTrace(GWT_NIV_BIZAR,
               ("Pas de Path des Blocs dans la conf. Valeur par defaut <%s> prise \n", givcCheminBloc));
    }
    (void) sprintf(conf, "%s_%s_%s","GIV_REPERTOIRE",GIXcNomDest,GIXcDepartement);
    iIntRet = GWTLireConf(conf,givcRepertoire);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givcRepertoire, GIXcDepartement);
      GWTTrace(GWT_NIV_BIZAR,
               ("Pas de répertoire de Blocs dans la conf. Valeur par defaut <%s> prise \n", GIXcDepartement));
    }
    /* Lecture variable d'environnement : nom du test */
    memset(nom_test, 0, sizeof(nom_test));
    iIntRet = GWTLireConf("GIV_NOM_TEST_XML", nom_test);

    /* Lecture variable d'environnement : caractère remplacement 'espace' du sous-type */
    memset(remplace_espace, 0, sizeof(remplace_espace));
    remplace_espace[0] = ' ';

    iIntRet = GWTLireConf("GIV_REMPLACE_ESPACE_SOUS_TYPE", remplace_espace);

    /* taille limite du fichier de sortie */
    if  ((0 == strcmp(GIXcValUrg, GWZUrgent)) && (0 != strcmp(givRecreerCD,GIXcNomIntf)))
    {
      (void) sprintf(conf, "%s_%s","GIV_TAILLE_FICHIER_URJ",GIXcNomDest);
    }
    else
    {
      (void) sprintf(conf, "%s_%s","GIV_TAILLE_FICHIER_XML",GIXcNomDest);
    }
    if ( 0 != GWTLireConfNum(conf,&giviNbBlocs))
    {
      giviNbBlocs = -1;
    }
    GWTTrace(GWT_NIV_FONCT,("Taille fichier XML en blocs : %8d\n", giviNbBlocs));
    /* Lecture variable d'environnement : chemin SGIPRO */
    memset(givtcRepSgiPro, 0, sizeof(givtcRepSgiPro));
    /* constitution du nom du fichier Bloc */
    (void) sprintf(conf, "%s","GIV_PATHCONTENU");
    iIntRet = GWTLireConf(conf,givtcRepSgiPro);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcRepSgiPro, "/fast/SGIPRO");
      GWTTrace(GWT_NIV_BIZAR,
               ("Pas de Path des fichiers SGIPRO dans la conf. Valeur par defaut <%s> prise \n", givtcRepSgiPro));
    }
    /* Lecture variable d'environnement : chemin MPG */
    memset(givtcRepMpg, 0, sizeof(givtcRepMpg));
    /* constitution du nom du fichier MPG */
    (void) sprintf(conf, "%s","GIV_PATH_MPG");
    iIntRet = GWTLireConf(conf,givtcRepMpg);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcRepMpg, "/DATA/DEPT/CD2G/888");
      GWTTrace(GWT_NIV_BIZAR,
               ("Pas de Path des fichiers SGIPRO dans la conf. Valeur par defaut <%s> prise \n", givtcRepMpg));
    }

    iIntRet = GWTLireConf("GIV_VERS_DOC_EPJ", givtcVersDoc);
    if ( GWTok != iIntRet )
    {
      givtcVersDoc[0] = '\0';
    }

    /* Lecture variable d'environnement : paru loc arr intallation */
    memset(givtcLocArrInst, 0, sizeof(givtcLocArrInst));
    (void) sprintf(conf, "%s_%s","GIV_PARU_ARR_INST",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcLocArrInst);
    if ( GWTok != iIntRet )
    {
      GWTTrace(GWT_NIV_BIZAR,
               ("Pas de paru loc arr intallation dans la conf \n"));
    }
    else
    {
        for(i=0; i<3; i++)
        {
          /* parution sur arrondissement d'installation */
          strcpy(buf_concat, givtrRefArr[i].dep);
          strcat(buf_concat, givtrRefArr[i].loc);
          if (NULL != strstr(givtcLocArrInst, buf_concat))
          {
            givtrRefArr[i].iParuInst = (int4)GIXCodeOK;
          }
        }
    }

    /* Lecture variable d'environnement : regions CECI */
    memset(givtcRegCECI, 0, sizeof(givtcRegCECI));
    (void) sprintf(conf, "%s_%s","GIV_REGION_CECI",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcRegCECI);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcRegCECI, "NON");
    }
    GWTTrace(GWT_NIV_FONCT,
               ("Regions CECI %s \n", givtcRegCECI));

    /* Lecture variable d'environnement : liste objets contenu */
    memset(givtcObjCont, 0, sizeof(givtcObjCont));
    /* constitution du nom du fichier Bloc */
    (void) sprintf(conf, "%s_%s","GIV_OBJETS_CONTENU",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcObjCont);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcObjCont, "");
      GWTTrace(GWT_NIV_BIZAR,
               ("Pas d'objet contenu dans la conf \n"));
    }

    memset(givtcPrioCont, 0, sizeof(givtcPrioCont));
    /* constitution du nom du fichier Bloc */
    (void) sprintf(conf, "%s_%s","GIV_PRIORITE_CONTENU",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcPrioCont);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcPrioCont, "");
      GWTTrace(GWT_NIV_BIZAR,
               ("Pas de priorité des contenus dans la conf \n"));
    }

    memset(givtcExceptCont, 0, sizeof(givtcExceptCont));
    (void) sprintf(conf, "%s_%s","GIV_CRC_EXCEPT",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcExceptCont);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcExceptCont, "");
      GWTTrace(GWT_NIV_BIZAR,
               ("Pas d'exception sur les contenus dans la conf \n"));
    }

  /* Lecture variable d'environnement : liste partenaires à éliminer */
    memset(givtcFourPart, 0, sizeof(givtcFourPart));
    /* constitution du nom de paramètre */
    (void) sprintf(conf, "%s_%s","GIV_NON_PARU_PART",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcFourPart);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcFourPart, "");
      GWTTrace(GWT_NIV_BIZAR,
               ("Pas de partenaire à éliminer \n"));
    }
    /* Lecture variable d'environnement : rapprochement ED  */
    memset(givtcRapED, 0, sizeof(givtcRapED));
    /* constitution du nom du fichier Bloc */
    (void) sprintf(conf, "%s_%s","GIV_RAP_EDITO",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcRapED);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcRapED, "NON");
      GWTTrace(GWT_NIV_BIZAR,
               ("Pas de rapprochement Etab/ED dans la conf. Valeur par defaut <%s> prise \n", givtcRapED));
    }
    /* Lecture variable d'environnement : contenu à traiter */
    memset(givtcContenu, 0, sizeof(givtcContenu));
    /* constitution du nom du fichier Bloc */
    (void) sprintf(conf, "%s_%s","GIV_CONTENU",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcContenu);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcObjCont, "");
      (void)strcpy(givtcContenu, "NON");
      (void)strcpy(givtcRapED, "NON");
      GWTTrace(GWT_NIV_BIZAR,
               ("Pas de contenu dans la conf \n"));
    }
    else
    {
      if (0 == strcmp("NON",givtcContenu))
      {
        (void)strcpy(givtcObjCont, "");
        (void)strcpy(givtcRapED, "NON");
        GWTTrace(GWT_NIV_BIZAR,
                 ("Pas de contenu dans la conf \n"));
      }
    }
    /* Lecture variable d'environnement : liste produits 'Annonces Mesurées' */
    memset(givtcAnMes, 0, sizeof(givtcAnMes));
    /* constitution du nom du paramètre */
    (void) sprintf(conf, "%s_%s","GIV_AN_MES",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcAnMes);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcAnMes, "");
      GWTTrace(GWT_NIV_BIZAR,
               ("Pas de produit 'Annonces Mesurées' dans la conf \n"));
    }
    /* Lecture variable d'environnement : suppression qualite dans cpl denom */
    memset(givtcSupCplDen, 0, sizeof(givtcSupCplDen));
    /* constitution du nom du paramètre */
    (void) sprintf(conf, "%s_%s","GIV_SUP_QUAL_CPL",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcSupCplDen);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcSupCplDen, "NON");
    }
    GWTTrace(GWT_NIV_FONCT,
             ("Suppression qual dans cpldenom <%s> \n", givtcSupCplDen));

     /* Lecture variable d'environnement : inversion de la denomination exacte */
    memset(givtcInvDenPn, 0, sizeof(givtcInvDenPn));
    /* constitution du nom du paramètre */
    (void) sprintf(conf, "%s_%s","INV_DNOM_PRE",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcInvDenPn);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcInvDenPn, "NON");
    }
    GWTTrace(GWT_NIV_FONCT,
             ("Inversion de la denomination exacte <%s> \n", givtcInvDenPn));

    /* paramêtre d'accès à GYTtabIeBlocCRC */
    (void) sprintf(conf, "%s_%s","GIV_GENE_IEBLOCEPJ_CRC",GIXcNomDest);

    iIntRet = GWTLireConf(conf, givtcGeneIeBlocCRC);
    if (( GWTok != iIntRet ) || ((0 == strcmp(givRecreerCD,GIXcNomIntf)) && (0 == strcmp(GIXcValUrg, GWZUrgent))))
    {
      (void)strcpy(givtcGeneIeBlocCRC, "NON");
    }
    GWTTrace(GWT_NIV_FONCT,
             ("Accès GYTtabIeBlocCRC <%s> \n", givtcGeneIeBlocCRC));
      /* paramêtre d'affichage AffCRC */
    (void) sprintf(conf, "%s_%s","GIV_GENE_AFF_CRC",GIXcNomDest);

    iIntRet = GWTLireConf(conf, givtcGeneAffCRC);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcGeneAffCRC, "NON");
    }
    GWTTrace(GWT_NIV_FONCT,
             ("AFFCRC <%s> \n", givtcGeneAffCRC));
  /* Lecture variable d'environnement : contenu partenaire au niveau inscription */
    (void) sprintf(conf, "%s_%s","GIV_CONTENU_PART_INSC",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcPartInsc);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcPartInsc, "NON");
    }
    GWTTrace(GWT_NIV_FONCT,
             ("contenu partenaire au niveau inscription <%s> \n", givtcPartInsc));

    /* Lecture variable d'environnement : parution pour inscription par epj */
    (void) sprintf(conf, "%s_%s","GIV_PARUTION_INSC_EPJ",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcParuInscEpj);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcParuInscEpj, "NON");
    }

    /* Lecture variable d'environnement : format balise text */
    (void) sprintf(conf, "%s_%s","GIV_CONTENU_TEXT_EPJ",GIXcNomDest);
    iIntRet = GWTLireConf(conf,givtcContText);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(givtcContText, "NON");
    }

    /* pas de fichier ouvert */
    GIVfDescFicMCD = NULL;
    /* pas de bloc de référence */
    memset(nom_bloc_ref, '0', sizeof(nom_bloc));
    giviNumFic = giviNumFicInit;
    /* préparation suppressions dans IeBloc */
    iIntRet=givPreparerRequetesIeBloc();

  return;
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_partie_1 ()                                          */
/*                                                                            */
/* But       : ecrit la partie une du bloc de parution simple ou groupe       */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, valeur_id_parution                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	(Jui/20/2006 - mb) : création de plusieurs fichiers de sortie */
/*----------------------------------------------------------------------------*/

static int4 giv_ecrit_partie_1 (char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice)

{
  int4 lg_write;
  char *buf_pos;
  int4	iCodRet = GWCCodeOK;		/* Code retour de la fonction */
  char type_bloc[2];                          /* Type de bloc : 'o' ou 'p'  */
  int4 lg_numlo;
  int4 lg_IG,i;
  int4 iIntRet = (int4)GWCCodeOK ;
  char chaine_id[7+1];			/* Numero qui s'incremente    */
  char ch[15+1];				/* Date du jour               */
  struct tm * pdh;
  time_t intps;
  int4 nbc;
  char    cNomFichier[128] = "";           /* Pathname des fichiers utilises */
  char  *pcVersion = NULL;

  /* Calcul du numero d'identifiant parution_id */
  num_id = num_id + 1;
  sprintf(chaine_id, "%07d", num_id);

  if (obtention_iden == 0)
  {
  	givInitConfGXX();
    /* Pour ne plus recaluler au prochain passage */
    obtention_iden = 1;
  }

  /* init nom de bloc */
  if (0 == strlen (doc->value.inscription[0].val_grp))
  {
    strcpy(nom_bloc,doc->value.a_classer.etab);
    strcpy(nom_bloc_ref, nom_bloc);
    GWTTrace (GWT_NIV_FONCT,("nom_bloc = %s\n",nom_bloc));
  }
  else
  {
    strcpy(nom_bloc,doc->value.a_classer.etab);
    strcpy(nom_bloc_ref, nom_bloc);
    if (0 != iMaxBlocEcritAvant)
    {
      sprintf(chaine_id, "%04d",iMaxBlocEcritAvant);
      strcat(nom_bloc,chaine_id);
    }
    GWTTrace (GWT_NIV_FONCT,("nom_bloc = %s\n",nom_bloc));
  }

  /* init numéro de bloc */
  num_bloc = 1;
  sprintf(chaine_id, "%04d", num_bloc);
  if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
  {
    sprintf(chaine_id, "%04d", 2);
  }
  else
  {
    sprintf(chaine_id, "%04d", 1);
  }

  /* Generation de la chaine pour "pjparutionid" */
  strcpy(doc->parution_id, nom_bloc);
  strcpy(doc->parution_id_ref, nom_bloc_ref);
  for (i=1 ; i<indice ; i++ )
  {
    strcpy((doc+i)->parution_id, (doc)->parution_id);
  }
  buf_pos = *buf_pos_in;

  lg_write = giv_ecrit_noeud_simple(buf_pos, "OPERATION");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, "addition", "TYPE_OPERATION");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->parution_id, "NAME");
  buf_pos = buf_pos + lg_write;

  pcVersion = strchr(pcVersionInsFour[0], (char)'.');
  pcVersion++;

  if (0 == strlen(doc->value.numero_client))
  {
    (void) sprintf(&cNomFichier[0], "%s/%c%c/%c%c/%s_v%s.xml", givcCheminBloc, doc->value.inscription[0].moyen_de_com.numero[0], doc->value.inscription[0].moyen_de_com.numero[1], doc->value.inscription[0].moyen_de_com.numero[2], doc->value.inscription[0].moyen_de_com.numero[3], doc->parution_id, pcVersion);
  }
  else
  {
    (void) sprintf(&cNomFichier[0], "%s/%c%c/%c%c/%s_v%s.xml", givcCheminBloc, doc->value.numero_client[0], doc->value.numero_client[1], doc->value.numero_client[2], doc->value.numero_client[3], doc->parution_id, pcVersion);
  }

  lg_write = giv_ecrit_noeud_simple(buf_pos, "CONTENT");
  buf_pos = buf_pos + lg_write;

  *buf_pos_in = buf_pos;

  return(iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_partie_2_1 ()                                        */
/*                                                                            */
/* But       : ecrit la partie deux du bloc de parution simple ou groupe      */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 giv_ecrit_partie_2_1 (char **buf_pos_in, GYBrDOCUMENT *docEPJ, GYBrDOCUMENT *doc, int4 indice)
{
  int4 lg_write;
  char *buf_pos, *buf_pos_ref, *buf_pos_cur;
  int4  iRet,iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_tmp, iDebut, iLg;
  char  *pcVersion = NULL;
  char transforme_stype[2+1];
  char ref_pub[1+2+2+1];
  char tcRefext[17+1];
  char tcNbimag[100];
  char tcImagCat[2];
  char tcMenu[2];
  int4 i,j,x,y,z,zz;
  int4	iLgChaineApvr;
  char *pcDeb;
  char *pcFin;
  int4 pipe;
  int4 iQualite;
  char tcPrecision[2+1];
  char tcStat[100+1];
  int4 iRang;
  GYBrIeinscT rInscRef;
  GYBrIamicT     rIamic;
  GYBrIapartT rIapart;
  GYBstrIeinscNumcliT tcNumcli;
  char tcProduit[GYBIamicLgTypobj+(2*GYBIamicLgTpdsob)+1];
  char tcEvt[2], tcPrg[2];
  char *pt_fin_lst;
  char *pt_debut;
  char *pt_fin;
  int4 iPrenom,iCpl,iMots,iMarq,iQual,iInMq = 0;
  char cInfo,cAvis;
  char tcElmt[29+1];                         /* partenaire*/
  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  /* Calcul du numero d'identifiant parution_id */
  for(i=0; i<indice; i++)
  {
    strcpy((doc+i)->value.numero_bloc_parution, doc->parution_id);
    strcpy((doc+i)->value.numero_bloc_parution_ref, doc->parution_id_ref);
  }


  /* Ecriture dans le fichier de sortie */
  iCodRet = (int4)giv_fichier_sortie ( &buf_pos, &GIVfDescFicMCD );

  GIVfDescFicBloc = GIVfDescFicMCD;

  lg_tmp=0;
  strcpy(buf_pos, "<blocepj>");

  lg_tmp = strlen(buf_pos);
  *(buf_pos+lg_tmp) = SEPARE_LIGNE;
  *(buf_pos + (lg_tmp+1) )= LINE_FEED;
  *(buf_pos + (lg_tmp+2) )= '\0';
  buf_pos = (buf_pos + lg_tmp +2);

  lg_write =giv_ecrit_balise(buf_pos, doc->value.numero_bloc_parution, "blocepjid");
  buf_pos = buf_pos + lg_write;

  pcVersion = strchr(pcVersionInsFour[0], (char)'.');
  pcVersion++;

  lg_write =giv_ecrit_balise(buf_pos, pcVersion, "version");
  buf_pos = buf_pos + lg_write;

  lg_write =giv_ecrit_balise(buf_pos, cDate, "datmodblocepj");
  buf_pos = buf_pos + lg_write;

  lg_write =giv_ecrit_balise(buf_pos, givtcVersDoc, "vdoc");
  buf_pos = buf_pos + lg_write;

  for(i=0; i<(indice); i++)
  {
    if ( giv_cLEUR == (doc+i)->cNature)
    {
    	/* indication de bloc leurre */
      lg_write = giv_ecrit_balise(buf_pos, "1", "leurre");
      buf_pos = buf_pos + lg_write;
  	  break;
    }
  }

  lg_write = giv_ecrit_noeud_simple(buf_pos, "epj");
  buf_pos = buf_pos + lg_write;

  /* Ecriture dans le fichier de sortie */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  lg_write =giv_ecrit_balise_epj(&buf_pos, docEPJ->value.intitule.denomination, "denom");

  lg_write =giv_ecrit_balise_epj(&buf_pos, docEPJ->value.intitule.complement_denomination, "cpldenom");

  lg_write =giv_ecrit_balise(buf_pos, docEPJ->value.a_classer.etab, "etab");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.instal,"codloc");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.numero_voie,"numvoie");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.lib_complt_num_voie,"libcplnumvoie");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.code_voie,"codvoie");
  buf_pos = buf_pos + lg_write;

  /* Ecriture dans le fichier de sortie */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  if (0 != strlen(docEPJ->value.inscription[0].adresse.lib_code_voie))
  {
    lg_write = giv_ecrit_balise_epj(&buf_pos, docEPJ->value.inscription[0].adresse.lib_code_voie,"libvoie");
  }
  else
  {
    lg_write = giv_ecrit_balise_epj(&buf_pos, docEPJ->value.inscription[0].adresse.libel_voie,"libvoie");
  }

  lg_write = giv_ecrit_balise_epj(&buf_pos, docEPJ->value.inscription[0].adresse.adrnr,"adrnr");

  lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.libinstal,"libloc");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.geoloc.longitude,"long");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.geoloc.latitude,"lat");
  buf_pos = buf_pos + lg_write;

  iQualite = atoi(docEPJ->value.inscription[0].adresse.geoloc.precision);
  switch(iQualite)
  {
    case 97:
    case 99:
      break;
    case 96:
    case 98:
      lg_write = giv_ecrit_balise(buf_pos, "04", "precision");
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_balise(buf_pos, "1", "srcprecision");
      buf_pos = buf_pos + lg_write;
      break;
    default:
      iQualite = iQualite % 4;
      (void) sprintf(&tcPrecision[0], "%02d", iQualite);
      lg_write = giv_ecrit_balise(buf_pos, tcPrecision, "precision");
      buf_pos = buf_pos + lg_write;
      iQualite = atoi(docEPJ->value.inscription[0].adresse.geoloc.precision);
      iQualite = iQualite / 4;
      (void) sprintf(&tcPrecision[0], "%d", iQualite);
      lg_write = giv_ecrit_balise(buf_pos, tcPrecision, "srcprecision");
      buf_pos = buf_pos + lg_write;
      break;
  }

  /* Ecriture dans le fichier de sortie */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  /* lecture et criture chapms Siret */
  iDebut = 1;
  iCodRet = givEcritureEtab(doc, &buf_pos, &iDebut);

  iDebut = 1;
  giviRefPJDC = -1;
  /* lecture et écriture des denominations secondaires */
  iCodRet = givEcritureDenomEtab(doc, &buf_pos, &iDebut);

  /* Ecriture dans le fichier de sortie */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  /* analyse de partenaire PJDC */
  iDebut = 1;
  for(j=0; j< doc->value.a_classer.iNbPart; j++)
  {
   	iLg = strlen (doc->value.a_classer.trpart[j].rpart) -4;
  	doc->value.a_classer.trpart[j].iRgParent = giviNbParentPart;
  	doc->value.a_classer.trpart[j].iNbParent = 0;
    if (0 == strcmp(giv_PJDC, &doc->value.a_classer.trpart[j].rpart[iLg]))
    {
    	giviRefPJDC = j;
  	  /* lecture et écriture des denominations du partenaire PJDC parent */
      iLg = strlen (doc->value.a_classer.trpart[j].rpart) -4;
  	  (void)strcpy (rIapart.acOriPart,&doc->value.a_classer.trpart[j].rpart[iLg]);
      memcpy (rIapart.acRefPart, doc->value.a_classer.trpart[j].rpart, iLg);
      rIapart.acRefPart[iLg] = '\0';
      strcpy (rIapart.acParentRefPart,doc->value.a_classer.trpart[j].parent);
      strcpy (rIapart.acTypeRefPart,doc->value.a_classer.trpart[j].typepart);

      /* intitule du partenaire pjdc */
      lg_write = giv_init_denom_parent (buf_pos, doc->value.a_classer.etab, &iDebut);
      buf_pos = buf_pos + lg_write;
      /* Ecriture dans le fichier de sortie */
      iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
           GWTTrace(GWT_NIV_FONCT,
             ("Type à traiter <%s> \n", doc->value.a_classer.trpart[j].typepart));
 	    if ((giv_orPJDC == rIapart.acTypeRefPart[0]) || (giv_cPJDC == rIapart.acTypeRefPart[0]))
 	    {
 	  	  /* recherche des types giv_svPJDC ou giv_prPJDC */
  	    iRet = GIVLecturePartEtabNav(&buf_pos, &rIapart, givtrPart ,&giviNbParentPart, &iDebut, NULL);
  	  }
  	  else if ((giv_prPJDC == rIapart.acTypeRefPart[0]) && (0 != strlen(rIapart.acParentRefPart)))
 	    {
 	  	  /* recherche des types giv_cPJDC ou giv_svPJDC ou/et giv_orPJDC */
  	    iRet = GIVLecturePartEtabNav(&buf_pos, &rIapart, givtrPart ,&giviNbParentPart, &iDebut, NULL);
  	    if ((0 != giviNbParentPart) && (giv_svPJDC == givtrPart[giviNbParentPart-1].acTypeRefPart[0]))
  	    {
  	      if (0 != strlen(givtrPart[giviNbParentPart-1].acParentRefPart))
  	      {
  	        if (0 != strcmp(rIapart.acRefPart,givtrPart[giviNbParentPart-1].acParentRefPart))
  	        {
  	      	  rIapart.acTypeRefPart[0] = givtrPart[giviNbParentPart-1].acTypeRefPart[0];
              strcpy (rIapart.acParentRefPart,givtrPart[giviNbParentPart-1].acParentRefPart);
  	          iRet = GIVLecturePartEtabNav(&buf_pos, &rIapart, givtrPart ,&giviNbParentPart, &iDebut, NULL);
  	        }
  	      }
  	    }
  	  }
  	  else if (giv_svPJDC == rIapart.acTypeRefPart[0])
  	  {
 	  	  /* recherche des types giv_orPJDC et giv_prPJDC */
   	    iRet = GIVLecturePartEtabNav(&buf_pos, &rIapart, givtrPart ,&giviNbParentPart, &iDebut, NULL);
   	    if (0 != strlen(rIapart.acParentRefPart))
   	    {
 		      rIapart.acParentRefPart[0] = '\0';
   	      iRet = GIVLecturePartEtabNav(&buf_pos, &rIapart, givtrPart ,&giviNbParentPart, &iDebut, NULL);
 		    }
  	  }
  	  doc->value.a_classer.trpart[j].iNbParent = 	giviNbParentPart - doc->value.a_classer.trpart[j].iRgParent;
      lg_write = giv_ecrit_fin_noeud(&buf_pos,"intitulelibpjdc");
      buf_pos = buf_pos + lg_write;
    }
  }

  if ('1' == doc->value.a_classer.parinsee)
  {
    lg_write =giv_ecrit_balise(buf_pos, docEPJ->value.a_classer.siret, "siret");
    buf_pos = buf_pos + lg_write;

    lg_write =giv_ecrit_balise(buf_pos, docEPJ->value.a_classer.naf, "ape");
    buf_pos = buf_pos + lg_write;
  }

  lg_write = giv_ecrit_fin_noeud(&buf_pos,"epj");
  buf_pos = buf_pos + lg_write;

  iRet = givLectureOldEtab(&buf_pos,doc->value.a_classer.etab);


  /* Ecriture dans le fichier de sortie en UTF8 */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  /* intitulé principal */
  iRang = givDnomPrincEtab(doc, indice);
  doc->value.intitule.iRgPrinc = iRang;
  if (-1 != iRang)
  {
  	strcpy(buf_concat, "");
    for (x=0; x<indice; x++)
    {
      for(y=0; y< (doc+x)->value.a_classer.iNbPart; y++)
      {
    	  if ((giv_prPJDC == (doc+x)->value.a_classer.trpart[y].typepart[0])
    	  	&&  (0 == strcmp("true",(doc+x)->value.a_classer.trpart[y].isdoc)))
        {
    	    /* ajout possible de "DR" pour docteur */
    	    break;
        }
      }
      if ((doc+x)->value.a_classer.iNbPart != y)
      {
    	  /* ajout possible de "DR" pour docteur */
    	  break;
      }
    }
  	if ((indice != x) && (0 == strlen((doc+iRang)->value.intitule.prenom)))
    {
      /* analyse de l'intitulé sans prénom pour PJDC */
      strcpy(rInscRef.acNumnat,(doc+iRang)->value.inscription[0].val_num);
      strcpy(rInscRef.acNumlo,(doc+iRang)->value.inscription[0].val_lo);
      strcpy(rInscRef.acNumls,(doc+iRang)->value.inscription[0].val_ls);
      iRet = GDQLibererCtxt();
      iRet = GDQQualifBlocIntl(&rInscRef);
      if (GIXCodeRIEN == iRet)
      {
    	  /* ajout de "DR" pour docteur */
    	  strcat(buf_concat, givTitreDoc);
      }
    }
  	else if ((indice != x) && (0 != strlen((doc+iRang)->value.intitule.prenom)))
    {
    	/* ajout de "DR" pour docteur avec prénom */
    	strcat(buf_concat, givTitreDoc);
    }
    for (i=0; i<indice; i++)
    {
      for (j = 0 ; (j < (doc+i)->value.rubriques.iNban9 && ('0' == (doc+i)->value.rubriques.Tan9[j].dnex)); j++);
      if ((doc+i)->value.rubriques.iNban9 != j)
      {
   	    break;
      }
    }
    if ((0 == strcmp(givtcInvDenPn,"NON")) || (indice == i))
    {
      strcat(buf_concat, (doc+iRang)->value.intitule.denomination);
      if (0 != strlen((doc+iRang)->value.intitule.prenom))
      {
        strcat(buf_concat, " ");
        strcat(buf_concat, (doc+iRang)->value.intitule.prenom);
      }
    }
    else
    {
  	  /* inversion de l'ordre le la denomination exacte */
      if (0 != strlen((doc+iRang)->value.intitule.prenom))
      {
        strcat(buf_concat, (doc+iRang)->value.intitule.prenom);
        strcat(buf_concat, " ");
        strcat(buf_concat, (doc+iRang)->value.intitule.denomination);
      }
      else
      {
        strcat(buf_concat, (doc+iRang)->value.intitule.denomination);
      }
    }
  	if (0 != strlen((doc+iRang)->value.intitule.complement_denomination))
  	{
  	  strcat(buf_concat, " ");
  	  strcat(buf_concat, (doc+iRang)->value.intitule.complement_denomination);
  	}
    lg_write = giv_ecrit_balise_iso(buf_pos, buf_concat, "intlprincipal");
    buf_pos = buf_pos + lg_write;
  }

  /* Ecriture dans le fichier de sortie */
  iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);

  lg_write = giv_ecrit_noeud_simple(buf_pos, "seo");
  buf_pos = buf_pos + lg_write;
  if ((0 != strlen(doc->value.a_classer.etab)) && ('0' != doc->cPubPrinc)
  	  	&& (giv_cLEUR != doc->cNature))
  {
      GWTTrace (GWT_NIV_FONCT,("Etab SEO... %s\n",doc->value.a_classer.etab));
      lg_write = giv_ecrit_balise(buf_pos, doc->value.a_classer.etab,"lepj");
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_balise(buf_pos, doc->value.a_classer.etab,"epj");
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_noeud_simple(buf_pos, "longseo");
      buf_pos = buf_pos + lg_write;
      if (0 != strlen(doc->value.a_classer.etab))
      {
        iRet = givServiceEtabSEO (doc, &cInfo, &cAvis);
        if ((int4)GIXCodeOK == iRet && 'o' == cInfo)
        {
          GWTTrace (GWT_NIV_FONCT,("Info Etab SEO...\n"));
          lg_write = giv_ecrit_balise(buf_pos,"info","ongseo");
          buf_pos = buf_pos + lg_write;
        }
        if ((int4)GIXCodeOK == iRet && 'o' == cAvis)
        {
          GWTTrace (GWT_NIV_FONCT,("Avis Etab SEO...\n"));
          lg_write = giv_ecrit_balise(buf_pos,"avis","ongseo");
          buf_pos = buf_pos + lg_write;
        }
      }
      lg_write = giv_ecrit_fin_noeud(&buf_pos,"longseo");
      buf_pos = buf_pos + lg_write;
  }
  lg_write = giv_ecrit_fin_noeud(&buf_pos,"seo");
  buf_pos = buf_pos + lg_write;

  if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
  {
    lg_write = giv_ecrit_balise(buf_pos, "2", "typeclient");
  }
  else
  {
    lg_write = giv_ecrit_balise(buf_pos, "1", "typeclient");
  }
  buf_pos = buf_pos + lg_write;

  if (0 != strlen(doc->value.a_classer.etab))
  {
    /* établissement */
    lg_write = giv_ecrit_balise(buf_pos,"1","petab");
  }
  else
  {
    lg_write = giv_ecrit_balise(buf_pos,"0","petab");
  }
  buf_pos = buf_pos + lg_write;

  if (0 != strlen(doc->value.a_classer.etab))
  {
    iRet = givLectureEvIlo (doc->value.a_classer.etab, &tcEvt[0], &tcPrg[0]);
    tcEvt[1] = '\0';
    tcPrg[1] = '\0';
    lg_write =giv_ecrit_balise(buf_pos, tcPrg, "iloprg");
    buf_pos = buf_pos + lg_write;
    lg_write =giv_ecrit_balise(buf_pos, tcEvt, "iloevt");
    buf_pos = buf_pos + lg_write;
    iRet = givLectureEtabMC (doc->value.a_classer.etab, doc->value.a_classer.parinsee, &buf_pos);
  }

  if ((0 != strlen(doc->value.a_classer.siret)) && ('1' == doc->value.a_classer.parinsee))
  {
    iRet = givLectureSIRET (doc->value.a_classer.siret);
    if ((int4)GIXCodeOK == iRet)
    {
       lg_write = giv_ecrit_balise(buf_pos, "1", "pagespro");
       buf_pos = buf_pos + lg_write;
    }
  }
  if (0 != strlen(doc->value.a_classer.etab))
  {
    /* BonPlan autorisé pour les IO et les IS */
    iRet = givEcritureBonPlan (doc->value.a_classer.etab,&buf_pos);
  }

  pipe = 0;
  for (x=0; x<indice; x++)
  {
    if (pipe == 0)
    {
      strcpy(buf_concat, (doc+x)->value.numero_client);
      pipe = 1;
    }
    else
    {
      strcat (buf_concat, "|");
      strcat(buf_concat, (doc+x)->value.numero_client);
    }
  }

  if (1 == pipe)
  {
    iRet = supprimer_doublon(buf_concat, '|');
    pt_fin_lst = buf_concat + strlen(buf_concat);
    for (pt_debut = buf_concat; pt_debut < pt_fin_lst; )
    {
      pt_fin=strchr(pt_debut, '|');
      if (pt_fin == 0)
      {
        pt_fin = pt_fin_lst;
      }
      /* analyse client */
      memcpy(tcNumcli, pt_debut, (pt_fin - pt_debut));
      tcNumcli[(pt_fin - pt_debut)] = '\0';
      lg_write = giv_ecrit_noeud_simple(buf_pos, "numclis");
      buf_pos = buf_pos + lg_write;
      lg_write =  giv_ecrit_element(buf_pos, "numcli", tcNumcli);
      buf_pos = buf_pos + lg_write;
      iRet = givLectureStat (tcNumcli, tcStat);
      lg_write =giv_ecrit_balise(buf_pos, tcStat, "estatan");
      buf_pos = buf_pos + lg_write;
      iRet = givLectureEmbauche (tcNumcli, tcRefext);
      lg_write =giv_ecrit_balise(buf_pos, tcRefext, "jobid");
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_fin_noeud(&buf_pos, "numclis");
      buf_pos = buf_pos + lg_write;
      pt_debut=pt_fin+1;
    }
  }

  buf_concat[0] = '\0';
  for (x=0; x<indice; x++)
  {
    if ((0 != strlen((doc+x)->value.a_classer.etab)) && (0 == strcmp("0000",(doc+x)->value.inscription[0].val_ls)) && ('0' == (doc+x)->cIndPart))
    {
      iRet = givLectureBUC ((doc+x)->value.a_classer.etab, "0001", "7999");
      break;
    }
  }
  if (0 != strlen(buf_concat))
  {
    GWTTrace (GWT_NIV_FONCT,(" BUC... %s\n",buf_concat ));
    iRet = supprimer_doublon(buf_concat, '|');
    pt_fin_lst = buf_concat + strlen(buf_concat);
    for (pt_debut = buf_concat; pt_debut < pt_fin_lst; )
    {
      pt_fin=strchr(pt_debut, '|');
      if (pt_fin == 0)
      {
        pt_fin = pt_fin_lst;
      }
      /* analyse client */
      memcpy(tcNumcli, pt_debut, (pt_fin - pt_debut));
      tcNumcli[(pt_fin - pt_debut)] = '\0';
      lg_write =  giv_ecrit_element(buf_pos, "numclipj", tcNumcli);
      buf_pos = buf_pos + lg_write;
      pt_debut=pt_fin+1;
    }
  }
  buf_concat[0] = '\0';
  for (x=0; x<indice; x++)
  {
    if ((0 != strlen((doc+x)->value.a_classer.etab)) && (0 == strcmp("0000",(doc+x)->value.inscription[0].val_ls)) && ('0' == (doc+x)->cIndPart))
    {
      iRet = givLectureBUC ((doc+x)->value.a_classer.etab, "8000", "9999");
      break;
    }
  }
  if (0 != strlen(buf_concat))
  {
    GWTTrace (GWT_NIV_FONCT,(" BUC... %s\n",buf_concat ));
    iRet = supprimer_doublon(buf_concat, '|');
    pt_fin_lst = buf_concat + strlen(buf_concat);
    for (pt_debut = buf_concat; pt_debut < pt_fin_lst; )
    {
      pt_fin=strchr(pt_debut, '|');
      if (pt_fin == 0)
      {
        pt_fin = pt_fin_lst;
      }
      /* analyse client */
      memcpy(tcNumcli, pt_debut, (pt_fin - pt_debut));
      tcNumcli[(pt_fin - pt_debut)] = '\0';
      lg_write =  giv_ecrit_element(buf_pos, "numclicdh", tcNumcli);
      buf_pos = buf_pos + lg_write;
      pt_debut=pt_fin+1;
    }
  }
  memset(buf_concat, 0, strlen(buf_concat));

  lg_write =giv_ecrit_balise(buf_pos, doc->value.intitule.datefinparu, "finparut");
  buf_pos = buf_pos + lg_write;

  /* Ecriture dans le fichier de sortie en UTF8 */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);

  for (x=0; x<indice; x++)
  {
    if (0 == x)
    {
    	y = x;
    }
    else
    {
    	y = x-1;
    }
    if ((0 == x) || (0 != strcmp((doc+x)->value.intitule.denomination,(doc+y)->value.intitule.denomination)))
    {
      if (0 != x)
      {
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "intitulemarques");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "qualites");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "marquess");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "motsdets");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "cpldenoms");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "prenoms");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "intitule");
        buf_pos = buf_pos + lg_write;
      }
      lg_write = giv_ecrit_noeud_simple(buf_pos, "intitule");
      buf_pos = buf_pos + lg_write;
      lg_write =giv_ecrit_balise_iso(buf_pos, (doc+x)->value.intitule.denomination, "denom");
      buf_pos = buf_pos + lg_write;

      iRet = givLectureSynonyme(doc, &buf_pos, x, indice);

      iPrenom = 1;
    }
    if ((1 == iPrenom) || (0 != strcmp((doc+x)->value.intitule.prenom,(doc+y)->value.intitule.prenom)))
    {
      if (1 != iPrenom)
      {
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "intitulemarques");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "qualites");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "marquess");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "motsdets");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "cpldenoms");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "prenoms");
        buf_pos = buf_pos + lg_write;
      }

      lg_write = giv_ecrit_noeud_simple(buf_pos, "prenoms");
      buf_pos = buf_pos + lg_write;

      lg_write =giv_ecrit_balise_iso(buf_pos, (doc+x)->value.intitule.prenom, "prenom");
      buf_pos = buf_pos + lg_write;

      lg_write =giv_ecrit_balise_iso(buf_pos, (doc+x)->value.intitule.initiale, "iprenom");
      buf_pos = buf_pos + lg_write;

      for (z=0; z<indice; z++)
      {
        for (zz = 0 ; (zz < (doc+z)->value.rubriques.iNban9 && ('0' == (doc+z)->value.rubriques.Tan9[zz].dnex)); zz++);
        if ((doc+z)->value.rubriques.iNban9 != zz)
        {
    	    break;
        }
      }
      if ((0 == strcmp(givtcInvDenPn,"NON")) || (indice == z))
      {
        strcpy(buf_concat, (doc+x)->value.intitule.denomination);
        if (0 != strlen((doc+x)->value.intitule.prenom))
        {
          strcat(buf_concat, " ");
          strcat(buf_concat, (doc+x)->value.intitule.prenom);
        }
      }
      else
      {
  	    /* inversion de l'ordre le la denomination exacte */
        if (0 != strlen((doc+x)->value.intitule.prenom))
        {
          strcpy(buf_concat, (doc+x)->value.intitule.prenom);
          strcat(buf_concat, " ");
          strcat(buf_concat, (doc+x)->value.intitule.denomination);
        }
        else
        {
          strcpy(buf_concat, (doc+x)->value.intitule.denomination);
        }
      }
      lg_write = giv_ecrit_balise_iso(buf_pos, buf_concat, "denomexacte");
      buf_pos = buf_pos + lg_write;
      iPrenom = 0;
      iCpl = 1;
    }

    if ((1 == iCpl) || (0 != strcmp((doc+x)->value.inscription[0].moyen_de_com.laqualite,(doc+y)->value.inscription[0].moyen_de_com.laqualite)))
    {
      if (1 != iCpl)
      {
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "intitulemarques");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "qualites");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "marquess");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "motsdets");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "cpldenoms");
        buf_pos = buf_pos + lg_write;
      }

      lg_write = giv_ecrit_noeud_simple(buf_pos, "cpldenoms");
      buf_pos = buf_pos + lg_write;

      memset(buf_concat, 0, strlen(buf_concat));
      strcpy(buf_concat, (doc+x)->value.intitule.complement_denomination);
      if ( 0 == strcmp(givtcSupCplDen,"OUI"))
      {
        if (0 == strcmp((doc+x)->value.intitule.complement_denomination, (doc+x)->value.inscription[0].moyen_de_com.laqualite))
        {
          buf_concat[0] = '\0';
        }
        else if (0 != strlen((doc+x)->value.inscription[0].moyen_de_com.laqualite))
        {
          pcDeb = strstr(buf_concat,(doc+x)->value.inscription[0].moyen_de_com.laqualite);
          if (NULL != pcDeb)
          {
            if ((pcDeb == &buf_concat[0]) && (' ' == *(pcDeb + strlen((doc+x)->value.inscription[0].moyen_de_com.laqualite))))
            {
              (void)strcpy(pcDeb, pcDeb + strlen((doc+x)->value.inscription[0].moyen_de_com.laqualite) + 1);
            }
            else if ((pcDeb != &buf_concat[0]) && (' ' == *(pcDeb - 1)) && (' ' == *(pcDeb + strlen((doc+x)->value.inscription[0].moyen_de_com.laqualite))))
            {
              (void)strcpy(pcDeb, pcDeb + strlen((doc+x)->value.inscription[0].moyen_de_com.laqualite) + 1);
            }
            else if ((pcDeb != &buf_concat[0]) && (' ' == *(pcDeb - 1)) && ('\0' == *(pcDeb + strlen((doc+x)->value.inscription[0].moyen_de_com.laqualite))))
            {
              *(pcDeb - 1) = '\0';
            }
          }
        }
      }
      lg_write =giv_ecrit_balise_iso(buf_pos, buf_concat, "cpldenom");
      buf_pos = buf_pos + lg_write;
      iCpl = 0;
      iMots = 1;
    }

    if ((1 == iMots) || (0 != strcmp((doc+x)->value.intitule.mots_determinants,(doc+y)->value.intitule.mots_determinants)))
    {
      if (1 != iMots)
      {
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "intitulemarques");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "qualites");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "marquess");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "motsdets");
        buf_pos = buf_pos + lg_write;
      }

      lg_write = giv_ecrit_noeud_simple(buf_pos, "motsdets");
      buf_pos = buf_pos + lg_write;

      lg_write =giv_ecrit_balise_iso(buf_pos, (doc+x)->value.intitule.mots_determinants, "motsdet");
      buf_pos = buf_pos + lg_write;
      iMots = 0;
      iMarq = 1;
    }

    if ((1 == iMarq) || (0 != strcmp((doc+x)->value.inscription[0].moyen_de_com.lamarque,(doc+y)->value.inscription[0].moyen_de_com.lamarque)))
    {
      if (1 != iMarq)
      {
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "intitulemarques");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "qualites");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "marquess");
        buf_pos = buf_pos + lg_write;
      }

      lg_write = giv_ecrit_noeud_simple(buf_pos, "marquess");
      buf_pos = buf_pos + lg_write;

      lg_write =giv_ecrit_balise_iso(buf_pos, (doc+x)->value.inscription[0].moyen_de_com.lamarque, "marques");
      buf_pos = buf_pos + lg_write;

      memset(buf_concat, 0, strlen(buf_concat));
      strcpy(buf_concat, (doc+x)->value.intitule.denomination);
      if (0 == strcmp((doc+x)->value.intitule.denomination, (doc+x)->value.inscription[0].moyen_de_com.lamarque))
      {
        buf_concat[0] = '\0';
      }
      else if (0 != strlen((doc+x)->value.inscription[0].moyen_de_com.lamarque))
      {
        pcDeb = strstr(buf_concat,(doc+x)->value.inscription[0].moyen_de_com.lamarque);
        if (NULL != pcDeb)
        {
          if ((pcDeb == &buf_concat[0]) && (' ' == *(pcDeb + strlen((doc+x)->value.inscription[0].moyen_de_com.lamarque))))
          {
            (void)strcpy(pcDeb, pcDeb + strlen((doc+x)->value.inscription[0].moyen_de_com.lamarque) + 1);
          }
          else if ((pcDeb != &buf_concat[0]) && (' ' == *(pcDeb - 1)) && (' ' == *(pcDeb + strlen((doc+x)->value.inscription[0].moyen_de_com.lamarque))))
          {
            (void)strcpy(pcDeb, pcDeb + strlen((doc+x)->value.inscription[0].moyen_de_com.lamarque) + 1);
          }
          else if ((pcDeb != &buf_concat[0]) && (' ' == *(pcDeb - 1)) && ('\0' == *(pcDeb + strlen((doc+x)->value.inscription[0].moyen_de_com.lamarque))))
          {
            *(pcDeb - 1) = '\0';
          }
        }
      }
      lg_write = giv_ecrit_balise_iso(buf_pos, buf_concat, "rs");
      buf_pos = buf_pos + lg_write;
      iMarq = 0;
      iQual = 1;
    }

    if ((1 == iQual) || (0 != strcmp((doc+x)->value.inscription[0].moyen_de_com.laqualite,(doc+y)->value.inscription[0].moyen_de_com.laqualite)))
    {
      if (1 != iQual)
      {
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "intitulemarques");
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "qualites");
        buf_pos = buf_pos + lg_write;
      }

      lg_write = giv_ecrit_noeud_simple(buf_pos, "qualites");
      buf_pos = buf_pos + lg_write;

      lg_write =giv_ecrit_balise_iso(buf_pos, (doc+x)->value.inscription[0].moyen_de_com.laqualite, "qualite");
      buf_pos = buf_pos + lg_write;
      iQual = 0;
      iInMq = 1;
    }

    if ((1 == iInMq) || (0 != strcmp((doc+x)->value.intitule.tcIntlAnnot,(doc+y)->value.intitule.tcIntlAnnot)))
    {
      if (1 != iInMq)
      {
        lg_write = giv_ecrit_fin_noeud(&buf_pos, "intitulemarques");
        buf_pos = buf_pos + lg_write;
      }
      lg_write = giv_ecrit_noeud_simple(buf_pos, "intitulemarques");
      buf_pos = buf_pos + lg_write;
      if (0 != strlen((doc+x)->value.intitule.tcIntlAnnot))
      {
        /* Ecriture dans le fichier de sortie */
        iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
        /* conversion du XMLType */
        (void)strcpy(GIVBuffInter,(doc+x)->value.intitule.tcIntlAnnot);
        (void) givConvClob();
        giviConflitCRC = GWCCodeKO;
        iRet = givAnalyseObjetXML("I1", doc+x, GIVBuffInter, &buf_pos);
        /* Ecriture dans le fichier de sortie de l'annotation déjà en UTF8 */
        iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
      }
      iInMq = 0;
    }
  }
  lg_write = giv_ecrit_fin_noeud(&buf_pos, "intitulemarques");
  buf_pos = buf_pos + lg_write;
  lg_write = giv_ecrit_fin_noeud(&buf_pos, "qualites");
  buf_pos = buf_pos + lg_write;
  lg_write = giv_ecrit_fin_noeud(&buf_pos, "marquess");
  buf_pos = buf_pos + lg_write;
  lg_write = giv_ecrit_fin_noeud(&buf_pos, "motsdets");
  buf_pos = buf_pos + lg_write;
  lg_write = giv_ecrit_fin_noeud(&buf_pos, "cpldenoms");
  buf_pos = buf_pos + lg_write;
  lg_write = giv_ecrit_fin_noeud(&buf_pos, "prenoms");
  buf_pos = buf_pos + lg_write;
  lg_write = giv_ecrit_fin_noeud(&buf_pos, "intitule");
  buf_pos = buf_pos + lg_write;

  /* Ecriture dans le fichier de sortie */
  iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);

  /* intitulés de LO présents dans les données additionnelles de source GC-EN */
  GWTTrace (GWT_NIV_FONCT,(" GC-EN ... %s,%s\n", (doc+x)->value.inscription[0].val_lslo, givtcObjCont));
  if (0 != strstr(givtcObjCont, giv_GCEN))
  {
    /* lecture en base de DA GC-EN */
    iRet = givLectureEtabDonSupp(doc->value.a_classer.etab,"",giv_GCEN,giv_ADG);
    GWTTrace (GWT_NIV_FONCT,(" GC-EN ... %s\n", GIVBuffInter ));
    iLg = strlen(GIVBuffInter);
    if (0 != iLg)
    {
    	pcDeb = GIVBuffInter;
      strcat (buf_pos, "<listeLibEnseigneEpj>");
      lg_write = strlen(buf_pos);
      *(buf_pos + lg_write) = SEPARE_LIGNE;
      *(buf_pos + lg_write + 1) = LINE_FEED;
      *(buf_pos + lg_write + 2) = '\0';
    	while ((GIVBuffInter + iLg) > pcDeb && (NULL != pcDeb))
      {
        pcDeb = strstr(pcDeb, "<libelleEnseigne>");
        pcDeb += strlen("<libelleEnseigne>");
        pcFin = strchr(pcDeb, '<');
        *pcFin = '\0';
        pcFin++;
        strcat (buf_pos, "<libEnseigneEpj>");
        strcat (buf_pos, pcDeb);
        strcat (buf_pos, "</libEnseigneEpj>");
        lg_write = strlen(buf_pos);
        *(buf_pos + lg_write) = SEPARE_LIGNE;
        *(buf_pos + lg_write + 1) = LINE_FEED;
        *(buf_pos + lg_write + 2) = '\0';
        pcDeb = strstr(pcFin, "<libelleEnseigne>");
      }
      strcat (buf_pos, "</listeLibEnseigneEpj>");
      lg_write = strlen(buf_pos);
      *(buf_pos + lg_write) = SEPARE_LIGNE;
      *(buf_pos + lg_write + 1) = LINE_FEED;
      *(buf_pos + lg_write + 2) = '\0';
      lg_write = lg_write + 2;
      buf_pos = (buf_pos + lg_write);
      /* Ecriture dans le fichier de sortie */
      iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
    }
  }

  buf_concat[0] = '\0';
  doc->cPubPrinc = '5';
  strcpy(rIamic.acNumobj,"");
  pipe = 0;
  for(i=0; i< indice; i++)
  {
  	/* ajout produits fictifs partenaires */
    for(x=0; x< doc[i].value.a_classer.iNbPart; x++)
    {
    	if (0 == strlen(doc[i].value.a_classer.trpart[x].prod))
    	{
    		continue;
    	}
      if (pipe == 0)
      {
        strcpy(buf_concat, "X");
        strcat(buf_concat, doc[i].value.a_classer.trpart[x].prod);
        pipe = 1;
      }
      else
      {
        strcat(buf_concat, "|X");
        strcat(buf_concat, doc[i].value.a_classer.trpart[x].prod);
      }
    }
  }

  for(j=0; j<givrListObj.iNbr; j++)
  {
   i = givrListObj.trEltListObj[givrListObj.trEltRangListObj[j]].iRgLigne;
   x = givrListObj.trEltListObj[givrListObj.trEltRangListObj[j]].iRgObj;
   if (0 == givrListObj.trEltListObj[givrListObj.trEltRangListObj[j]].iOrdTri)
   {
      strcpy(ref_pub, (doc+i)->value.objets_pub.micro[x].type);
      strcpy(transforme_stype, (doc+i)->value.objets_pub.micro[x].stype);
      if (transforme_stype[0] == ' ')
      {
        strcat(ref_pub, &transforme_stype[1]);
      }
      else
      {
        strcat(ref_pub, transforme_stype);
      }
    if ((0 == strcmp((doc+i)->value.objets_pub.micro[x].stype,  "SC")) &&
    	(0 == strcmp((doc+i)->value.objets_pub.micro[x].sstype, "PB")) )
    {
      /* SC-PB */
      strcat(ref_pub, (doc+i)->value.objets_pub.micro[x].sstype);
    }
    if (0 == strlen(buf_concat))
    {
      strcpy(buf_concat, ref_pub);
    }
    else if ((0 == strstr(buf_concat, ref_pub)) || (0 == strcmp((doc+i)->value.objets_pub.micro[x].stype,  "SC")))
    {
    	if ((int4)strlen(buf_concat) >= ((int4)sizeof(buf_concat) - (int4)strlen(ref_pub) - (int4)1))
      {
    	  /* espace insuffisant */
        GWTTrace (GWT_NIV_GRAVE,
              ("Taille buffer interne produit dépassée epj : %s\n",doc->value.a_classer.etab));
    	  break;
      }
      strcat(buf_concat, "|");
      strcat(buf_concat, ref_pub);
    }
    if ((0 == strcmp((doc+i)->value.objets_pub.micro[x].stype,  "SC")) &&
    	(0 == strcmp((doc+i)->value.objets_pub.micro[x].sstype, "PV")) &&
    	(0 == strlen(rIamic.acNumobj)))
    {
      /* SC-PB/SR n'est pas un PVI */
     strcpy(rIamic.acNumobj,(doc+i)->value.objets_pub.micro[x].id);
      doc->cPubPrinc = '1';
    }
    else if ((0 == strcmp(transforme_stype," T")) && ('2' < doc->cPubPrinc))
    {
      doc->cPubPrinc = '2';
    }
    else if ((0 == strcmp(transforme_stype,"NV")) && ('3' < doc->cPubPrinc))
    {
      doc->cPubPrinc = '3';
    }
    else if ((0 == strcmp(transforme_stype,"NT")) && ('4' < doc->cPubPrinc))
    {
      doc->cPubPrinc = '4';
    }
   }
  }
  for(i=1; i<indice; i++)
  {
    (doc+i)->cPubPrinc = doc->cPubPrinc;
  }

  iCodRet = supprimer_doublon(buf_concat, '|');
    pt_fin_lst = buf_concat + strlen(buf_concat);
    for (pt_debut = buf_concat; pt_debut < pt_fin_lst; )
    {
      pt_fin=strchr(pt_debut, '|');
      if (pt_fin == 0)
      {
        pt_fin = pt_fin_lst;
      }
      /* analyse client */
      memcpy(tcProduit, pt_debut, (pt_fin - pt_debut));
      tcProduit[(pt_fin - pt_debut)] = '\0';
      lg_write =  giv_ecrit_element(buf_pos, "pjproduit", tcProduit);
      buf_pos = buf_pos + lg_write;
      pt_debut=pt_fin+1;
    }

  if (0 != strlen(rIamic.acNumobj))
  {
    iRet = givLectureImag (&rIamic, tcNbimag, tcImagCat, &tcMenu[0]);
    tcMenu[1] ='\0';
    lg_write = giv_ecrit_balise(buf_pos, tcNbimag, "nbimag");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_balise(buf_pos, tcImagCat, "imagcat");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_balise(buf_pos, tcMenu, "imagmenu");
    buf_pos = buf_pos + lg_write;
  }

  /* analyse des produits MA pour UAVS */
  if ((NULL != strstr(buf_concat,givtcMaxAud)) && (0 != strlen(buf_concat)))
  {
    lg_write =  giv_ecrit_element(buf_pos, "rank", "2");
    buf_pos = buf_pos + lg_write;
  }

  /* analyse des Numéros Fréquemment Demandés 95299999 */
  for(x=0; (x< givrListParu.iNbr && ((0 != strcmp(givcDepFictif,givrListParu.trEltList[x].dep)) || (0 != strcmp(givcLocFictive,givrListParu.trEltList[x].loc)))) ; x++);
  if (givrListParu.iNbr != x)
  {
    lg_write =  giv_ecrit_element(buf_pos, "rank", "1");
    buf_pos = buf_pos + lg_write;
  }
  /* Ecriture dans le fichier de sortie en UTF8 */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);

  iRang = -1;
  for (x=0; x<indice; x++)
  {
    if (iRang != (doc+x)->value.intitule.iRgDnom)
    {
      lg_write =giv_ecrit_balise_iso(buf_pos, (doc+x)->value.intitule.denomination, "denomination");
      buf_pos = buf_pos + lg_write;
      iRang = (doc+x)->value.intitule.iRgDnom;
    }
  }
  /* Ecriture dans le fichier de sortie */
  iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);

  for (x=0; x<indice; x++)
  {
    for (y=0; y<x; y++)
    {
      if (0 == strcmp((doc+x)->value.rubriques.mogmoi,(doc+y)->value.rubriques.mogmoi))
      {
      	break;
      }
    }
    if (y == x)
    {
      lg_write = giv_ecrit_balise(buf_pos, (doc+x)->value.rubriques.mogmoi,"mogmoi");
      buf_pos = buf_pos + lg_write;
    }
  }
  for (x=0; x<indice; x++)
  {
    for (y=0; y<x; y++)
    {
      if (0 == strcmp((doc+x)->value.rubriques.mpg,(doc+y)->value.rubriques.mpg))
      {
      	break;
      }
    }
    if (y == x)
    {
      lg_write = giv_ecrit_balise(buf_pos, (doc+x)->value.rubriques.mpg,"mpg");
      buf_pos = buf_pos + lg_write;
    }
  }
  for (x=0; x<indice; x++)
  {
    for (y=0; y<x; y++)
    {
      if (0 == strcmp((doc+x)->value.rubriques.mendom,(doc+y)->value.rubriques.mendom))
      {
      	break;
      }
    }
    if (y == x)
    {
      lg_write = giv_ecrit_balise(buf_pos, (doc+x)->value.rubriques.mendom,"mendom");
      buf_pos = buf_pos + lg_write;
    }
  }

  *buf_pos_in=buf_pos;

  return(iCodRet);

} /* Fin ecrire_partie_2_1 */


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_partie_2_2 ()                                        */
/*                                                                            */
/* But       : ecrit la partie deux du bloc de parution simple ou groupe      */
/*             possibilite de boucler si cas de Ig ou groupement              */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 giv_ecrit_partie_2_2 (char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice, GYBrDOCUMENT *docIG, int4 indmax)
{


  int4 lg_write;
  int4 lg;
  int4 i,j,k,l,q;
  char *buf_pos;
  int4         iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  char code_instal[10+1];
  char tcPrecision[2+1];
  char tcBlocid[27+1];
  char datfin[GYBIeinscLgDatmod +1]; /* date fin */
  char tcDeplocarr[GYBIeinscLgDeppar+GYBIeinscLgLocpar+GYBIeinscLgArrond+1];
  char tcNb[5+1]; /* nb de bon plan */
  int4 iQualite;
  int4 pipe;                          /* Flag pour ajout pipe */
  int4 iRet;
  int4 iAn9, iRef;
  char *pt_fin_liste;
  char *pt_debut_element;
  char *pt_fin_element;
  char *pt_mil_element;
  char *pt_fin_lst;
  char *pt_debut;
  char *pt_fin;
  char tcElmt[29+1];                         /* partenaire*/
  GYBrIamicT rIamic;
  GYBrIadresT    rIadres; /* adresse étendue */
  GYBrIndIadresT rIndIadres;

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  lg_write = giv_ecrit_noeud_inscription(buf_pos, doc, 0);
  buf_pos = buf_pos + lg_write;

  /* numéro standard */
  lg_write = giv_ecrit_balise(buf_pos, "STD", "TypeNum");
  buf_pos = buf_pos + lg_write;

  if (docIG->value.intitule.iRgPrinc == indice)
  {
    lg_write = giv_ecrit_balise(buf_pos,doc->value.numero_bloc_parution_ref,"ippal");
    buf_pos = buf_pos + lg_write;
  }

  iAn9 = 0;
  for(i=0; i<(doc->value.rubriques.iNban9); i++)
  {
      if (0 == strcmp(doc->value.rubriques.Tan9[i].val_codan9, givcR00000000))
      {
        iAn9 = 1;
        break;
      }
  }
  if (1 == iAn9)
  {
    lg_write = giv_ecrit_balise(buf_pos,"O","ialpha");
    buf_pos = buf_pos + lg_write;
  }
  iAn9 = 0;
  for(i=0; i<(doc->value.rubriques.iNban9); i++)
  {
      if (0 != strcmp(doc->value.rubriques.Tan9[i].val_codan9, givcR00000000))
      {
        iAn9 = 1;
        lg_write = giv_ecrit_balise(buf_pos, doc->value.rubriques.Tan9[i].val_codan9, "ian9");
        buf_pos = buf_pos + lg_write;
      }
  }
  iAn9 = 0;
  for(i=0; i<(doc->value.rubriques.iNban9); i++)
  {
      if (0 != strcmp(doc->value.rubriques.Tan9[i].val_codan9, givcR00000000))
      {
        iAn9 = 1;
        lg_write = giv_ecrit_balise(buf_pos, doc->value.rubriques.Tan9[i].val_codan8, "ian8");
        buf_pos = buf_pos + lg_write;
      }
  }

  memset(buf_concat, 0, strlen(buf_concat));
  pipe = 0;

  for(i=0; i<(givrListParu.iNbrTot); i++)
  {
    j= givrListParu.trEltRangList[i];
    if ( indice == givrListParu.trEltList[j].iRgLigne && 0 != strlen(givrListParu.trEltList[j].rubinit) )
    {
      if (pipe == 0)
      {
        strcpy(buf_concat, givrListParu.trEltList[j].nature);
        pipe = 1;
      }
      else if ((int4)strlen(buf_concat) < ((int4)sizeof(buf_concat) - (int4)strlen(givtcNatureAn8Part)))
      {
        strcat (buf_concat, "|");
        strcat(buf_concat, givrListParu.trEltList[j].nature);
      }
    }
  }
  GWTTrace (GWT_NIV_FONCT,(" ipjb2b... %s\n",buf_concat ));

  iRet = supprimer_doublon(buf_concat, '|');
  if (0 != strlen(buf_concat))
  {
    lg_write = giv_ecrit_balise(buf_pos, buf_concat, "ipjb2b");
    buf_pos = buf_pos + lg_write;
  }
  /* Ecriture dans le fichier de sortie en UTF8 */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);

  lg_write = giv_ecrit_balise_iso(buf_pos, doc->value.intitule.denomination, "denomination");
  buf_pos = buf_pos + lg_write;

  lg_write =giv_ecrit_balise_iso(buf_pos, doc->value.intitule.prenom, "prenom");
  buf_pos = buf_pos + lg_write;

  lg_write =giv_ecrit_balise_iso(buf_pos, doc->value.intitule.initiale, "iprenom");
  buf_pos = buf_pos + lg_write;

  for (i=0; i<indmax; i++)
  {
    for (j = 0 ; (j < (docIG+i)->value.rubriques.iNban9 && ('0' == (docIG+i)->value.rubriques.Tan9[j].dnex)); j++);
    if ((docIG+i)->value.rubriques.iNban9 != j)
    {
    	break;
    }
  }
  if ((0 == strcmp(givtcInvDenPn,"NON")) || (indmax == i))
  {
    strcpy(buf_concat, doc->value.intitule.denomination);
    if (0 != strlen(doc->value.intitule.prenom))
    {
      strcat(buf_concat, " ");
      strcat(buf_concat, doc->value.intitule.prenom);
    }
  }
  else
  {
  	/* inversion de l'ordre le la denomination exacte */
    if (0 != strlen(doc->value.intitule.prenom))
    {
      strcpy(buf_concat, doc->value.intitule.prenom);
      strcat(buf_concat, " ");
      strcat(buf_concat, doc->value.intitule.denomination);
    }
    else
    {
      strcpy(buf_concat, doc->value.intitule.denomination);
    }
  }
  lg_write = giv_ecrit_balise_iso(buf_pos, buf_concat, "denomexacte");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise_iso(buf_pos, doc->value.intitule.complement_denomination, "icpldenom");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise_iso(buf_pos, doc->value.inscription[0].moyen_de_com.laqualite, "iqualite");
  buf_pos = buf_pos + lg_write;
  /* Ecriture dans le fichier de sortie */
  iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);

  memset(buf_concat, 0, strlen(buf_concat));

  lg_write = giv_ecrit_noeud(buf_pos, doc->value.inscription[0].adresse.parution, "adresse", "parution");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.numero_voie,"numvoie");
  buf_pos = buf_pos + lg_write;


  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.instal,"codloc");
  buf_pos = buf_pos + lg_write;


  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.lib_complt_num_voie,"libcplnumvoie");
  buf_pos = buf_pos + lg_write;


  if (0 != strlen(doc->value.inscription[0].adresse.code_voie))
  {
    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.code_voie,"codvoie");
    buf_pos = buf_pos + lg_write;
    memset(buf_concat, 0, strlen(buf_concat));
    strcpy(buf_concat, doc->value.inscription[0].adresse.instal);
    strcat(buf_concat, doc->value.inscription[0].adresse.code_voie);
    lg_write = giv_ecrit_balise(buf_pos, buf_concat, "pjcoddeplocvoie");
    buf_pos = buf_pos + lg_write;
  }

  if (0 != strlen(doc->value.inscription[0].adresse.lib_code_voie))
  {
    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.lib_code_voie,"libvoie");
  }
  else
  {
    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.libel_voie,"libvoie");
  }
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.adrnr,"adrnr");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.lieue_ae,"lieueae");
  buf_pos = buf_pos + lg_write;

  if (((0 == strcmp(GIVtcGeneSSAdr,"OUI"))
       && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr]))
      || (givcParuSSAdr != doc->value.inscription[0].adresse.parution[givcIndParuAdr]))
  {
    memset(buf_concat, 0, strlen(buf_concat));
    pipe = 0;
    if (0 != strlen(doc->value.rubriques.arract))
    {
      strcpy(buf_concat, doc->value.rubriques.arract);
      pipe = 1;
    }
    else if (0 != strlen(doc->value.inscription[0].adresse.arrondissement))
    {
      strcpy(buf_concat, doc->value.inscription[0].adresse.arrondissement);
      pipe = 1;
    }
    /* suppression des doubles arrondissement */
    iRet = supprimer_doublon(buf_concat, '|');

    lg_write = giv_ecrit_balise(buf_pos, buf_concat, "arr");
    buf_pos = buf_pos + lg_write;


    buf_concat[0] = '\0';

    memset(buf_concat, 0, strlen(buf_concat));
    pipe = 0;
    if (0 != strlen(doc->value.rubriques.arract))
    {
      strcpy(buf_concat, doc->value.rubriques.depact);
      strcat(buf_concat, doc->value.rubriques.locact);
      strcat(buf_concat, doc->value.rubriques.arract);
      pipe = 1;
    }
    else if (0 != strlen(doc->value.inscription[0].adresse.arrondissement))
    {
      strcpy(buf_concat, doc->value.inscription[0].adresse.instal);
      strcat(buf_concat, doc->value.inscription[0].adresse.arrondissement);
      pipe = 1;
    }
    /* suppression des doubles arrondissement */
    iRet = supprimer_doublon(buf_concat, '|');

    lg_write = giv_ecrit_balise(buf_pos, buf_concat, "arrinst");
    buf_pos = buf_pos + lg_write;
  }

  buf_concat[0] = '\0';

  pipe = 0;

  for(j=0; j<(givrListParu.iNbr); j++)
  {
    l= givrListParu.trEltRangList[j];
    if ( ((int4)GIXCodeKO == givrListParu.trEltList[l].iLF)
         && (99 != givrListParu.trEltList[l].iGeoArr) )
    {
      strcpy(tcDeplocarr,givrListParu.trEltList[l].dep);
      strcat(tcDeplocarr,givrListParu.trEltList[l].loc);
      strcat(tcDeplocarr,givrListParu.trEltList[l].arr);
      if (sizeof(buf_concat) < (strlen(buf_concat) + strlen(tcDeplocarr)) )
      {
        /* Trop d'entrées internes */
        GWTTrace (GWT_NIV_GRAVE,
              ("Taille buffer interne dépassée\n"));
        break;
      }
      if (pipe == 0)
      {
        strcpy(buf_concat, tcDeplocarr);
        pipe = 1;
      }
      else if (0 == strstr (buf_concat, tcDeplocarr))
      {
        strcat (buf_concat, "|");
        strcat(buf_concat, tcDeplocarr);
      }
    }
  }

  /* suppression des doubles arrondissement */
  iRet = supprimer_doublon(buf_concat, '|');
  if (0 != strlen(buf_concat))
  {
      pt_fin_lst = buf_concat + strlen(buf_concat);
      for (pt_debut = buf_concat; pt_debut < pt_fin_lst; )
      {
        pt_fin=strchr(pt_debut, '|');
        if (pt_fin == 0)
        {
          pt_fin = pt_fin_lst;
        }
        /* analyse rub */
        memcpy(code_instal, pt_debut, (pt_fin - pt_debut));
        code_instal[(pt_fin - pt_debut)] = '\0';
        lg_write =  giv_ecrit_element(buf_pos, "arrpar", code_instal);
        buf_pos = buf_pos + lg_write;
        pt_debut=pt_fin+1;
      }
  }

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.libinstal,"libloc");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.libinstact,"liblocact");
  buf_pos = buf_pos + lg_write;

  iRet = givLectureLibLocAtt(&buf_pos, doc->value.inscription[0].adresse.instal, doc->value.a_classer.etab);

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.code_postal, "cp");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.code_cedex, "cedex");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.lib_cedex, "libcedex");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.boite, "bp");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.ipays, "ipays");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.ensemble_batiment, "bat");
  buf_pos = buf_pos + lg_write;

  buf_concat[0] = '\0';
  i = 0;
  if ((givcParuSSAdr != doc->value.intitule.parution[givcIndParuAdr]) ||
     ((0 == strcmp(GIVtcGeneSSAdr,"OUI"))
            && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr])))
  {
  	/* Adresse étendue */
    (void)strcpy (rIadres.acNumnat,doc->value.inscription[0].val_num);
    (void)strcpy (rIadres.acNumlo,doc->value.inscription[0].val_lo);
    (void)strcpy (rIadres.acNumls,doc->value.inscription[0].val_ls);
    iRet = GIVLectureLectureIADRES (&rIadres,
                                    &rIndIadres);
    if ((int4)GIXCodeOK == iRet)
    {
      lg_write = giv_ecrit_balise(buf_pos, rIadres.acCodReg, "coderegion");
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_balise(buf_pos, rIadres.acLibDep, "libdep");
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_balise(buf_pos, rIadres.acLibReg, "libregion");
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_balise(buf_pos, rIadres.acTypVoiEtendu, "typevoieetendu");
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_balise(buf_pos, rIadres.acLibVoiEtendu, "libvoietendu");
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_balise(buf_pos, rIadres.acLigne2Etendu, "ligne2Etendu");
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_balise(buf_pos, rIadres.acLigne3Etendu, "ligne3Etendu");
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_balise(buf_pos, rIadres.acLigne5Etendu, "ligne5Etendu");
      buf_pos = buf_pos + lg_write;
    }

    strcat(buf_concat, doc->value.inscription[0].adresse.ensemble_batiment);
    if (givcParuSSNoParu != doc->value.intitule.parution[givcIndParuNoParu])
    {
      if (0 != strlen(doc->value.inscription[0].adresse.numero_voie))
      {
        strcat(buf_concat," ");
        strcat(buf_concat, doc->value.inscription[0].adresse.numero_voie);
      }
      if (0 != strlen(doc->value.inscription[0].adresse.lib_complt_num_voie))
      {
        strcat(buf_concat," ");
        strcat(buf_concat, doc->value.inscription[0].adresse.lib_complt_num_voie);
      }
    }
    if (0 != strlen(doc->value.inscription[0].adresse.lib_code_voie))
    {
      strcat(buf_concat," ");
      strcat(buf_concat, doc->value.inscription[0].adresse.lib_code_voie);
    }
    else if (0 != strlen(doc->value.inscription[0].adresse.libel_voie))
    {
      strcat(buf_concat," ");
      strcat(buf_concat, doc->value.inscription[0].adresse.libel_voie);
    }
    else if (0 != strlen(doc->value.inscription[0].adresse.adrnr))
    {
      strcat(buf_concat," ");
      strcat(buf_concat, doc->value.inscription[0].adresse.adrnr);
    }
    if (0 != strlen(doc->value.inscription[0].adresse.lieue_ae))
    {
      strcat(buf_concat," ");
      strcat(buf_concat, doc->value.inscription[0].adresse.lieue_ae);
    }
    if (0 != strlen(doc->value.inscription[0].adresse.boite))
    {
      strcat(buf_concat, " BP ");
      strcat(buf_concat, doc->value.inscription[0].adresse.boite);
    }
    if (0 != strlen(doc->value.inscription[0].adresse.code_cedex))
    {
      strcat(buf_concat," ");
      strcat(buf_concat, doc->value.inscription[0].adresse.code_cedex);
    }
    else if (0 != strlen(doc->value.inscription[0].adresse.code_postal))
    {
      if ((0 == strcmp(doc->value.inscription[0].val_ls,"0000")) ||
      	((0 == strcmp(GIVtcGeneCP,"OUI")) && (0 != strcmp(doc->value.inscription[0].val_ls,"0000"))))
      {
        strcat(buf_concat," ");
        strcat(buf_concat, doc->value.inscription[0].adresse.code_postal);
      }
    }
    if (0 == strcmp(doc->value.inscription[0].val_ls,"0000"))
    {
      if (0 != strlen(doc->value.inscription[0].adresse.lib_cedex))
      {
        strcat(buf_concat," ");
        strcat(buf_concat, doc->value.inscription[0].adresse.lib_cedex);
      }
      else if (0 != strlen(doc->value.inscription[0].adresse.libinstal))
      {
        strcat(buf_concat," ");
        strcat(buf_concat, doc->value.inscription[0].adresse.libinstal);
      }
    }
    if (((0 != strlen(doc->value.inscription[0].adresse.lib_code_voie))
    	  || (0 != strlen(doc->value.inscription[0].adresse.libel_voie)))
    	  && (0 != strlen(doc->value.inscription[0].adresse.adrnr))
    	  && (0 != strcmp(doc->value.inscription[0].val_ls,"0000")))
    {
        strcat(buf_concat," ");
        strcat(buf_concat, doc->value.inscription[0].adresse.adrnr);
    }
    for(i=0; ( i < strlen(buf_concat) && ' ' == buf_concat[i]); i++);
  }

  lg_write = giv_ecrit_balise(buf_pos, &buf_concat[i], "adressekm");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_noeud_simple(buf_pos, "geoloc");
  buf_pos = buf_pos + lg_write;

  if ((( 0 == strcmp(doc->value.inscription[0].adresse.geoloc.precision,"00"))
  	|| ( 0 == strcmp(doc->value.inscription[0].adresse.geoloc.precision,"04"))
  	|| ( 0 == strcmp(doc->value.inscription[0].adresse.geoloc.precision,"99"))
  	|| ( 0 == strcmp(doc->value.inscription[0].adresse.geoloc.precision,"97")
  	   &&   givcParuAdr == doc->value.intitule.parution[givcIndParuAdr] ))
  	&& ( 0 == strcmp(doc->value.inscription[0].adresse.centreloc.precision, "0")))
  {
    strcpy(doc->value.inscription[0].adresse.geoloc.precision,"00");
    strcpy(doc->value.inscription[0].adresse.geoloc.longitude,doc->value.inscription[0].adresse.centreloc.longitude);
    strcpy(doc->value.inscription[0].adresse.geoloc.latitude,doc->value.inscription[0].adresse.centreloc.latitude);
  }
  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.geoloc.longitude,"long");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.geoloc.latitude,"lat");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.centreloc.precision,"prcnt");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.centreloc.longitude,"longcnt");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.centreloc.latitude,"latcnt");
  buf_pos = buf_pos + lg_write;

  iQualite = atoi(doc->value.inscription[0].adresse.geoloc.precision);
  if (50 == iQualite)
  {
  	/* précision forçée au centre de la localité */
    lg_write = giv_ecrit_balise(buf_pos, "1","forccnt");
    buf_pos = buf_pos + lg_write;
   	iQualite = 0;
   	strcpy(doc->value.inscription[0].adresse.geoloc.precision,"00");
  }
  else if (51 == iQualite)
  {
  	/* précision indiquant une inversion longitude et latitude */
    lg_write = giv_ecrit_balise(buf_pos, "1","forccnt");
    buf_pos = buf_pos + lg_write;
   	iQualite = 3;
   	strcpy(doc->value.inscription[0].adresse.geoloc.precision,"03");
  }
  doc->iDblGeoLoc = giv_EXTL;
  if (giv_LOC == doc->iGeoLoc)
  {
    /* inscription locale ou avec un double local */
    doc->iDblGeoLoc = giv_LOC;
    GWTTrace (GWT_NIV_FONCT,("test extraloc doc : %d\n", doc->iDblGeoLoc));
  }
  else
  {
    for (j=0 ; j < givrListParu.iNbrTot ; j++)
    {
      q= givrListParu.trEltRangList[j];
      if (giv_LOC == givrListParu.trEltList[q].iGeoLoc)
      {
        /* inscription locale via les autres parutions */
        doc->iDblGeoLoc = giv_LOC;
        GWTTrace (GWT_NIV_FONCT,("test extraloc dbl : %d\n", doc->iDblGeoLoc));
        break;
      }
    }
  }


  GWTTrace (GWT_NIV_FONCT,("test extraloc: %d,%d\n", doc->iDblGeoLoc,iAn9));
  switch(iQualite)
  {
    case 97:
    case 99:
      break;
    case 96:
    case 98:
      lg_write = giv_ecrit_balise(buf_pos, "04", "precision");
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_balise(buf_pos, "1", "srcprecision");
      buf_pos = buf_pos + lg_write;
      break;
    default:
      iQualite = iQualite % 4;
      (void) sprintf(&tcPrecision[0], "%02d", iQualite);
      lg_write = giv_ecrit_balise(buf_pos, tcPrecision, "precision");
      buf_pos = buf_pos + lg_write;
      if (giv_LOC == doc->iDblGeoLoc)
      {
        if ((0 != strlen(doc->value.a_classer.etab)) && (0 == strcmp(doc->value.inscription[0].val_ls,"0000")) && (0 != iAn9))
        {
          GWTTrace (GWT_NIV_FONCT,
                ("Extra Loc IO %s,%s,%s,%s\n", doc->value.a_classer.etab,doc->value.inscription[0].val_num,doc->value.inscription[0].val_lo,doc->value.inscription[0].val_ls));
          iRet = givExtraLocIO (doc);
          if ((int4)GIXCodeOK == iRet)
          {
      	    /* existence d'autre locale pour IO locale */
            lg_write = giv_ecrit_balise(buf_pos, tcPrecision, "prloc");
            buf_pos = buf_pos + lg_write;
          }
        }
        else
        {
          lg_write = giv_ecrit_balise(buf_pos, tcPrecision, "prloc");
          buf_pos = buf_pos + lg_write;
        }
      }
      if ((0 != strlen(doc->value.a_classer.etab)) && (giv_LOC != doc->iDblGeoLoc) && (0 != iAn9))
      {
      	buf_concat[0] = '\0';
        for(i=0; i<(givrListParu.iNbrTot); i++)
        {
          j= givrListParu.trEltRangList[i];
          if ( indice == givrListParu.trEltList[j].iRgLigne && 0 != strlen(givrListParu.trEltList[j].rubinit) &&
      	       NULL == strstr(buf_concat,givrListParu.trEltList[j].rubinit) )
          {
            iRet = givExtraLocIS (doc->value.a_classer.etab, givrListParu.trEltList[j].rubinit);
            if ((int4)GIXCodeOK != iRet)
            {
      	      /* absence de locale pour IS/IO non locale */
            GWTTrace (GWT_NIV_FONCT,
                  ("Extra Loc IS %s,%s\n", doc->value.a_classer.etab,givrListParu.trEltList[j].rubinit));
      	      break;
            }
            if (0 == strlen(buf_concat))
            {
              strcpy(buf_concat,givrListParu.trEltList[j].rubinit);
            }
            else
            {
              strcat(buf_concat,"|");
              strcat(buf_concat,givrListParu.trEltList[j].rubinit);
            }
          }
        }
        if (i != givrListParu.iNbrTot)
        {
          /* absence de locale pour un an8 */
          GWTTrace (GWT_NIV_FONCT,("Prloc IS... %s\n",givrListParu.trEltList[j].rubinit));
          lg_write = giv_ecrit_balise(buf_pos, tcPrecision, "prloc");
          buf_pos = buf_pos + lg_write;
        }
      }
      iQualite = atoi(doc->value.inscription[0].adresse.geoloc.precision);
      iQualite = iQualite / 4;
      (void) sprintf(&tcPrecision[0], "%d", iQualite);
      lg_write = giv_ecrit_balise(buf_pos, tcPrecision, "srcprecision");
      buf_pos = buf_pos + lg_write;
      break;
  }

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.geoloc.precMappy, "precisionMappy");
  buf_pos = buf_pos + lg_write;

  if (0 != strlen(doc->value.inscription[0].adresse.geoloc.longitude))
  {
    lg_write = giv_ecrit_noeud_simple(buf_pos, "carte");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_balise(buf_pos, doc->value.numero_bloc_parution, "ctebloc");
    buf_pos = buf_pos + lg_write;
    /* Ecriture dans le fichier de sortie en UTF8 */
    iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);

    lg_write = giv_ecrit_balise_iso(buf_pos, doc->value.intitule.denomination, "ctedenom");
    buf_pos = buf_pos + lg_write;
    /* Ecriture dans le fichier de sortie */
    iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);

    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.geoloc.longitude, "ctelong");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.geoloc.latitude, "ctelat");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"carte");
    buf_pos = buf_pos + lg_write;
  }

  lg_write = giv_ecrit_fin_noeud(&buf_pos,"geoloc");
  buf_pos = buf_pos + lg_write;

  /* Fin de l'entité adresse */
  lg_write = giv_ecrit_fin_noeud(&buf_pos, "adresse");
  buf_pos = buf_pos + lg_write;

  /* Entête pour moyen de communication */
  if (('0' != doc->cIndPart) && ( 0 == strlen(doc->value.inscription[0].moyen_de_com.numero_parution) ))
  {
  lg_write = giv_ecrit_noeud_simple(buf_pos, "moycom/");
  buf_pos = buf_pos + lg_write;
  }
  else
  {
  lg_write = giv_ecrit_noeud_simple(buf_pos, "moycom");
  buf_pos = buf_pos + lg_write;

  /* Ecriture dans le fichier de sortie en UTF8 */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);

  lg_write = giv_ecrit_balise_iso(buf_pos, doc->value.inscription[0].moyen_de_com.designation_ligne,"desligne");
  buf_pos = buf_pos + lg_write;
  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
  }

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.numero,"num");
  buf_pos = buf_pos + lg_write;

  switch (doc->value.intitule.protection[0])
  {
    case '1' :
      lg_write = giv_ecrit_balise(buf_pos,"rouge","protection");
      break;
    case '2' :
      lg_write = giv_ecrit_balise(buf_pos,"orange","protection");
      break;
    case '3' :
      lg_write = giv_ecrit_balise(buf_pos,"rouge|orange","protection");
      break;
    case '4' :
      lg_write = giv_ecrit_balise(buf_pos,"safran","protection");
      break;
    case '5' :
      lg_write = giv_ecrit_balise(buf_pos,"rouge|safran","protection");
      break;
    case '6' :
      lg_write = giv_ecrit_balise(buf_pos,"orange|safran","protection");
      break;
    case '7' :
      lg_write = giv_ecrit_balise(buf_pos,"rouge|orange|safran","protection");
      break;
    case 'A' :
      lg_write = giv_ecrit_balise(buf_pos,"noninverse","protection");
      break;
    case 'B' :
      lg_write = giv_ecrit_balise(buf_pos,"orange|noninverse","protection");
      break;
    case 'C' :
      lg_write = giv_ecrit_balise(buf_pos,"safran|noninverse","protection");
      break;
    case 'D' :
      lg_write = giv_ecrit_balise(buf_pos,"orange|safran|noninverse","protection");
      break;
    default :
      lg_write = 0;
      break;
  }
  buf_pos = buf_pos + lg_write;

  switch (doc->value.intitule.support[0])
  {
    case givcSuppCham :
      lg_write = giv_ecrit_balise(buf_pos,"chamois","support");
      break;
    default :
      lg_write = 0;
      break;
  }
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.numero_parution,"numpar");
  buf_pos = buf_pos + lg_write;

  j = 0;
  iRef = -1;
  if ( 0 != strlen(doc->value.inscription[0].moyen_de_com.numero_parution) )
  {
    for ( i = 0 ; i < strlen(doc->value.inscription[0].moyen_de_com.numero_parution) ; i++)
    {
    	  if (' ' == doc->value.inscription[0].moyen_de_com.numero_parution[i])
    	  {
    	  	iRef = i;
    	  }
    	  else if (( iRef+1 == i ) && (-1 != iRef) &&
    	  	(0 == isdigit(doc->value.inscription[0].moyen_de_com.numero_parution[i])) &&
    	  	(0 != isdigit(doc->value.inscription[0].moyen_de_com.numero_parution[0])))
        {
          doc->value.inscription[0].moyen_de_com.numero_parution[iRef] = '\0';
          lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.numero_parution,"numpartel");
          buf_pos = buf_pos + lg_write;
          doc->value.inscription[0].moyen_de_com.numero_parution[iRef] = ' ';
          lg_write = giv_ecrit_balise(buf_pos, &doc->value.inscription[0].moyen_de_com.numero_parution[iRef+1],"numparmagique");
          buf_pos = buf_pos + lg_write;
          break;
        }
    }
    if (strlen(doc->value.inscription[0].moyen_de_com.numero_parution) == i)
    {
    	  if (0 != isdigit(doc->value.inscription[0].moyen_de_com.numero_parution[0]))
        {
          lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.numero_parution,"numpartel");
          buf_pos = buf_pos + lg_write;
        }
        else
        {
          lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.numero_parution,"numparmagique");
          buf_pos = buf_pos + lg_write;
        }
    }
  }

  j = 0;
  if ( 0 != strlen(doc->value.inscription[0].moyen_de_com.numero_parution) )
  {

    for ( i = 0 ; i < strlen(doc->value.inscription[0].moyen_de_com.numero_parution) ; i++)
    {
      if (0 != isdigit(doc->value.inscription[0].moyen_de_com.numero_parution[i]))
      {
        buf_concat[j] = doc->value.inscription[0].moyen_de_com.numero_parution[i];
        j++;
      }
    }
  }
  else
  {
    for ( i = 0 ; i < strlen(doc->value.inscription[0].moyen_de_com.numero) ; i++)
    {
      if (0 != isdigit(doc->value.inscription[0].moyen_de_com.numero[i]))
      {
        buf_concat[j] = doc->value.inscription[0].moyen_de_com.numero[i];
        j++;
      }
    }
  }
  buf_concat[j] = '\0';
  lg_write = giv_ecrit_balise(buf_pos, buf_concat, "numinverse");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.code_produit,"codpro");
  buf_pos = buf_pos + lg_write;
  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.code_produit_etd,"codproetendu");
  buf_pos = buf_pos + lg_write;
  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.catnum,"catnumero");
  buf_pos = buf_pos + lg_write;

  if ((NULL != strstr(doc->value.inscription[0].moyen_de_com.code_produit,givtcAnMes)) && (0 != strlen(doc->value.inscription[0].moyen_de_com.code_produit)))
  {
    lg_write = giv_ecrit_balise(buf_pos,"AM","indic");
    buf_pos = buf_pos + lg_write;
  }

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.equiptel,"equiptel");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.servtel,"servtel");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.tarifart,"tarifart");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.operateur,"operateur");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.email,"email");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.mnemonique,"mnemonique");
  buf_pos = buf_pos + lg_write;

  /* Ecriture dans le fichier de sortie */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);

  /* conversion spécifique euro pour mention tarifaire */
  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.tarif_exact,"tarif");
  buf_pos = buf_pos + lg_write;
  /* Conversion du buffer avant écriture dans le fichier */
  givTradChar(&lg_write);
  /* Conversion euro */
  memcpy(GIVBuffInter, GIVBuffXML, strlen(GIVBuffXML));
  gwtRemplaceChaine(GIVBuffInter, GXW_cg_Euro, GXW_utf8_Euro, GIVBuffXML);
  /* écriture dans le fichier */
  iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );

  /* Fin de l'entité moyen_de_communication */
  lg_write = giv_ecrit_fin_noeud(&buf_pos,"moycom");
  buf_pos = buf_pos + lg_write;
  }

  if (0 != strlen(doc->value.inscription[0].moyen_de_com.cteutil))
  {
  /* Entête pour cu */
  lg_write = giv_ecrit_noeud_simple(buf_pos, "cu");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.cteutil,"idutil");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.datcu,"cudate");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.nomsupplement,"nomsf");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.msknum,"indmasknum");
  buf_pos = buf_pos + lg_write;

  lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.mskmel,"indmaskemail");
  buf_pos = buf_pos + lg_write;

  /* Fin de l'entité compte utilisateur */
  lg_write = giv_ecrit_fin_noeud(&buf_pos,"cu");
  buf_pos = buf_pos + lg_write;
  }

  *buf_pos_in=buf_pos;

  return(iCodRet);

} /* Fin ecrire_partie_2_2 */

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_partie_2_3 ()                                        */
/*                                                                            */
/* But       : ecrit la partie deux du bloc de parution simple ou groupe      */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 giv_ecrit_partie_2_3 (char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice)
{

  int4 lg_write;
  char *buf_pos, *buf_pos_ref, *buf_pos_cur;
  int4  iIntRet = GWCCodeOK;            /* Code retour de la fonction */
  int4  iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_tp,i,k,kk;
  int4 iDebut,iCVI;
  int4 iRang,iObj;
  int4 iRgLigne,iRgObj;

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  GWTTrace (GWT_NIV_FONCT,
            ("Entree partie 2_3 nb MICRO : ... %d\n", nb_micro));



  /* Fin de l'entité inscriptions */
  lg_write = giv_ecrit_fin_noeud(&buf_pos,"inscriptions");
  buf_pos = buf_pos + lg_write;

  (void)strcpy (givcTriPub, "1");

  iIntRet = giv_ecrit_noeud_objets_pub(&buf_pos, doc, indice, givcTriPub);
  iIntRet = giv_ecrit_noeud_objets_pvi(&buf_pos, doc, indice);

  iDebut = 1;
  /* lecture et ecriture des liens vers les produits à l'epj */
  iCodRet = givLectureLiensEtab(doc, &buf_pos, &iDebut, indice);
  if (0 == iDebut)
  {
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"elementsproduits");
    buf_pos = buf_pos + lg_write;
    /* Ecriture dans le fichier de sortie */
    iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
  }

  lg_write = giv_ecrit_noeud_simple(buf_pos, "contenus");
  buf_pos = buf_pos + lg_write;

  for(i=0; i<indice; i++)
  {
    buf_pos_ref = buf_pos;
    lg_write = giv_ecrit_noeud_simple(buf_pos, "urls");
    buf_pos = buf_pos + lg_write;
    buf_pos_cur = buf_pos;
    lg_write = giv_ecrit_balise(buf_pos, (doc+i)->value.inscription[0].moyen_de_com.indrg,"indrg");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_balise(buf_pos, (doc+i)->value.inscription[0].moyen_de_com.numrg,"numrg");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_balise(buf_pos, (doc+i)->value.inscription[0].moyen_de_com.url,"url");
    buf_pos = buf_pos + lg_write;
    if (0 != strlen((doc+i)->value.inscription[0].moyen_de_com.url))
    {
      lg_write = giv_ecrit_balise(buf_pos, "lvs" ,"typ_url");
      buf_pos = buf_pos + lg_write;
    }
    if (buf_pos_cur != buf_pos)
    {
      lg_write = giv_ecrit_fin_noeud(&buf_pos,"urls");
      buf_pos = buf_pos + lg_write;
    }
    else
    {
      buf_pos = buf_pos_ref;
      *buf_pos = '\0';
    }
  }
  /* analyse video d'un PVI */
  iRang = -1;
  iRgLigne = -1;
  for(i=0; i<givrListObj.iNbr; i++)
  {
    k = givrListObj.trEltRangListObj[i];
    kk = givrListObj.trEltListObj[k].iRgLigne;
    iObj = givrListObj.trEltListObj[k].iRgObj;
    if (iRang != givrListObj.trEltListObj[k].iRangTri)
    {
    	iRang = givrListObj.trEltListObj[k].iRangTri;
      if ( ((doc+kk)->value.objets_pub.micro[iObj].type[0] == 'X') &&
     	       (0 != strlen((doc+kk)->value.objets_pub.micro[iObj].tcdatact)) &&
             ( (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "VI")) ||
               (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "FI")) ||
               (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "IN")) ) )
      {
        if (-1 == iRgLigne)
        {
       	  iRgLigne = kk;
       	  iRgObj = iObj;
        }
        else if (0 < strcmp((doc+kk)->value.objets_pub.micro[iObj].tcdatact,(doc+iRgLigne)->value.objets_pub.micro[iRgObj].tcdatact))
        {
       	  iRgLigne = kk;
       	  iRgObj = iObj;
        }
      }
    }
  }
  if (-1 != iRgLigne)
  {
    lg_write = giv_ecrit_balise(buf_pos, (doc+iRgLigne)->value.objets_pub.micro[iRgObj].tcdatact ,"dmajvideo");
    buf_pos = buf_pos + lg_write;
  }

  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  }

  iIntRet = giv_ecrit_noeud_objets_url(&buf_pos, doc, indice);
    if (0 != strlen(doc->value.objets_pub.libUrlSite))
    {
      for(i=1; i<indice; i++)
      {
      	strcpy((doc+i)->value.objets_pub.libUrlSite,doc->value.objets_pub.libUrlSite);
      }
    }
  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie sans changement de format */
    iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
  }

  lg_write = giv_ecrit_fin_noeud(&buf_pos,"contenus");
  buf_pos = buf_pos + lg_write;

  GWTTrace (GWT_NIV_FONCT,
            ("Sortie partie 2_3 nb MICRO : ... %d\n", nb_micro));
  if (0 == strcmp("OUI",givtcContenu))
  {
    if (0 == strcmp(givtcRapED, "ETAB"))
    {
      iCodRet = givAnalyseContenu(&buf_pos, doc, indice);
    }
    else if (0 == strcmp(givtcRapED, "OUI"))
    {
      /* table des contenus prioritaires inutilisée */
      giviConflitCRC = GWCCodeKO;
      iCVI = GIXCodeKO;
      iCodRet = givEcritContenu("",&buf_pos, doc, indice, &iCVI);
      iCodRet = givEcritContenuED(&buf_pos, doc, indice);
    }
    /* enrichissements par le partenaire */
    iCodRet = givEcritPart(&buf_pos, doc, indice);
    /* données "réseaux-relais-colis" */
    iCodRet = givEcritDonRelais(&buf_pos, doc, 0, indice);
    /* données enrichies */
    iCodRet = givEcritDonEnr(&buf_pos, doc, indice);
    /* données additionnelles */
    iCodRet = givEcritDonAdd("DA", &buf_pos, doc, indice);
    /* mutualisation des données des partenaires */
    iCodRet = givMutualiserDonPartenaires(&buf_pos, doc, indice);
    /* données horaires payantes et gratuites */
    iCodRet = givEcritDonHoraires(&buf_pos, doc, indice);
    /* lecture et ecriture des Photos de l'epj */
    iDebut = 1;
    iCodRet = givLecturePhotosEtab(doc, &buf_pos, &iDebut);
    if (0 == iDebut)
    {
      lg_write = giv_ecrit_fin_noeud(&buf_pos,"affugc");
      buf_pos = buf_pos + lg_write;
      /* Ecriture dans le fichier de sortie */
      iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
    }
    iDebut = 1;
    /* lecture et ecriture des liens vzers site issus de SEO */
    iCodRet = givLectureLvsSeoEtab(doc, &buf_pos, &iDebut);
    if (0 == iDebut)
    {
      lg_write = giv_ecrit_fin_noeud(&buf_pos,"lvsparts");
      buf_pos = buf_pos + lg_write;
      /* Ecriture dans le fichier de sortie */
      iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
    }
    /* analyse des CRC (balises <normale>) par epj */
    iCodRet = givAffCRCEtab(&buf_pos);
  }
  else if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  }

  *buf_pos_in=buf_pos;

  return(iCodRet);

} /* Fin ecrit partie_2_3  */


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_partie_30       ()                                   */
/*                                                                            */
/* But       : ecrit la partie trois spécifique du tri                        */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 giv_ecrit_partie_30 (char **buf_pos_in, int4 iRg, int4 iTri)
{
  int4  iIntRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_write;
  char *buf_pos;
  int4 pipe;                          /* Flag pour ajout pipe */
  int4 i,j,k,l,jj,ll;
  int4 z,zz;
  int4 jRef,jRefObj;
  int4 iNbGeoRub;
  int4 iAlpha, iPV;
  int4 iDoc,iObj;
  char tcElemt[19];
  char tcStype[3],tcStypcvi[3];
  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;
    j = 0;
    jRef = -1;
    jRefObj = -1;
    iAlpha = -1;
    l = givrListParu.trEltRangList[j];
 GWTTrace (GWT_NIV_FONCT,("RgTriDbl: %d\n",iRg));
    while (j < givrListParu.iNbr)
    {
      if (iRg == givrListParu.trEltList[l].iRgTriDbl)
      {
        if (-1 == jRef)
        {
          if (giv_RUB == iTri)
          {
            lg_write = giv_ecrit_noeud_simple(buf_pos,"parutionrubriques");
            buf_pos = buf_pos + lg_write;
            memset(buf_concat, 0, strlen(buf_concat));
            pipe = 0;
          }
          else if (giv_DNOM == iTri)
          {
            lg_write = giv_ecrit_noeud_simple(buf_pos,"parutiondenoms");
            buf_pos = buf_pos + lg_write;
          }
          else
          {
            lg_write = giv_ecrit_noeud_simple(buf_pos,"parutionobjets");
            buf_pos = buf_pos + lg_write;
          }
        }
        jRef = j;

        if (giv_DNOM == iTri)
        {
          lg_write = 0;
          if ((int4)GIXCodeKO != givrListParu.trEltList[l].iRgLigne)
          {
            lg_write = giv_ecrit_balise_iso(buf_pos, (doc2+givrListParu.trEltList[l].iRgLigne)->value.intitule.denomination, "denom");
          }
        }
        else if (giv_OBJ == iTri)
        {
          iDoc = givrListParu.trEltList[l].iRgLigne;
          iObj = givrListParu.trEltList[l].iRgObj;
          giv_ecrit_objet_pub (&buf_pos, doc2, iDoc, iObj,"objetpub");
          if ( ((0 == strcmp ("SC", (doc2+iDoc)->value.objets_pub.micro[iObj].stype)) &&
                  (0 != strcmp ("PB", (doc2+iDoc)->value.objets_pub.micro[iObj].sstype))) ||
               ((0 != strlen((doc2+iDoc)->value.objets_pub.micro[iObj].stypcvi)) &&
                  (0 != strcmp ("MO", (doc2+iDoc)->value.objets_pub.micro[iObj].stype))) )
          {
            GWTTrace (GWT_NIV_FONCT,("iDoc,iObj : %d, %d, %s\n",iDoc,iObj,(doc2+iDoc)->value.objets_pub.micro[iObj].id));
          	pipe = 0;
          	iPV = -1;
          	jRefObj = 0;
          	/* sous-sous-type pour lien PV ou SR */
	          strcpy(tcStype,(doc2+iDoc)->value.objets_pub.micro[iObj].sstype);
	          strcpy(tcStypcvi,(doc2+iDoc)->value.objets_pub.micro[iObj].stypcvi);
            while (jRefObj < givrListParu.iNbrTot)
            {
              if (givrListParu.trEltList[l].iRangTri != givrListParu.trEltList[givrListParu.trEltRangList[jRefObj]].iRangTri)
              {
                jRefObj++;
              	continue;
              }
          	  jj = 0;
              while (jj < givrListParu.iNbrTot)
              {
                ll = givrListParu.trEltRangList[jj];
                if (givrListParu.trEltList[ll].iRgLigne ==
                	givrListParu.trEltList[givrListParu.trEltRangList[jRefObj]].iRgLigne)
                {
              	  iDoc = givrListParu.trEltList[ll].iRgLigne;
                  iObj = givrListParu.trEltList[ll].iRgObj;
                  GWTTrace (GWT_NIV_FONCT,("iDoc,iObj : %d, %d, %s, %s, %s\n",iDoc,iObj,
                                          (doc2+iDoc)->value.objets_pub.micro[iObj].stype,
                                          (doc2+iDoc)->value.objets_pub.micro[iObj].sstype,
                                          (doc2+iDoc)->value.objets_pub.micro[iObj].id));
                  if ( ((0 == strcmp (tcStype, (doc2+iDoc)->value.objets_pub.micro[iObj].sstype)) &&
                  ((0 == strcmp ("FI", (doc2+iDoc)->value.objets_pub.micro[iObj].stype)) ||
                  (0 == strcmp ("VI", (doc2+iDoc)->value.objets_pub.micro[iObj].stype)) ||
                  (0 == strcmp ("IN", (doc2+iDoc)->value.objets_pub.micro[iObj].stype)) ||
                  (0 == strcmp ("OB", (doc2+iDoc)->value.objets_pub.micro[iObj].stype)) ||
                  (0 == strcmp ("CP", (doc2+iDoc)->value.objets_pub.micro[iObj].stype)))) ||
                  ((0 == strcmp (tcStypcvi, (doc2+iDoc)->value.objets_pub.micro[iObj].stypcvi)) &&
                  (0 == strcmp ("MO", (doc2+iDoc)->value.objets_pub.micro[iObj].stype))) )
                  {
                     GWTTrace (GWT_NIV_FONCT,("objet lié/pub : %d\n",iPV));
                	  if (-1 == iPV)
                	  {
                		  iPV = 0;
                		  lg_write = giv_ecrit_noeud_simple(buf_pos, "objetsLies");
                      buf_pos = buf_pos + lg_write;
	                  }
	                  strcpy(tcElemt,(doc2+iDoc)->value.objets_pub.micro[iObj].stype);
                    strcat(tcElemt,(doc2+iDoc)->value.objets_pub.micro[iObj].id);
                    if (pipe == 0)
                    {
                      giv_ecrit_objet_pub (&buf_pos, doc2, iDoc, iObj,"objetpub");
                      strcpy(buf_concat,tcElemt);
                      pipe = 1;
                    }
                    else if (0 == strstr (buf_concat, tcElemt))
                    {
                      giv_ecrit_objet_pub (&buf_pos, doc2, iDoc, iObj,"objetpub");
                      strcat (buf_concat, "|");
                      strcat(buf_concat,tcElemt);
                    }
                  }
                }
                jj++;
              }
              jRefObj++;
            }
            if (0 == iPV)
            {
              lg_write = giv_ecrit_fin_noeud(&buf_pos,"objetsLies");
              buf_pos = buf_pos + lg_write;
            }
            lg_write = giv_ecrit_fin_noeud(&buf_pos,"objetpub");
            buf_pos = buf_pos + lg_write;
          }
          lg_write = 0;
        }
        else if (0 != strcmp(givrListParu.trEltList[l].rub, givcR00000000))
        {
          /* recherche en priorité d'une rubrique d'origine autre que complémentaire */
          for(k=0; (k<givrListParu.trEltList[l].iNbGeoTri &&
          (('4'==givrListParu.trEltList[givrListParu.trEltRangList[j+k]].orig)
          || ('6'==givrListParu.trEltList[givrListParu.trEltRangList[j+k]].orig)
          || ('7'==givrListParu.trEltList[givrListParu.trEltRangList[j+k]].orig))) ; k++);
          if (givrListParu.trEltList[l].iNbGeoTri == k)
          {
            if (pipe == 0)
            {
              strcpy(buf_concat, givrListParu.trEltList[l].nature);
              pipe = 1;
            }
            else if ((int4)strlen(buf_concat) < ((int4)sizeof(buf_concat) - (int4)strlen(givrListParu.trEltList[l].nature) - (int4)1))
            {
              strcat(buf_concat, "|");
              strcat(buf_concat, givrListParu.trEltList[l].nature);
            }
          }
          else
          {
            if (pipe == 0)
            {
              strcpy(buf_concat, givrListParu.trEltList[l].nature);
              pipe = 1;
            }
            else if ((int4)strlen(buf_concat) < ((int4)sizeof(buf_concat) - (int4)strlen(givrListParu.trEltList[l].nature) - (int4)1))
            {
              strcat (buf_concat, "|");
              strcat(buf_concat, givrListParu.trEltList[l].nature);
            }
          }
          lg_write = 0;
        }
        else
        {
          lg_write = 0;
          iAlpha = j;
        }
        buf_pos = buf_pos + lg_write;
      }
      iNbGeoRub = givrListParu.trEltList[l].iNbGeoTri;
      j = j + iNbGeoRub;
      if (j < givrListParu.iNbr)
      {
        l = givrListParu.trEltRangList[j];
      }
    }

  if ((giv_RUB == iTri) && (-1 != jRef))
  {
    iIntRet = supprimer_doublon(buf_concat, '|');
    lg_write = giv_ecrit_balise(buf_pos,buf_concat,"pjb2b");
    buf_pos = buf_pos + lg_write;

    j = 0;
    jRef = -1;
    iAlpha = -1;
    l = givrListParu.trEltRangList[j];
    memset(buf_concat, 0, strlen(buf_concat));
    pipe = 0;
    while (j < givrListParu.iNbr)
    {
      if (iRg == givrListParu.trEltList[l].iRgTriDbl)
      {
        jRef = j;

        if (0 != strcmp(givrListParu.trEltList[l].rub, givcR00000000))
        {
        	/* recherche de la parution santé */
          z = givrListParu.trEltList[l].iRgLigne;
          for (zz = 0 ; (zz < (doc2+z)->value.rubriques.iNban9
               && (0 != strcmp(givrListParu.trEltList[l].rub,(doc2+z)->value.rubriques.Tan9[zz].val_codan9)));
                zz++);
          /* recherche en priorité d'une rubrique d'origine autre que complémentaire */
          for(k=0; (k<givrListParu.trEltList[l].iNbGeoTri &&
          (('4'==givrListParu.trEltList[givrListParu.trEltRangList[j+k]].orig)
          || ('6'==givrListParu.trEltList[givrListParu.trEltRangList[j+k]].orig)
          || ('7'==givrListParu.trEltList[givrListParu.trEltRangList[j+k]].orig))) ; k++);
          if (givrListParu.trEltList[l].iNbGeoTri == k)
          {
            lg_write = giv_ecrit_noeud_rubriques(buf_pos, givrListParu.trEltList[l].rubinit, givrListParu.trEltList[l].rub, givrListParu.trEltList[l].orig, (doc2+z)->value.rubriques.Tan9[zz].dnex);
          }
          else
          {
            lg_write = giv_ecrit_noeud_rubriques(buf_pos, givrListParu.trEltList[l].rubinit, givrListParu.trEltList[l].rub, givrListParu.trEltList[givrListParu.trEltRangList[j+k]].orig, (doc2+z)->value.rubriques.Tan9[zz].dnex);
          }
        }
        else
        {
          lg_write = 0;
          iAlpha = j;
        }
        buf_pos = buf_pos + lg_write;
      }
      iNbGeoRub = givrListParu.trEltList[l].iNbGeoTri;
      j = j + iNbGeoRub;
      if (j < givrListParu.iNbr)
      {
        l = givrListParu.trEltRangList[j];
      }
    }

  }

    j = jRef;
    if (-1 != iAlpha)
    {
      lg_write = giv_ecrit_balise(buf_pos,"O","alpha");
      buf_pos = buf_pos + lg_write;
    }

    *buf_pos_in=buf_pos;

  return(j);

} /* Fin ecrit partie_30  */



/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_partie_3_geo   ()                                    */
/*                                                                            */
/* But       : ecrit la partie trois par géographie selon le tri              */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 giv_ecrit_partie_3_geo (char **buf_pos_in, GYBrDOCUMENT *docClone, int4 iInit, int4 iRangTri, int4 iTypeLoc, int4 iValLoc, char *pcBalise)
{

  int4 lg;                             /* Logueur du champ à traiter */
  int4 lg_write;
  char *buf_pos;
  int4  iCodRet,iIntRet;                      /* Code retour de la fonction */
  int4 pipe;                          /* Flag pour ajout pipe */
  int4 i,j,k,l,q,jj,ll;
  int4 iRang,iRgLigne,iObj;
  char tcRang[4+1];
  char tcDeplocarr[GYBIeinscLgDeppar+GYBIeinscLgLocpar+GYBIeinscLgArrond+1];
  char tcBalises[50+1];
  int4 iGeo, iParuInst;
  char *pt_fin_lst;
  char *pt_debut;
  char *pt_fin;
  iCodRet = GWCCodeOK;

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;
  /* balise encadrante */
  strcpy(tcBalises,pcBalise);

    memset(buf_concat, 0, strlen(buf_concat));
    pipe = 0;
    j = iInit;
    while (j < givrListParu.iNbrTot)
    {
      if ((iRangTri != givrListParu.trEltList[givrListParu.trEltRangList[j]].iRangTri) && (giv_ARR == iValLoc))
      {
      	j++;
      	continue;
      }
      else if (iRangTri != givrListParu.trEltList[givrListParu.trEltRangList[j]].iRangTri)
      {
      	j++;
      	continue;
      }
      l= givrListParu.trEltRangList[j];
          if (giv_ARR == iTypeLoc)
          {
            iGeo = givrListParu.trEltList[l].iGeoArr;
          }
          else if (giv_LOC == iTypeLoc)
          {
            iGeo = givrListParu.trEltList[l].iGeoLoc;
          }
          else if (giv_DEPT == iTypeLoc)
          {
            iGeo = givrListParu.trEltList[l].iGeoDept;
          }
          else if (giv_REG == iTypeLoc)
          {
            iGeo = givrListParu.trEltList[l].iGeoReg;
          }
          iParuInst = (int4)GIXCodeOK;
          iRgLigne = givrListParu.trEltList[l].iRgLigne;
          for(q=0; (q<3 && giv_ARR == iValLoc && iValLoc == iGeo && 0 != strcmp("0000",(docClone+iRgLigne)->value.inscription[0].val_ls)); q++)
          {
            /* parution sur arrondissement d'installation */
            if ((0 == strcmp(givtrRefArr[q].dep,givrListParu.trEltList[l].dep)) &&  (0 == strcmp(givtrRefArr[q].loc,givrListParu.trEltList[l].loc)))
            {
              iParuInst = givtrRefArr[q].iParuInst;
              break;
            }
          }

          if ( giv_ZU == iValLoc )
          {
      	      GWTTrace (GWT_NIV_FONCT,("ZU Ins : %d, %d, %s, %s\n",iGeo,givrListParu.trEltList[l].iZU,givrListParu.trEltList[l].dep,givrListParu.trEltList[l].loc));

          }

          if ((0 == strcmp("999",givrListParu.trEltList[l].dep))
          	&& (giv_REG != iTypeLoc))
          {
          	/* ancienne région : seule la parution sur région est validée */
      	  }
          else if ( (( giv_ARR == iValLoc ) && ((int4)GIXCodeOK != iParuInst)) || (( giv_ARR != iValLoc ) && ( giv_ZU != iValLoc ) && ( giv_ZV != iValLoc ) && ( giv_UV != iValLoc ) && ( iValLoc == iGeo ))
             || (( giv_ZU == iValLoc ) && ( giv_DEPT == iGeo ) && ((int4)GIXCodeOK == givrListParu.trEltList[l].iZU))
             || (( giv_ZU == iValLoc ) && ( giv_EXTL == iGeo ) && ((int4)GIXCodeOK == givrListParu.trEltList[l].iZU))
             || (( giv_ZV == iValLoc ) && ( iTypeLoc == iGeo ))
             || (( giv_UV == iValLoc ) && ( '1' == givrListParu.trEltList[l].cParuloc ) && (giv_ARR != iTypeLoc))
             || (( giv_UV == iValLoc ) && ( '1' == givrListParu.trEltList[l].cParuloc ) && (giv_ARR == iTypeLoc)
              && (0 != strcmp("99",givrListParu.trEltList[l].arr))
              && (0 != strcmp("00",givrListParu.trEltList[l].arr))
              && ( giv_INIT_ARR != iGeo )) )
      {
        if (pipe == 0)
        {
          if (0 == strcmp("pjdeploc",pcBalise))
          {
            lg_write =  giv_ecrit_element(buf_pos, "pjlocal", "1");
            buf_pos = buf_pos + lg_write;
          }
        }
        if (giv_ZV == iValLoc)
        {
          jj = iInit;
          while (jj < givrListParu.iNbrTot)
          {
            if (iRangTri != givrListParu.trEltList[givrListParu.trEltRangList[jj]].iRangTri)
            {
      	      jj++;
      	      continue;
            }
            ll= givrListParu.trEltRangList[jj];
            if (((int4)GIXCodeOK == givrListParu.trEltList[ll].iZU)
            	&& (0 != strcmp("999",givrListParu.trEltList[ll].dep))
      	      &&  (givrListParu.trEltList[l].iRgLigne == givrListParu.trEltList[ll].iRgLigne))
            {
              strcpy(tcDeplocarr,givrListParu.trEltList[ll].dep);
              strcat(tcDeplocarr,givrListParu.trEltList[ll].loc);
              if (sizeof(buf_concat) < (strlen(buf_concat) + strlen(tcDeplocarr)) )
              {
                /* Trop d'entrées internes */
                GWTTrace (GWT_NIV_GRAVE,
                  ("Taille buffer interne dépassée\n"));
                break;
              }
              if (pipe == 0)
              {
                strcpy(buf_concat,tcDeplocarr);
                pipe = 1;
              }
              else if (0 == strstr (buf_concat, tcDeplocarr))
              {
                strcat (buf_concat, "|");
                strcat(buf_concat,tcDeplocarr);
              }
            }
      	    jj++;
          }
      	  j++;
      	  continue;
        }
        else if (giv_UV == iValLoc)
        {
      	  if (0 == strcmp(givrListParu.trEltList[l].loc,givcLocFictive))
          {
        	  /* ajout de toutes les localités du département pour LF */
            iIntRet = givLectureLocDep(givrListParu.trEltList[l].dep, &pipe);
      	    j++;
      	    continue;
          }
          else if (giv_ARR == iTypeLoc)
          {
            strcpy(tcDeplocarr,givrListParu.trEltList[l].dep);
            strcat(tcDeplocarr,givrListParu.trEltList[l].loc);
            strcat(tcDeplocarr,givrListParu.trEltList[l].arr);
          }
          else
          {
            strcpy(tcDeplocarr,givrListParu.trEltList[l].dep);
            strcat(tcDeplocarr,givrListParu.trEltList[l].loc);
          }
        }
        else if (giv_ARR == iTypeLoc)
        {
          strcpy(tcDeplocarr,givrListParu.trEltList[l].dep);
          strcat(tcDeplocarr,givrListParu.trEltList[l].loc);
          strcat(tcDeplocarr,givrListParu.trEltList[l].arr);
        }
        else if (giv_LOC == iTypeLoc)
        {
          strcpy(tcDeplocarr,givrListParu.trEltList[l].dep);
          strcat(tcDeplocarr,givrListParu.trEltList[l].loc);
        }
        else if (giv_DEPT == iTypeLoc)
        {
          strcpy(tcDeplocarr,givrListParu.trEltList[l].dep);
        }
        else if (giv_REG == iTypeLoc)
        {
          strcpy(tcDeplocarr,givrListParu.trEltList[l].reg);
        }
        if (sizeof(buf_concat) < (strlen(buf_concat) + strlen(tcDeplocarr)) )
        {
          /* Trop d'entrées internes */
          GWTTrace (GWT_NIV_GRAVE,
              ("Taille buffer interne dépassée\n"));
          break;
        }
        if (pipe == 0)
        {
          strcpy(buf_concat,tcDeplocarr);
          pipe = 1;
        }
        else if (0 == strstr (buf_concat, tcDeplocarr))
        {
          strcat (buf_concat, "|");
          strcat(buf_concat,tcDeplocarr);
        }
      }
      j++;
    }
    j = iInit;
    while ((j < givrListInst.iNbrTot) && (giv_ARR == iTypeLoc) && (giv_ARR == iValLoc))
    {
      if (iRangTri != givrListInst.trEltList[givrListInst.trEltRangList[j]].iRangTri)
      {
      	j++;
      	continue;
      }
      l= givrListInst.trEltRangList[j];
            iGeo = givrListInst.trEltList[l].iGeoArr;
          iRgLigne = givrListInst.trEltList[l].iRgLigne;
          for(q=0; q<3; q++)
          {
            /* parution sur arrondissement d'installation */
            if ((0 == strcmp(givtrRefArr[q].dep,givrListInst.trEltList[l].dep)) &&  (0 == strcmp(givtrRefArr[q].loc,givrListInst.trEltList[l].loc)))
            {
              iParuInst = givtrRefArr[q].iParuInst;
              break;
            }
          }
          if (0 == strcmp("0000",(docClone+iRgLigne)->value.inscription[0].val_ls))
          {
            iParuInst = (int4)GIXCodeOK;
          }
          if  (((int4)GIXCodeOK == iParuInst) && ( iValLoc == iGeo ))

      {
        if (pipe == 0)
        {
          if (0 == strcmp("pjdeploc",pcBalise))
          {
            lg_write =  giv_ecrit_element(buf_pos, "pjlocal", "1");
            buf_pos = buf_pos + lg_write;
          }
        }
          strcpy(tcDeplocarr,givrListInst.trEltList[l].dep);
          strcat(tcDeplocarr,givrListInst.trEltList[l].loc);
          strcat(tcDeplocarr,givrListInst.trEltList[l].arr);
        if (sizeof(buf_concat) < (strlen(buf_concat) + strlen(tcDeplocarr)) )
        {
          /* Trop d'entrées internes */
          GWTTrace (GWT_NIV_GRAVE,
              ("Taille buffer interne dépassée\n"));
          break;
        }
        if (pipe == 0)
        {
          strcpy(buf_concat,tcDeplocarr);
          pipe = 1;
        }
        else if (0 == strstr (buf_concat, tcDeplocarr))
        {
          strcat (buf_concat, "|");
          strcat(buf_concat,tcDeplocarr);
        }
      }
      j++;
    }
          if ( giv_ZU == iValLoc )
          {
      	      GWTTrace (GWT_NIV_FONCT,("ZU Ins Buf: %s\n",buf_concat));

          }
    if (1 == pipe)
    {
      iIntRet = supprimer_doublon(buf_concat, '|');
      GWTTrace (GWT_NIV_FONCT,("Taille liste geo : '%d'\n",strlen(buf_concat)));
      pt_fin_lst = buf_concat + strlen(buf_concat);
      for (pt_debut = buf_concat; pt_debut < pt_fin_lst; )
      {
        pt_fin=strchr(pt_debut, '|');
        if (pt_fin == 0)
        {
          pt_fin = pt_fin_lst;
        }
        /* analyse geo */
        memcpy(tcDeplocarr, pt_debut, (pt_fin - pt_debut));
        tcDeplocarr[(pt_fin - pt_debut)] = '\0';
        lg_write =  giv_ecrit_element(buf_pos, pcBalise, tcDeplocarr);
        buf_pos = buf_pos + lg_write;
        pt_debut=pt_fin+1;
      }
    }
    else
    {
      iCodRet = GWCCodeKO;
    }

    *buf_pos_in=buf_pos;

  return(iCodRet);

} /* Fin ecrit partie_3_geo  */


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_partie_3_an9   ()                                    */
/*                                                                            */
/* But       : ecrit la partie trois du tri rubrique                          */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 giv_ecrit_partie_3_an9 (char **buf_pos_in, GYBrDOCUMENT *docClone, int4 iRangTri, int4 iTypeLoc, int4 iValLoc, char *pcBalise)
{

  int4 lg;                             /* Logueur du champ à traiter */
  int4 lg_write;
  char *buf_pos;
  int4  iCodRet,iIntRet;                      /* Code retour de la fonction */
  int4 pipe;                          /* Flag pour ajout pipe */
  int4 i,j,k,l,q,jj,ll;
  int4 iRang,iRgLigne,iObj;
  char tcRang[4+1];
  char tcDeploc[GYBIeinscLgDeppar+GYBIeinscLgLocpar+1];
  int4 iGeo, iParuInst;
  char *pt_fin_lst;
  char *pt_debut;
  char *pt_fin;
  char tcBalise[50+1];
  iCodRet = GWCCodeOK;

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;
  buf_concat[0] = '\0';

      pipe = 0;
      for(j=0; j< givrListParu.iNbrTot; j++)
      {
        l= givrListParu.trEltRangList[j];
        if (iRangTri == givrListParu.trEltList[l].iRgTriDbl)
        {
          if (giv_ARR == iTypeLoc)
          {
            iGeo = givrListParu.trEltList[l].iGeoArr;
          }
          else if (giv_LOC == iTypeLoc)
          {
            iGeo = givrListParu.trEltList[l].iGeoLoc;
          }
          else if (giv_DEPT == iTypeLoc)
          {
            iGeo = givrListParu.trEltList[l].iGeoDept;
          }
          else if (giv_REG == iTypeLoc)
          {
            iGeo = givrListParu.trEltList[l].iGeoReg;
          }
          iParuInst = (int4)GIXCodeOK;
          iRgLigne = givrListParu.trEltList[l].iRgLigne;
          for(q=0; (q<3 && giv_ARR == iValLoc && iValLoc == iGeo && 0 != strcmp("0000",(docClone+iRgLigne)->value.inscription[0].val_ls)); q++)
          {
            /* parution sur arrondissement d'installation */
            if ((0 == strcmp(givtrRefArr[q].dep,givrListParu.trEltList[l].dep)) &&  (0 == strcmp(givtrRefArr[q].loc,givrListParu.trEltList[l].loc)))
            {
              iParuInst = givtrRefArr[q].iParuInst;
              break;
            }
          }
          if ((0 == strcmp("999",givrListParu.trEltList[l].dep))
          	&& (giv_REG != iTypeLoc))
          {
          	/* ancienne région : seule la parution sur région est validée */
      	  }
          else if (( giv_ZV == iValLoc ) && ( iTypeLoc == iGeo ))
          {
            jj = 0;
            while (jj < givrListParu.iNbrTot)
            {
              if (iRangTri != givrListParu.trEltList[givrListParu.trEltRangList[jj]].iRangTri)
              {
      	        jj++;
      	        continue;
              }
              ll= givrListParu.trEltRangList[jj];
              if (((int4)GIXCodeOK == givrListParu.trEltList[ll].iZU)
            	  && (0 != strcmp("999",givrListParu.trEltList[ll].dep))
      	        &&  (givrListParu.trEltList[l].iRgLigne == givrListParu.trEltList[ll].iRgLigne))
              {
      	        i = givrListParu.trEltList[ll].iRgLigne;
                if ((int4)10000 < (strlen(buf_concat) + strlen(givrListParu.trEltList[ll].tcRgDnom)) )
                {
                  /* Trop d'entrées internes */
                  GWTTrace (GWT_NIV_GRAVE,
                  ("Taille buffer interne dépassée\n"));
                  break;
                }
                if (pipe == 0)
                {
                  strcpy(buf_concat, givrListParu.trEltList[ll].tcRgDnom);
                  buf_concat[10000] = '\0';
                  pipe = 1;
                }
                else if (0 == strstr (buf_concat, givrListParu.trEltList[ll].tcRgDnom))
                {
                  strcat (buf_concat, "|");
                  strcat(buf_concat, givrListParu.trEltList[ll].tcRgDnom);
                }
                for(q=0; q<givrListObj.iNbr; q++)
      	        {
      	        	if (i == givrListObj.trEltListObj[givrListObj.trEltRangListObj[q]].iRgLigne)
      	        	{
      	        		k = givrListObj.trEltListObj[givrListObj.trEltRangListObj[q]].iRgObj;
                  if ((int4)40000 < (strlen(&buf_concat[10000]) + strlen((docClone+i)->value.objets_pub.micro[k].tcRgObj)) )
                  {
                    /* Trop d'entrées internes */
                    GWTTrace (GWT_NIV_GRAVE,
                    ("Taille buffer interne dépassée\n"));
                    break;
                  }
                  if ('\0' == buf_concat[10000])
                  {
                    strcpy(&buf_concat[10000], (docClone+i)->value.objets_pub.micro[k].tcRgObj);
                  }
                  else if (0 == strstr (&buf_concat[10000], (docClone+i)->value.objets_pub.micro[k].tcRgObj))
                  {
                    strcat (&buf_concat[10000], "|");
                    strcat(&buf_concat[10000], (docClone+i)->value.objets_pub.micro[k].tcRgObj);
                  }
                  }
                }
              }
      	      jj++;
            }
          }
          else if ( (( giv_ARR == iValLoc ) && ((int4)GIXCodeOK != iParuInst)) || (( giv_ARR != iValLoc ) && ( giv_ZU != iValLoc ) && ( giv_UV != iValLoc ) && ( iValLoc == iGeo ))
             || (( giv_ZU == iValLoc ) && ( giv_DEPT == iGeo ) && ((int4)GIXCodeOK == givrListParu.trEltList[l].iZU))
             || (( giv_ZU == iValLoc ) && ( giv_EXTL == iGeo ) && ((int4)GIXCodeOK == givrListParu.trEltList[l].iZU))
             || (( giv_UV == iValLoc ) && ( '1' == givrListParu.trEltList[l].cParuloc ) && ( giv_DFT != iGeo ) && ( giv_INIT_ARR != iGeo )) )
          {
      	    i = givrListParu.trEltList[l].iRgLigne;
            if ((int4)10000 < (strlen(buf_concat) + strlen(givrListParu.trEltList[l].tcRgDnom)) )
            {
              /* Trop d'entrées internes */
              GWTTrace (GWT_NIV_GRAVE,
                ("Taille buffer interne dépassée\n"));
              break;
            }
            if (pipe == 0)
            {
              strcpy(buf_concat, givrListParu.trEltList[l].tcRgDnom);
              buf_concat[10000] = '\0';
              pipe = 1;
            }
            else if (0 == strstr (buf_concat, givrListParu.trEltList[l].tcRgDnom))
            {
              strcat (buf_concat, "|");
              strcat(buf_concat, givrListParu.trEltList[l].tcRgDnom);
            }
            for(q=0; q<givrListObj.iNbr; q++)
      	    {
      	      if (i == givrListObj.trEltListObj[givrListObj.trEltRangListObj[q]].iRgLigne)
      	      {
      	        k = givrListObj.trEltListObj[givrListObj.trEltRangListObj[q]].iRgObj;
              if ((int4)40000 < (strlen(&buf_concat[10000]) + strlen((docClone+i)->value.objets_pub.micro[k].tcRgObj)) )
              {
                /* Trop d'entrées internes */
                GWTTrace (GWT_NIV_GRAVE,
                  ("Taille buffer interne dépassée\n"));
                break;
              }
              if ('\0' == buf_concat[10000])
              {
                strcpy(&buf_concat[10000], (docClone+i)->value.objets_pub.micro[k].tcRgObj);
              }
              else if (0 == strstr (&buf_concat[10000], (docClone+i)->value.objets_pub.micro[k].tcRgObj))
              {
                strcat (&buf_concat[10000], "|");
                strcat(&buf_concat[10000], (docClone+i)->value.objets_pub.micro[k].tcRgObj);
              }
              }
            }
          }
        }
                                  GWTTrace (GWT_NIV_FONCT,
            ("Ref Pub geo pour An9 : ... %d,%d,%d,%d,%s,%s\n", iRangTri,givrListParu.trEltList[l].iRgTriDbl,givrListParu.trEltList[l].iRangTri, givrListParu.trEltList[l].iRgLigne, buf_concat, &buf_concat[10000]));
      }
        GWTTrace (GWT_NIV_FONCT,
            ("Ref Pub geo pour An9 : ... %s,%s\n", buf_concat, &buf_concat[10000]));

      for(j=0; (j< givrListInst.iNbrTot && giv_ARR == iTypeLoc && giv_ARR == iValLoc); j++)
      {
        l= givrListInst.trEltRangList[j];
        iGeo = givrListInst.trEltList[l].iGeoArr;
        if ((iRangTri == givrListInst.trEltList[l].iRgTriDbl) && ( iValLoc == iGeo ))
        {
          iRgLigne = givrListInst.trEltList[l].iRgLigne;
          for(q=0; q<3; q++)
          {
            /* parution sur arrondissement d'installation */
            if ((0 == strcmp(givtrRefArr[q].dep,givrListInst.trEltList[l].dep)) &&  (0 == strcmp(givtrRefArr[q].loc,givrListInst.trEltList[l].loc)))
            {
              iParuInst = givtrRefArr[q].iParuInst;
              break;
            }
          }
          if (0 == strcmp("0000",(docClone+iRgLigne)->value.inscription[0].val_ls))
          {
            iParuInst = (int4)GIXCodeOK;
          }

          if ((int4)GIXCodeOK == iParuInst)
          {
      	    i = givrListInst.trEltList[l].iRgLigne;
            if ((int4)10000 < (strlen(buf_concat) + strlen(givrListParu.trEltList[l].tcRgDnom)) )
            {
              /* Trop d'entrées internes */
              GWTTrace (GWT_NIV_GRAVE,
                ("Taille buffer interne dépassée\n"));
              break;
            }
            if (pipe == 0)
            {
              strcpy(buf_concat, givrListInst.trEltList[l].tcRgDnom);
              buf_concat[10000] = '\0';
              pipe = 1;
            }
            else if (0 == strstr (buf_concat, givrListInst.trEltList[l].tcRgDnom))
            {
              strcat (buf_concat, "|");
              strcat(buf_concat, givrListInst.trEltList[l].tcRgDnom);
            }
            for(q=0; q<givrListObj.iNbr; q++)
      	    {
      	      if (i == givrListObj.trEltListObj[givrListObj.trEltRangListObj[q]].iRgLigne)
      	      {
      	        k = givrListObj.trEltListObj[givrListObj.trEltRangListObj[q]].iRgObj;
              if ((int4)40000 < (strlen(&buf_concat[10000]) + strlen((docClone+i)->value.objets_pub.micro[k].tcRgObj)) )
              {
                /* Trop d'entrées internes */
                GWTTrace (GWT_NIV_GRAVE,
                  ("Taille buffer interne dépassée\n"));
                break;
              }
              if ('\0' == buf_concat[10000])
              {
                strcpy(&buf_concat[10000], (docClone+i)->value.objets_pub.micro[k].tcRgObj);
              }
              else if (0 == strstr (&buf_concat[10000], (docClone+i)->value.objets_pub.micro[k].tcRgObj))
              {
                strcat (&buf_concat[10000], "|");
                strcat(&buf_concat[10000], (docClone+i)->value.objets_pub.micro[k].tcRgObj);
              }
              }
            }
          }
        }
      }
      if (1 == pipe)
      {
        iIntRet = supprimer_doublon(buf_concat, '|');
        strcpy(tcBalise,"pjdenom");
        strcat(tcBalise,pcBalise);
        pt_fin_lst = buf_concat + strlen(buf_concat);
        for (pt_debut = buf_concat; pt_debut < pt_fin_lst; )
        {
          pt_fin=strchr(pt_debut, '|');
          if (pt_fin == 0)
          {
            pt_fin = pt_fin_lst;
          }
          /* analyse rang */
          memcpy(tcRang, pt_debut, (pt_fin - pt_debut));
          tcRang[(pt_fin - pt_debut)] = '\0';
          iRang = atoi(tcRang);
          lg_write =  giv_ecrit_balise_iso(buf_pos, (docClone+iRang)->value.intitule.denomination, tcBalise);
          buf_pos = buf_pos + lg_write;
          pt_debut=pt_fin+1;
        }
     }
      if ('\0' != buf_concat[10000])
      {
        iIntRet = supprimer_doublon(&buf_concat[10000], '|');
        strcpy(tcBalise,"pjobjet");
        strcat(tcBalise,pcBalise);
        pt_fin_lst = &buf_concat[10000] + strlen(&buf_concat[10000]);
        for (pt_debut = &buf_concat[10000]; pt_debut < pt_fin_lst; )
        {
          pt_fin=strchr(pt_debut, '|');
          if (pt_fin == 0)
          {
            pt_fin = pt_fin_lst;
          }
          /* analyse rang */
          memcpy(tcRang, pt_debut, (pt_fin - pt_debut));
          tcRang[(pt_fin - pt_debut)] = '\0';
          iRang = atoi(tcRang);
          for(i=0; (i<givrListObj.iNbr && iRang != givrListObj.trEltListObj[i].iRangTri); i++);
          iRang = givrListObj.trEltListObj[i].iRgLigne;
          iObj = givrListObj.trEltListObj[i].iRgObj;
          iIntRet = giv_ecrit_objet_pub (&buf_pos, docClone, iRang, iObj, tcBalise);
          pt_debut=pt_fin+1;
        }
      }

  *buf_pos_in=buf_pos;

  return(iCodRet);

} /* Fin ecrit partie_3_an9  */


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : giv_ecrit_partie_3       ()                                    */
/*                                                                            */
/* But       : ecrit la partie trois du clone                                 */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int4 giv_ecrit_partie_3 (char **buf_pos_in, GYBrDOCUMENT *docClone, int4 indice, int4 iTri)
{


  int4 lg;                             /* Logueur du champ à traiter */
  int4 lg_write;
  char *buf_pos;
  int4  iCodRet, iRet;                      /* Code retour de la fonction */
  int4 pipe;                          /* Flag pour ajout pipe */
  int4 i,j,k,l,m,mm,n,p,q;
  int4 iRef;
  int4 jRef,jInit;
  int4 iTrouve;
  int4 iIntRet = GWCCodeOK;
  int4 iNbrRangRub;
  int4 iRgRubDbl, iRang, iObj;
  char tcRang[4+1];
  char tcDeploc[GYBIeinscLgDeppar+GYBIeinscLgLocpar+1];
  int4 iNbGeoRub;
  int4 iNbRub;
  int4 iParuInst;
  int4 iCountMC ;
  char *pt_fin_lst;
  char *pt_debut;
  char *pt_fin;
  iCodRet = GWCCodeOK;

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  /* boucle sur rubrique */
  GWTTrace (GWT_NIV_FONCT, ("Partie 3 Nombre de tris [%d]\n", givrListParu.iNbrTri));
  pipe = 0;
  buf_concat[0] = '\0';
  docClone->iSource = 1;
  for(i=1; i< indice; i++)
  {
    (docClone+i)->iSource = docClone->iSource;
  }

  i = 0;
  j = 0;
  pipe = 0;
  for(n = 0; n < givrListParu.iNbrTri; n++)
  {
    if ((giv_RUB == iTri) && ('\0' != GIVBuffXML[0]))
    {
      /* Ecriture dans le fichier de sortie */
      iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
    }
    jRef = giv_ecrit_partie_30 (&buf_pos, n, iTri);
    if ((giv_RUB == iTri) && ('\0' != GIVBuffXML[0]))
    {
      /* Ecriture dans le fichier de sortie  en UTF8 */
      iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
    }
    if (-1 == jRef)
    {
      continue;
    }

    j = jRef;
    l = givrListParu.trEltRangList[j];
    m = givrListParu.trEltList[l].iRangTri;
    mm = givrListParu.trEltList[l].iRgTriDbl;
    /* analyse des données géographiques des doubles */
    memset(buf_concat, 0, strlen(buf_concat));
    pipe = 0;
    i = 0;
    /* Pour deplocarr */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, 0, m, giv_ARR, giv_ARR, "pjdeplocarr");
    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_ARR, giv_ARR, "deplocarr");
    }

    /* deplocarrextra */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_ARR, giv_LOC, "pjdeplocarrextra");
    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_ARR, giv_LOC, "deplocarrextra");
    }

    /* Pour deploc */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_LOC, giv_LOC, "pjdeploc");
    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_LOC, giv_LOC, "deploc");
    }

    /* Pour deploczoneurbaine */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_LOC, giv_ZU, "pjdeploczoneurbaine");

    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_LOC, giv_ZU, "deploczoneurbaine");
    }

    /* Pour deplocZuv */

    iIntRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_LOC, giv_ZV, "pjdeplocZuv");

    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_LOC, giv_ZV, "deplocZuv");
    }

    /* Pour deplocextraloc */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_LOC, giv_DEPT, "pjdeplocextraloc");
    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_LOC, giv_DEPT, "deplocextraloc");
    }

    /* deplocarrextraloc */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_ARR, giv_DEPT, "pjdeplocarrextraloc");
    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_ARR, giv_DEPT, "deplocarrextraloc");
    }

    /* deplocuv */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_LOC, giv_UV, "pjdeplocuv");
    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_LOC, giv_UV, "pjdeplocuv");
    }

    /* deplocarruv */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_ARR, giv_UV, "pjdeplocarruv");
    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_ARR, giv_UV, "pjdeplocarruv");
    }

    /* Pour deplocextradep */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_LOC, giv_EXTL, "pjdeplocextradep");
    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_LOC, giv_EXTL, "deplocextradep");
    }

    /* deplocarrextradep */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_ARR, giv_EXTL, "pjdeplocarrextradep");
    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_ARR, giv_EXTL, "deplocarrextradep");
    }

    /* Pour dep */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_DEPT, giv_DEPT, "pjdep");
    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_DEPT, giv_DEPT, "dep");
    }


    /* Pour depextra */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_DEPT, giv_EXTL, "pjdepextra");
    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_DEPT, giv_EXTL, "depextra");
    }

    /* Pour reg */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_REG, giv_REG, "pjreg");
    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_REG, giv_REG, "reg");
    }

    /* Pour regextra */

    iRet = giv_ecrit_partie_3_geo (&buf_pos, docClone, jRef, m, giv_REG, giv_EXTL, "pjregextra");
    if ((GWCCodeOK == iRet) && (giv_RUB == iTri))
    {
      iRet = giv_ecrit_partie_3_an9 (&buf_pos, docClone, mm, giv_REG, giv_EXTL, "regextra");
    }

    if (giv_RUB == iTri)
    {
      lg_write = giv_ecrit_fin_noeud(&buf_pos,"parutionrubriques");
    }
    else if (giv_DNOM == iTri)
    {
      lg_write = giv_ecrit_fin_noeud(&buf_pos,"parutiondenoms");
    }
    else if (giv_OBJ == iTri)
    {
      lg_write = giv_ecrit_fin_noeud(&buf_pos,"parutionobjets");
    }
    buf_pos = buf_pos + lg_write;

    /* tri suivant */
  }

  *buf_pos_in=buf_pos;

  return(iCodRet);

} /* Fin ecrit partie_3  */



/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  :giv_sortie_ISO ()                                               */
/*                                                                            */
/* But       : écriture ISO du fichier de sortie                              */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 giv_sortie_ISO (char **buf_pos_in, FILE *afDescFic)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */
  int4 lg_a_ecrire = 0;
  char *buf_pos;

  /* Calcul de la longueur a ecrire */
  lg_a_ecrire = strlen(GIVBuffXML);

  GWTTrace (GWT_NIV_FONCT, ("Enrichissement %d,%d \n",giviEnrich,giviCodRetEcr));
  if ((NULL != afDescFic) && (0 != lg_a_ecrire) && ((int4)GIXCodeOK == giviCodRetEcr))
  {
    GWTTrace (GWT_NIV_FONCT, ("On passe dans l'ecriture du fichier de sortie ISO \n"));

    /* ecriture de l'enregistrement dans le fichier de sortie */
    GWTTrace (GWT_NIV_FONCT, ("Taille du buff a ecrire dans le fic XML : %d\n", lg_a_ecrire));

    /* Conversion du buffer avant écriture dans le fichier */
    givTradChar(&lg_a_ecrire);
    /* ecriture de l'enregistrement dans le fichier de sortie */
    GWTTrace (GWT_NIV_FONCT, ("Taille du buff UTF8 a ecrire dans le fic XML : %d,%d\n", strlen(GIVBuffTest),lg_a_ecrire));

    if ((int4)GIXCodeOK != giviEnrich)
    {
      /* Ecriture dans le fichier de sortie */
      iIntRet = (int4)fwrite ( GIVBuffXML, lg_a_ecrire, 1, afDescFic);
    }
    /* utilisation du buffer de cas de test */
    else if ((strlen(GIVBuffTest) + strlen(GIVBuffXML)) > giv_LG_BUFFTEST)
    {
      GWTTrace(GWT_NIV_GRAVE, ("Erreur : taille du bloc %d supérieure à %d octets\n",(strlen(GIVBuffTest) + strlen(GIVBuffXML)),giv_LG_BUFFTEST));
      giviCodRetEcr = (int4)GIXCodeKO;
    }
    else
    {
      strcat(GIVBuffTest,GIVBuffXML);
      iIntRet = 1;
    }

    if (1 != iIntRet)
    {
      /*  Erreur d'ecriture mouvement CD */
      GWTTrace (GWT_NIV_FONCT, ("Erreur ecriture sur fichier MCD : [ERR=%02Xh]\n", errno));
      GWTTrace (GWT_NIV_FONCT, ("Erreur ecriture sur fichier MCD, code retour fwrite : %d\n", iIntRet));
      iCodRet = (int4)GIXCodeKO;
    }

  }
  if ((GIVfDescFicBloc == afDescFic) && (GIVfDescFicMCD != GIVfDescFicBloc) && (0 != lg_a_ecrire))
  {
    /* Ecriture dans le fichier de sortie */
    iIntRet = (int4)fwrite ( GIVBuffXML, lg_a_ecrire, 1, GIVfDescFicMCD);

    if (1 != iIntRet)
    {
      /*  Erreur d'ecriture mouvement CD */
      GWTTrace (GWT_NIV_FONCT, ("Erreur ecriture sur fichier MCD : [ERR=%02Xh]\n", errno));
      GWTTrace (GWT_NIV_FONCT, ("Erreur ecriture sur fichier MCD, code retour fwrite : %d\n", iIntRet));
      iCodRet = (int4)GIXCodeKO;
    }
  }
  /* Effacement du buffer */
  GIVBuffXML[0] = '\0';
  /* Pointeur sur debut du buffer */
  buf_pos = GIVBuffXML;
  *buf_pos_in = buf_pos;

  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  :giv_sortie_ ()                                               */
/*                                                                            */
/* But       : écriture du fichier de sortie format inchangé                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 giv_sortie (char **buf_pos_in, FILE *afDescFic)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */
  int4 lg_a_ecrire = 0;
  char *buf_pos;

  /* Calcul de la longueur a ecrire */
  lg_a_ecrire = strlen(GIVBuffXML);

  GWTTrace (GWT_NIV_FONCT, ("Enrichissement %d,%d \n",giviEnrich,giviCodRetEcr));
  if ((NULL != afDescFic) && (0 != lg_a_ecrire) && ((int4)GIXCodeOK == giviCodRetEcr))
  {
    GWTTrace (GWT_NIV_FONCT, ("On passe dans l'ecriture du fichier de sortie UTF8 \n"));

    /* ecriture de l'enregistrement dans le fichier de sortie */
    GWTTrace (GWT_NIV_FONCT, ("Taille du buff a ecrire dans le fic XML : %d\n", lg_a_ecrire));
    if ((int4)GIXCodeOK != giviEnrich)
    {
    /* Ecriture dans le fichier de sortie */
      iIntRet = (int4)fwrite ( GIVBuffXML, lg_a_ecrire, 1, afDescFic);
    }
    /* utilisation du buffer de cas de test */
    else if ((strlen(GIVBuffTest) + strlen(GIVBuffXML)) > giv_LG_BUFFTEST)
    {
      GWTTrace(GWT_NIV_GRAVE, ("Erreur : taille du bloc %d supérieure à %d octets\n",(strlen(GIVBuffTest) + strlen(GIVBuffXML)),giv_LG_BUFFTEST));
      giviCodRetEcr = (int4)GIXCodeKO;
    }
    else
    {
      strcat(GIVBuffTest,GIVBuffXML);
      iIntRet = 1;
    }

    if (1 != iIntRet)
    {
      /*  Erreur d'ecriture mouvement CD */
      GWTTrace (GWT_NIV_FONCT, ("Erreur ecriture sur fichier MCD : [ERR=%02Xh]\n", errno));
      GWTTrace (GWT_NIV_FONCT, ("Erreur ecriture sur fichier MCD, code retour fwrite : %d\n", iIntRet));
      iCodRet = (int4)GIXCodeKO;
    }


  }
  if ((GIVfDescFicBloc == afDescFic) && (GIVfDescFicMCD != GIVfDescFicBloc) && (0 != lg_a_ecrire))
  {
    /* Ecriture dans le fichier de sortie */
    iIntRet = (int4)fwrite ( GIVBuffXML, lg_a_ecrire, 1, GIVfDescFicMCD);

    if (1 != iIntRet)
    {
      /*  Erreur d'ecriture mouvement CD */
      GWTTrace (GWT_NIV_FONCT, ("Erreur ecriture sur fichier MCD : [ERR=%02Xh]\n", errno));
      GWTTrace (GWT_NIV_FONCT, ("Erreur ecriture sur fichier MCD, code retour fwrite : %d\n", iIntRet));
      iCodRet = (int4)GIXCodeKO;
    }
  }

  /* Effacement du buffer */
  GIVBuffXML[0] = '\0';
  /* Pointeur sur debut du buffer */
  buf_pos = GIVBuffXML;
  *buf_pos_in = buf_pos;

  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givFin ()                                                      */
/*                                                                            */
/* But       : Fin de tous les blocs                                          */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) : la structure XML d'un bloc                                     */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 givFin (char **buf_pos_in, char *blocid)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_write;
  char *buf_pos;
  int4 iIntRet = GWCCodeOK;

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  if ((int4)GWCCodeOK == iCodRet)
  {GWTTrace (GWT_NIV_FONCT, ("Fin ECRITURE PARTIE_3 ..debut Fin.\n")); }


  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    if (0 == strcmp("OUI",givtcContenu))
    {
      iIntRet = (int4)giv_sortie_ISO ( &buf_pos, GIVfDescFicMCD );
    }
    else
    {
      iIntRet = giv_fichier_sortie ( &buf_pos, &GIVfDescFicMCD );
    }
  }

  /* fermeture du fichier */
  iIntRet = (int4)giv_fermeture_fichier_sortie ( &buf_pos, blocid );
  if ((int4)GWCCodeOK != iIntRet)
  {
    GWTTrace (GWT_NIV_FONCT,("pas de fichier de sortie\n"));
     iCodRet = GWCCodeKO ;
  }

  *buf_pos_in=buf_pos;

  return(iCodRet);

} /* Fin Documents */

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  :giv_fichier_sortie ()                                          */
/*                                                                            */
/* But       : Creation du fichier de sortie pr chaque bloc de parution       */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 giv_fichier_sortie (char **buf_pos_in, FILE **apfDescFic)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */
  char    cChemin[128] = "";               /* Pathname des fichiers utilises */
  char    cNomFichier[128] = "";           /* Pathname des fichiers utilises */
  char    cNomFichier1[256] = "";           /* Pathname des fichiers utilises */  char    cNomFichier3[256] = "";           /* Pathname des fichiers utilises */
  int4 lg_a_ecrire;                              /* Longueur du contenu de buffer : a ecrire */
  int4 lg_ecrit_entete = 0;
  char    cEntete_xml[100] = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>";
  char    cEntete_xml0[] = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>";
  char    cEntete_xml1[] = "<!DOCTYPE sgipro [";
  char    cEntete_xml2[] = "<!ENTITY euro   \"&#8364;\" >";
  char    cEntete_xml3[] = "<!ENTITY laquo   \"&#171;\" >";
  char    cEntete_xml4[] = "<!ENTITY raquo   \"&#187;\" >";
  char    cEntete_xml5[] = "<!ENTITY quot   \"&#34;\" >";
  char    cEntete_xml6[] = "]>";
  char *buf_pos;
  char tcNumMvt[GXWLgIdDonnees];
  char  *pcVersion = NULL;
  char          conf[50];

  GWTTrace (GWT_NIV_FONCT, ("On passe dans l'ecriture du fichier de sortie %d,%d,%d\n",num_id,giviNbBlocs,giviClose));
  buf_pos = *buf_pos_in;

  if ( (0 != num_id) && (0 == (num_id % giviNbBlocs)) && (-1 != giviNbBlocs) && ((int4)GIXCodeKO == giviClose) )
  {
    giviClose = (int4)GIXCodeOK;
    giviNumFic = giviNumFicInit + (num_id / giviNbBlocs);
  }

  if ((NULL == *apfDescFic) && (('\0' != GIVBuffXML[0]) || ((int4)GIXCodeKO == giviClose)))
  {
    /* nouveau fichier */

    /* Initialisation des variables locales */
    (void)memset ((void *)cChemin, 0x00, (size_t)sizeof(cChemin));
    (void)memset ((void *)cNomFichier, 0x00, (size_t)sizeof(cNomFichier));

    /* ouverture du fichier des mouvements CD2G */
    /* constitution du nom du fichier */
    /* constitution du nom du fichier Bloc */
    (void) sprintf(conf, "%s_%s","GXXPathCd2g",GIXcNomDest);
    iIntRet = GWTLireConf(conf,cChemin);
    if ( GWTok != iIntRet )
    {
      (void)strcpy(cChemin, "/DATA/DEPT/CD2G");
      GWTTrace(GWT_NIV_BIZAR,
               ("Pas de Path des mvts interne dans la conf. Valeur par defaut <%s> prise \n", cChemin));
    }

    if (-1 == giviNbBlocs)
    {
      (void) sprintf(&cNomFichier[0], "%s/%s/%s.%s.%s.xml", cChemin, givcRepertoire, GIXtcNomFichier, GIXcNomDest, givcRepertoire);
      (void) sprintf(&cNomFichier1[0], "%s/%s/CFLT.%s.%s.%s.xml", cChemin, givcRepertoire, GIXtcNomFichier, GIXcNomDest, givcRepertoire);
      (void) sprintf(&cNomFichier3[0], "%s/%s/ETB.%s.%s.%s", cChemin, givcRepertoire, GIXtcNomFichier, GIXcNomDest, givcRepertoire);
    }
    else
    {
      (void) sprintf(&cNomFichier[0], "%s/%s/%s.%s.%s.%d.xml", cChemin, givcRepertoire, GIXtcNomFichier, GIXcNomDest, givcRepertoire, giviNumFic);
      (void) sprintf(&cNomFichier1[0], "%s/%s/CFLT.%s.%s.%s.%d.xml", cChemin, givcRepertoire, GIXtcNomFichier, GIXcNomDest, givcRepertoire, giviNumFic);
      (void) sprintf(&cNomFichier3[0], "%s/%s/ETB.%s.%s.%s.%d", cChemin, givcRepertoire, GIXtcNomFichier, GIXcNomDest, givcRepertoire, giviNumFic);
    }

    GWTTrace(GWT_NIV_FONCT,
             ("Nom fichier mouvements CD2G <%s>\n", cNomFichier));

    /* Ouverture fichier des mouvements CD2G */
    *apfDescFic = fopen64 (cNomFichier,
                              GIV_FCREAT);

    if (NULL == *apfDescFic)
    {
      /* Echec ouverture fichier mouvements => erreur */
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur FOPEN fichier mouvements CD : [ERR=%02Xh, PTH=%s]\n", errno, cNomFichier));
      iCodRet = (int4)GIXCodeKO;
    }

    GIVfDescFicCFLT = NULL;

    GIVfDescFicETB = NULL;

    /* Preparation du header XML dans le fichier de sortie */
    strcpy (buf_concat,cEntete_xml0);
    lg_ecrit_entete = strlen(cEntete_xml0);
    *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;
    *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;
    lg_ecrit_entete = lg_ecrit_entete + 2;
    strcpy (&buf_concat[lg_ecrit_entete],cEntete_xml1);
    lg_ecrit_entete += strlen(cEntete_xml1);
    *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;
    *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;
    lg_ecrit_entete = lg_ecrit_entete + 2;
    strcpy (&buf_concat[lg_ecrit_entete],cEntete_xml2);
    lg_ecrit_entete += strlen(cEntete_xml2);
    *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;
    *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;
    lg_ecrit_entete = lg_ecrit_entete + 2;
    strcpy (&buf_concat[lg_ecrit_entete],cEntete_xml3);
    lg_ecrit_entete += strlen(cEntete_xml3);
    *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;
    *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;
    lg_ecrit_entete = lg_ecrit_entete + 2;
    strcpy (&buf_concat[lg_ecrit_entete],cEntete_xml4);
    lg_ecrit_entete += strlen(cEntete_xml3);
    *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;
    *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;
    lg_ecrit_entete = lg_ecrit_entete + 2;
    strcpy (&buf_concat[lg_ecrit_entete],cEntete_xml5);
    lg_ecrit_entete += strlen(cEntete_xml5);
    *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;
    *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;
    lg_ecrit_entete = lg_ecrit_entete + 2;
    strcpy (&buf_concat[lg_ecrit_entete],cEntete_xml6);
    lg_ecrit_entete += strlen(cEntete_xml6);
    *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;
    *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;
    lg_ecrit_entete = lg_ecrit_entete + 2;

    /* Ajout de la ligne <operations> */
    strcpy (&buf_concat[lg_ecrit_entete], "<OPERATIONS>");

    lg_ecrit_entete = strlen(buf_concat);
    *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;
    *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;
    *(buf_concat + lg_ecrit_entete + 2) = '\0';
    lg_ecrit_entete = lg_ecrit_entete + 2;

    /* ecriture du contenu du header dans le fichier de sortie */
    iIntRet = (int4)fwrite (buf_concat, lg_ecrit_entete, 1, *apfDescFic);
    if ( 1 != iIntRet )
    {
      /* probleme d'ecriture de l'entete */
      GWTTrace(GWT_NIV_GRAVE,
               ("Probleme d'ecriture de l'entete pour le dept [%s]\n",
                GIXcDepartement));
      iCodRet = GIXCodeKO;
    }

    /* Init buffer de cas de test */
    GIVBuffTest[0] = '\0';

  }


  if ( ((int4)GWCCodeOK == iCodRet) && ('\0' != GIVBuffXML[0]) )
  {
    /* Ecriture dans le fichier de sortie */
    iIntRet = (int4)giv_sortie_ISO ( &buf_pos, *apfDescFic );
  }

  *buf_pos_in = buf_pos;

  return (iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  :giv_fichier_sortie_cflt ()                                      */
/*                                                                            */
/* But       : Creation du fichier de sortie de conflit                       */
/*             de balise de contenu selon priorité                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 giv_fichier_sortie_cflt (int4 aiRg, GYBrDOCUMENT *doc,   GYBrPrioCRCT *prPrioCRC)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */
  char buf[200];
  int4 lg_ecrit = 0;

  GWTTrace (GWT_NIV_FONCT, ("On passe dans l'ecriture du fichier de conflit \n"));

  strcpy(&buf[0],"SCG");
  strcat(buf, "|");
  strcat(buf,doc->parution_id);
  strcat(buf, "|");
  strcat(buf,doc->value.numero_client);
  strcat(buf, "|");
  /* source prioritaire pour le bloc */
  strcat(buf,givrListCRC.trEltList[aiRg].acTpdsob);
  strcat(buf, "|");
  strcat(buf,givrListCRC.trEltList[aiRg].acEtab);
  strcat(buf, "|");
  /* critère non prioritaire pour le bloc */
  strcat(buf,prPrioCRC->acTpdsob);
  strcat(buf, "|");
  strcat(buf,prPrioCRC->acEtab);
  strcat(buf, "|");
  strcat(buf,prPrioCRC->acCodan8);
  strcat(buf, "|");
  strcat(buf,prPrioCRC->acCRC);

  lg_ecrit = strlen(buf);
  buf[lg_ecrit] = SEPARE_LIGNE;
  buf[lg_ecrit + 1] = LINE_FEED;
  buf[lg_ecrit + 2] = '\0';
  lg_ecrit += 2;

  /* ecriture du contenu dans le fichier de sortie */
  iIntRet = (int4)fwrite (buf, lg_ecrit, 1, GIVfDescFicCFLT);
  if ( 1 != iIntRet )
  {
    /* probleme d'ecriture */
    GWTTrace(GWT_NIV_GRAVE,
             ("Probleme d'ecriture de conflit [%s]\n",
              doc->parution_id));
    iCodRet = GIXCodeKO;
  }

  return (iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction :  givTriGeoIns
 *
 * But : Tri des codes géographiques par inscription
 *
 * Description :
 * Fonction de tri des réponses en fonction d'un critère qui précise l'ordre
 * de priorité des tris
 *
 * Portabilité : sûrement portable
 *
 * Interface :
 *
 *	Paramètres :
 *
 *	Valeurs retournées :
 *
 *	Erreurs :
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Jan/29/2008  (mb)
 *
 * Modification   (MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givTriGeoIns(GYBrDOCUMENT *doc, int4 indice)
{

  int4 iCodRet;     /* Code retour de la fonction */
  int4 iIntRet;     /* Code retour interne */
  int4 iGeoArr,iGeoArrInst,iGeoLoc,iGeoDept,iGeoReg;
  int4 i,j,k,q;
  int4 pipe;
  char tcCoddep [3+1];
  char tcCodloc [5+1];
  char tcLocfus [5+1];
  /* Initialisation des variables locales */
  iCodRet = (int4)GIXCodeOK;
  iIntRet = (int4)GIXCodeOK;


  /* une seule installation traitée avec éventuellement plusieurs arr */

  if ((0 != strlen(doc->value.rubriques.depact)) && (0 != strlen(doc->value.rubriques.locact)))
  {
    /* utilisation des données d'activité */
    strcpy(doc->value.inscription[0].cCoddep, doc->value.rubriques.depact);
    strcpy(doc->value.inscription[0].cCodloc, doc->value.rubriques.locact);
  }

  if (0 != strlen(doc->value.inscription[0].cCoddep))
  {
    (void)strcpy(tcCoddep,doc->value.inscription[0].cCoddep);
    if (0 != strcmp (givcLocFictive,doc->value.inscription[0].cCodloc))
    {
      (void)strcpy(tcCodloc,doc->value.inscription[0].cCodloc);
    }
    else
    {
      (void)strcpy(tcCodloc,givcLocIndf);
    }
  }
  else if ((0 == strlen(doc->value.inscription[0].cCoddep)) && (0 != strcmp (givcDepFictif,doc->value.inscription[0].cDeppar)))
  {
    (void)strcpy(tcCoddep,doc->value.inscription[0].cDeppar);
    if (0 != strcmp (givcLocFictive,doc->value.inscription[0].cLocpar))
    {
      (void)strcpy(tcCodloc,doc->value.inscription[0].cLocpar);
    }
    else
    {
      (void)strcpy(tcCodloc,givcLocIndf);
    }
  }
    (void)strcpy(tcLocfus,doc->value.inscription[0].cLocFus);
    givrListInst.iNbr = 1;
    givrListInst.trEltRangList[0] = 0;
    strcpy(givrListInst.trEltList[0].dep, tcCoddep);
    strcpy(givrListInst.trEltList[0].loc, tcCodloc);
    strcpy(givrListInst.trEltList[0].arr, "99");
    givrListInst.trEltList[0].iGeoReg = 99;
    givrListInst.trEltList[0].iGeoDept = 99;
    givrListInst.trEltList[0].iGeoLoc = 99;
    givrListInst.trEltList[0].iGeoArr = 99;
    givrListInst.trEltList[0].iRangTri = (int4)0;

    if (0 != strlen(doc->value.rubriques.arract))
    {
      strcpy(givrListInst.trEltList[0].arr, doc->value.rubriques.arract);
    }
    else if (0 != strlen(doc->value.inscription[0].adresse.arrondissement))
    {
      strcpy(givrListInst.trEltList[0].arr, doc->value.inscription[0].adresse.arrondissement);
    }
    if (0 != strlen (doc->value.inscription[0].cLocFus))
    {
    	memcpy(&givrListInst.trEltList[givrListInst.iNbr],&givrListInst.trEltList[0], sizeof(givrEltListT));
      (void)strcpy(givrListInst.trEltList[givrListInst.iNbr].loc,doc->value.inscription[0].cLocFus);
      givrListInst.trEltRangList[givrListInst.iNbr] = givrListInst.iNbr;
      givrListInst.iNbr++;
    }

  givrListInst.iNbrTot = givrListInst.iNbr;
  iGeoArrInst = giv_INIT_ARR;
  for ( i = 0 ; i < givrListParu.iNbr ; i++)
  {
    /* comparaison Parution/Installation */

    iGeoReg = 99;
    iGeoDept = 99;
    iGeoLoc = 99;
    iGeoArr = 99;
    k = givrListParu.trEltRangList[i];

    if ((0 == strcmp(doc->value.inscription[0].cReg, givrListParu.trEltList[k].reg))
    	|| (0 == strcmp(doc->value.inscription[0].cAncReg, givrListParu.trEltList[k].reg)))
    {
      /* même région */
      iGeoReg = giv_REG;

      if (0 == strcmp(tcCoddep, givrListParu.trEltList[k].dep))
      {
        iGeoDept = giv_DEPT;
        if ((0 == strcmp(tcCodloc, givrListParu.trEltList[k].loc))
          || (0 == strcmp(tcLocfus, givrListParu.trEltList[k].loc)))
        {
          /* inscription locale */
          iGeoLoc = giv_LOC;
          /* inscription locale : arr */

          for ( j = 0 ; ((j < givrListInst.iNbr) && (0 == strcmp(tcCodloc, givrListParu.trEltList[k].loc))); j++)
          {
            if ((0 != strcmp("99",givrListInst.trEltList[j].arr)) && ((int4)GIXCodeOK != givrListParu.trEltList[k].iZU))
            {
              iGeoArrInst = giv_ARR;
            }
            if (0 == strcmp(givrListInst.trEltList[j].arr,givrListParu.trEltList[k].arr))
            {
              break;
            }
          }

          if (givrListInst.iNbr != j)
          {
            /* même arrondissement */
            /* inscription locale : arr */
            if (0 != strcmp("99",givrListParu.trEltList[k].arr))
            {
              iGeoArr = giv_ARR;
            }
          }
          else
          {
            /* arr inst != arr paru */
            /* différents arrondissements */
            if (0 != strcmp("99",givrListParu.trEltList[k].arr))
            {
              iGeoArr = giv_LOC;
            }
            /* inscription locale : arr extra */
          }
        }
        else
        {
          /* inscription départementale */
          /* loc inst != loc paru */
          /* différentes localités */
          iGeoLoc = giv_DEPT;
          if (0 != strcmp("99",givrListParu.trEltList[k].arr))
          {
            iGeoArr = giv_DEPT;
          }
          /* inscription dept : loc extra */
        }
      }

      else
      {
        /* inscription extra départementale */
        iGeoDept = giv_EXTL;
        iGeoLoc = giv_EXTL;
        if (0 != strcmp("99",givrListParu.trEltList[k].arr))
        {
          iGeoArr = giv_EXTL;
        }
        /* inscription régionale */
      }
    }
    else
    {
      /* différentes régions */
      /* inscription extra départementale */
      iGeoDept = giv_EXTL;
      iGeoLoc = giv_EXTL;
      if (0 != strcmp("99",givrListParu.trEltList[k].arr))
      {
        iGeoArr = giv_EXTL;
      }
      /* inscription extra-régionale */
      iGeoReg = giv_EXTL;

    }

    /* pas d'arrondissement pour le pôle de zone urbaine */
    if (0 == strcmp("00",givrListParu.trEltList[k].arr))
    {
      iGeoArr = 99;
    }

    if (0 == strcmp("999",givrListParu.trEltList[k].dep))
    {
    	/* ancienne région : seule la parution sur région est validée */
      iGeoDept = giv_DFT;
      iGeoLoc = giv_DFT;
      iGeoArr = giv_DFT;
    }

    /* Validation iGeo */
      /* changement de reg */
      givrListParu.trEltList[k].iGeoReg = iGeoReg;
      /* changement de dept */
      givrListParu.trEltList[k].iGeoDept = iGeoDept;
      /* changement de loc */
      givrListParu.trEltList[k].iGeoLoc = iGeoLoc;
      /* changement d'arr */
      givrListParu.trEltList[k].iGeoArr = iGeoArr;
  }

  /* changement d'arr instal */
  for ( j = 0 ; j < givrListInst.iNbr ; j++)
  {
    if (0 != strcmp("99",givrListInst.trEltList[j].arr))
    {
       givrListInst.trEltList[j].iGeoArr = iGeoArrInst;
    }
  }

    GWTTrace (GWT_NIV_FONCT, (" Inscription [%s],[%s],[%s],[%s]\n", doc->value.inscription[0].cReg, doc->value.inscription[0].cCoddep,doc->value.inscription[0].cCodloc, doc->value.inscription[0].cArrond));
    GWTTrace (GWT_NIV_FONCT, ("Parution-Installation Inscription [%d],[%d]\n", givrListParu.iNbr,givrListInst.iNbr));

/* Retourner sans erreur */
  return(iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  :giv_close_fichier_sortie ()                                          */
/*                                                                            */
/* But       : Fermeture du fichier de sortie                                 */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 giv_fermeture_fichier_sortie (char **buf_pos_in, char *blocid)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */
  char *buf_pos;
  int4 lg_a_ecrire;
  char tcNumMvt[GXWLgIdDonnees];
  char  *pcVersion = NULL;
  GWTTrace (GWT_NIV_FONCT, ("On passe dans l'ecriture du fichier de sortie \n"));
  buf_pos = *buf_pos_in;
  GYBrParam_erreurT	vErreurSQL;   /* Traitement des erreurs SQL */


  lg_a_ecrire = strlen(GIVBuffTest);

  if ((0 != lg_a_ecrire) && (NULL != GIVfDescFicMCD) && ((int4)GIXCodeOK != giviCodRetEcr) && ((int4)GIXCodeOK == giviEnrich))
  {
    GWTTrace(GWT_NIV_GRAVE, ("Erreur : bloc %s\n", blocid));
    /* Pas d'écriture buffer de cas de test : débordement */
    GIVBuffTest[0] = '\0';
  }
  else if ((0 != lg_a_ecrire) && (NULL != GIVfDescFicMCD) && ((int4)GIXCodeOK == giviEnrich))
  {
    GWTTrace (GWT_NIV_FONCT, ("Ecriture de BuffTest %d\n",lg_a_ecrire));
    /* Ecriture buffer de cas de test */
    iIntRet = (int4)fwrite ( GIVBuffTest, lg_a_ecrire, 1, GIVfDescFicMCD);
    GIVBuffTest[0] = '\0';
  }

  if (((int4)GIXCodeOK == giviClose) && (NULL != GIVfDescFicMCD))
  {
    /* Initialisation pointeur */
    buf_pos = GIVBuffXML;
    /* Calcul de la longueur a ecrire */
    lg_a_ecrire = giv_ecrit_fin_noeud(&buf_pos,"documents");

    /* ecriture de l'enregistrement dans le fichier de sortie */
    GWTTrace (GWT_NIV_FONCT, ("Taille du buff a ecrire dans le fic XML : %d\n", lg_a_ecrire));

    /* Ecriture dans le fichier de sortie */
    iIntRet = (int4)fwrite ( GIVBuffXML, lg_a_ecrire, 1, GIVfDescFicMCD);

    /* fichier rempli */
    iIntRet = fclose (GIVfDescFicMCD);
    if ( iIntRet != (int4)GWCCodeOK )
    {
      /* probleme de fermeture de fichier */
      GWTTrace(GWT_NIV_GRAVE,
               ("Probleme de fermeture de fichier \n"));
      iCodRet = GIXCodeKO;
    }
    GIVfDescFicMCD = NULL;

    if (NULL != GIVfDescFicCFLT)
    {
      iIntRet = fclose (GIVfDescFicCFLT);
      if ( iIntRet != (int4)GWCCodeOK )
      {
        /* probleme de fermeture de fichier */
        GWTTrace(GWT_NIV_GRAVE,
                 ("Probleme de fermeture de fichier \n"));
        iCodRet = GIXCodeKO;
      }
    }

    GIVfDescFicCFLT = NULL;
    if (NULL != GIVfDescFicETB)
    {
       iIntRet = fclose (GIVfDescFicETB);
      if ( iIntRet != (int4)GWCCodeOK )
      {
        /* probleme de fermeture de fichier */
        GWTTrace(GWT_NIV_GRAVE,
                 ("Probleme de fermeture de fichier \n"));
        iCodRet = GIXCodeKO;
      }
    }

    GIVfDescFicETB = NULL;
    GIViCommit = (int4)GIXCodeOK;
    giviClose = (int4)GIXCodeKO;
    /* Effacement du buffer */
    GIVBuffXML[0] = '\0';
    if ((0 == strcmp(givRecreerCD,GIXcNomIntf)) && (0 != strcmp(GIXcValUrg, GWZUrgent)))
    {
      /* Construction chaine de marquage reprise */
      (void)sprintf (tcNumMvt,
                     "%d-%s",
                     giviNumFic,
                     nom_bloc_ref);
      pcVersion = strchr(pcVersionInsFour[0], (char)'.');
      pcVersion++;
      GWTTrace(GWT_NIV_FONCT,
               ("Bloc reprise [%s]\n",
                tcNumMvt));

      /* Sauvegarde chaine de version dans referentiel */
      iIntRet = GHHModiVersionIeinscDest (GIXcDepartement,
                                          GIXcNomIntf,
                                          pcVersion,
                                          (char *)NULL,
                                          tcNumMvt,
                                          GIXcNomDest);

      if ((int4)GWZKo == iIntRet)
      {
        /* Erreur mise a jour donnees de version */
        GWTTrace (GWT_NIV_FONCT,
                  ("Erreur GHHModiVersionIeinsc ...\n"));
      }

    }

  }
  *buf_pos_in = buf_pos;

  return (iCodRet);
}



/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givInitBlocParution ()                                         */
/*                                                                            */
/* But       : Initialisation de la structure d'un bloc                       */
/*             XML a vide, avant réut                                         */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) : la structure XML d'un bloc                                     */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 givInitBlocParution (GYBrDOCUMENT *doc)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */


  /* Effacement de la zone de donnees */
  memset(doc, 0, sizeof(*doc));
  giviNbParentPart = 0;

  return(iCodRet);


} /* Fin IniBloc de parution */


/*----------------------------------Fonction----------------------------------*
 * Fonction :  givMefPnom
 *
 * But : Mise en forme du champ prénom
 *
 * Description :
 * Cette fonction récupère les initilaes du champ prénom de l'inscription
 *
 *---------------------------------Historique----------------------------------
 *
 * Création :	 Fev/07/2007  (mb)
 *
 * Modification	(MMM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

static int4 givMefPnom( char *aprPrenom, char *aprInit )
{
  /* code retour des fonctions appelées */
  int4 iCodRet = GWCCodeOK;
  /* Prénom obtenu dans l'inscription */
  char *pcPrenom;
  /* Mot courant du prénom ( spécifique au traitement des initiales ) */
  char tcMotCrt[ 128 ];
  int4 iLgPrenom, iBoucle;

  /* Récupération du prénom complet */
  pcPrenom = aprPrenom ;
  iLgPrenom = 0;

  /* Parcours de la liste des prénoms */
  while ( 1 == sscanf( pcPrenom, "%s", tcMotCrt ) )
  {
    GWTTrace (GWT_NIV_FONCT, ("Mot : %s\n", tcMotCrt));
    /* A la recherche du mot de liaison 'et'  qui doit figurer dans la réponse */
    /* Le blanc séparateur est systématiquement placé avant le mot de liaison */
      if ( ( 0 == strcmp( "ET", tcMotCrt ) ) || ( 0 == strcmp( "et", tcMotCrt ) ) || ( 0 == strcmp( "Et", tcMotCrt ) )  )
      {
        aprInit[iLgPrenom++] = ' ';
        memcpy(&aprInit[iLgPrenom],tcMotCrt,strlen(tcMotCrt));
        iLgPrenom += strlen(tcMotCrt);
      }
      else
      {
        /* Ou à la recherche de l'initiale qui peut être double dans le cas */
        /* des prénoms composés ( séparés par un tiret )                    */
        /* Le blanc séparateur est rajouté devant l'initiale sauf s'il      */
        /* s'agit du premier prénom de la liste traîté                      */
        /* Par contre les initiales d'un prénom composé sont collées        */
        iLgPrenom = strlen( aprInit );
        if ( 0 != iLgPrenom )
        {
          aprInit[ iLgPrenom ] = ' ';
          iLgPrenom ++;
        }
        aprInit[ iLgPrenom ] = tcMotCrt[0] ;
        iLgPrenom ++;
        for ( iBoucle = 0; iBoucle < strlen( tcMotCrt ); iBoucle ++ )
        {
          if ( '-' == tcMotCrt[ iBoucle ] )
          {
            aprInit[ iLgPrenom ] = tcMotCrt[ iBoucle + 1 ];
            iLgPrenom ++;
          }
        }
        aprInit[ iLgPrenom ] = 0;
      }

      /* Passage au prénom suivant dans la liste */
      if ( 0 != strcmp( pcPrenom, tcMotCrt ) )
      {
        pcPrenom += strlen ( tcMotCrt ) + 1;
      }
      else
      {
        break;
      }

    }


  /* Retourner sans erreur */
  return(iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givMefDonneesGestion ()                                        */
/*                                                                            */
/* But       : Mise en forme de l'ensemble "donnees de gestion"               */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 givMefDonneesGestion (GYBrDOCUMENT *doc, int4 indice)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */
  char         *pcFour  = NULL;
  char cBufSeq[sizeof(GIVvInscrip.acNoselo)+1+sizeof(GIVvInscrip.acNosels)] = "";
  int4           i;

  /* initialisation données locales */
  (void) memset(&cBufSeq[0], 0x00, sizeof(cBufSeq));


  /* on a qu'une inscription dans doc */
  indice=0;

  /* Encodage du numero national */
  /* le numéro de téléphone est transmis en clair */
  (void)strcpy(givcNumnat,cNumnat);

  strcpy(doc->value.inscription[indice].val_num, givcNumnat);
  GWTTrace (GWT_NIV_FONCT,
            ("No nat : %s\n", doc->value.inscription[indice].val_num));



  /* Encodage du numero de LO */
  usLgchamp = strlen(cNumlo);
  /* cas des numlo d'authentification = fournisseur, passer en numérique */
  pcFour = strstr(GIVcListeFour, cNumlo);
  if (NULL != pcFour)
  {
    /* c'est une inscription d'authentification */
    (void) sprintf(cNumlo, "%04d", ((pcFour - &GIVcListeFour[0]) / (GYBIeinscLgNumlo+1)) + 1);
  }

  /* Encodage du No Lo  */
  strcpy(doc->value.inscription[indice].val_lo, cNumlo);
  GWTTrace (GWT_NIV_FONCT,
            ("No Lo : %s\n", doc->value.inscription[indice].val_lo));


  /* Encodage du numero de LS */
  strcpy(doc->value.inscription[indice].val_ls, cNumls);
  GWTTrace (GWT_NIV_FONCT,
            ("No Ls : %s\n", doc->value.inscription[indice].val_ls));

  /* nature de l'inscription */
  doc->cNature = GIVvInscrip.acNature;
  if ( giv_cLEUR == doc->value.inscription[indice].val_num[0])
  {
  	/* partenaire leurre (origine PJ) */
  	doc->cNature = doc->value.inscription[indice].val_num[0];
  }
  /* partenaire */
  doc->cIndPart = GIVvInscrip.acIndPart[0];

  /* Encodage du numero de bloc précédent */
  if (0 == strcmp(cBlocidPrec,"C0001"))
  {
    /* chgmt 888 vers 999 */
    strcpy(doc->value.inscription[indice].trace_bloc,"888-999");
  }
  else if (0 == strcmp(cBlocidPrec,"C0002"))
  {
    /* chgmt 999 vers 888 */
    strcpy(doc->value.inscription[indice].trace_bloc,"999-888");
  }
  else
  {
    strcpy(doc->value.inscription[indice].trace_bloc, cBlocidPrec);
  }

  GWTTrace (GWT_NIV_FONCT,
            ("No Bloc trace : %s\n", doc->value.inscription[indice].trace_bloc));

  /* Encodage de la clé de tri */
  strcpy(doc->value.inscription[indice].val_tri1, &GIVvInscrip.acCleTri1[1]);
  GWTTrace (GWT_NIV_FONCT,
            ("Cle tri : %s\n", doc->value.inscription[indice].val_tri1));
  strcpy(doc->value.inscription[indice].val_tri2, &GIVvInscrip.acCleTri2[1]);
  GWTTrace (GWT_NIV_FONCT,
            ("Cle tri : %s\n", doc->value.inscription[indice].val_tri2));


  /* Encodage du numero de regroupement */
  if ((int4)GYBok ==  GIVvIndInscrip.sNogrouI && (boolen != 2))
  {
    strcpy(doc->value.inscription[indice].val_grp, GIVvInscrip.acNogrou);
    GWTTrace (GWT_NIV_FONCT,
              ("No grp : %s\n", doc->value.inscription[indice].val_grp));
  }
  else if ( boolen == 2)
  {
   strcpy(doc->value.inscription[indice].val_grp, nogrou_sav);
    GWTTrace (GWT_NIV_FONCT,
              ("No grp 2eme choix: %s\n", doc->value.inscription[indice].val_grp));
  }
  /* Encodage du numero de sequence LO/LS les deux concatenes */
  if ( 0 == strcmp(GIVvInscrip.acNumls , "0000"))
    strcpy(doc->value.inscription[indice].val_seq, GIVvInscrip.acNoselo);
  else
  {
    strcpy(&doc->value.inscription[indice].val_seq[1], GIVvInscrip.acNosels);
    doc->value.inscription[indice].val_seq[0] = '0';
  }
  strcpy(doc->value.inscription[indice].val_seqLO, GIVvInscrip.acNoselo);
  strcpy(doc->value.inscription[indice].val_seqLS, GIVvInscrip.acNosels);
  GWTTrace (GWT_NIV_FONCT,
            ("No seq : %s\n", doc->value.inscription[indice].val_seq));


  strcpy(doc->value.inscription[indice].val_lols, cNumlo);
  strcpy(doc->value.inscription[indice].val_lslo, cNumls);

  iCodRet = GWCCodeOK;

  /* Sortie de la fonction givMefDonneesGestion*/
  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givMefDonneesParution ()                                       */
/*                                                                            */
/* But       : Mise en forme de l'ensemble "donnees de parution"              */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Modification (Dec/03/2002 mb) : ajout de mention tarifaire                 */
/*----------------------------------------------------------------------------*/

static int4 givMefDonneesParution (GYBrDOCUMENT *doc, int4 aIndice)
{
  int4		iCodRet = GWCCodeOK;		/* Code retour de la fonction */
  int4		iIntRet = GWCCodeOK;		/* Code retour interne */

/* numéro de client */
  char givcNumcli[8];
  int4 i,j,k,lg;
  int4 iDept,iArrond;
  int4 iRes, iAcc;
  int4 indice;
  GYBrIapartT rPart;

  /* on a qu'une inscription dans doc */
  indice=0;
  /* indicateur de protection */
  strcpy(doc->value.intitule.protection, GIVvInscrip.acInprot);
  /* indicateur de support */
  strcpy(doc->value.intitule.support, GIVvInscrip.acInsupp);

  /* Encodage de la designation de ligne  */
  if ((int4)GYBok ==  GIVvIndInscrip.sDesignI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.designation_ligne, GIVvInscrip.acDesign);
    GWTTrace (GWT_NIV_FONCT,
              ("DESIGNATION DE LIGNE : %s\n", doc->value.inscription[indice].moyen_de_com.designation_ligne));
  }

  /* Encodage du numero de client  */
  if ((int4)GYBok ==  GIVvIndInscrip.sNumcliI)
  {
    memcpy(&givcNumcli[0],&GIVvInscrip.acNumcli[4], 8);
    givcNumcli[8]='\0';
    strcpy(doc->value.numero_client, givcNumcli);
    GWTTrace (GWT_NIV_FONCT,
              ("No_CLIENT : %s\n", doc->value.numero_client));
  }


  /* Encodage du numero du code etablissement */
  if ((int4)GYBok ==  GIVvIndInscrip.sEtabI)
  {
    strcpy(doc->value.a_classer.etab_dc, GIVvInscrip.acEtab);
    strcpy(doc->value.a_classer.etab, GIVvInscrip.acEtab);
    GWTTrace (GWT_NIV_FONCT,
              ("ETAB : %s\n", doc->value.a_classer.etab));
  }

  /* Encodage du numero de code SIRET */
  if ((int4)GYBok ==  GIVvIndInscrip.sSiretI)
  {
    strcpy(doc->value.a_classer.siret, GIVvInscrip.acSiret);
    GWTTrace (GWT_NIV_FONCT,
              ("SIRET : %s\n", doc->value.a_classer.siret));
  }


  /* Encodage du numero du code NAF */
  if ((int4)GYBok ==  GIVvIndInscrip.sNafI)
  {
    for ( i = 0 ; i < (strlen(GIVvInscrip.acNaf)-1) ; i++)
    {
      if (0 == isdigit(GIVvInscrip.acNaf[i]))
      {
        break;
      }
    }
    if ((i != (strlen(GIVvInscrip.acNaf)-1))
        || ('A' > GIVvInscrip.acNaf[strlen(GIVvInscrip.acNaf)-1])
         || ('Z' < GIVvInscrip.acNaf[strlen(GIVvInscrip.acNaf)-1]))
    {
      strcpy(doc->value.a_classer.naf, "");
    }
    else
    {
      strcpy(doc->value.a_classer.naf, GIVvInscrip.acNaf);
    }
    GWTTrace (GWT_NIV_FONCT,
              ("NAF : %s\n", doc->value.a_classer.naf));
  }

  GWTTrace (GWT_NIV_FONCT,
              ("Nb IaPart : %d\n", GIViNbTupleIapart));
  if (0 != GIViNbTupleIapart)
  {
    iRes = 0;
    iAcc = 0;
    for(i=0; i< GIViNbTupleIapart; i++)
    {
    	if ((0 == strcmp(GIVtrPart[i].acOriPart,giv_RESA)) && (NULL == strstr(givtcFourPart,GIVtrPart[i].acOriPart)))
    	{
        iRes = 1;
    	}
    	else if ((0 == strcmp(GIVtrPart[i].acOriPart,giv_ACCO)) && (NULL == strstr(givtcFourPart,GIVtrPart[i].acOriPart)))
    	{
        iAcc = 1;
        break;
    	}
    }
    j = 0;
    for(i=0; i< GIViNbTupleIapart; i++)
    {
      if ((NULL == strstr(givtcFourPart,GIVtrPart[i].acOriPart)) || ('0' != GIVvInscrip.acIndPart[0]))
      {
      	if ((1 == iAcc) && ((0 == strcmp(GIVtrPart[i].acOriPart,giv_RESA))
      		|| (0 == strcmp(GIVtrPart[i].acOriPart,giv_EXPD))))
      	{
          GWTTrace (GWT_NIV_FONCT,
          ("Part resa/expd non prioritaire : %s, %s\n", GIVtrPart[i].acRefPart,doc->value.a_classer.etab));
      		continue;
      	}
      	else if ((1 == iRes) && (0 == strcmp(GIVtrPart[i].acOriPart,giv_EXPD)))
      	{
          GWTTrace (GWT_NIV_FONCT,
          ("Part expd non prioritaire : %s, %s\n", GIVtrPart[i].acRefPart,doc->value.a_classer.etab));
      		continue;
      	}
      	else if (0 == strcmp(GIVtrPart[i].acOriPart,rPart.acOriPart))
      	{
          GWTTrace (GWT_NIV_FONCT,
          ("Part expd double non prioritaire : %s, %s\n", GIVtrPart[i].acRefPart,doc->value.a_classer.etab));
      		continue;
      	}
        strcpy(rPart.acOriPart, GIVtrPart[i].acOriPart);
        doc->value.a_classer.trpart[j].iForPJDC = GIXCodeKO;
        strcpy(doc->value.a_classer.trpart[j].rpart, GIVtrPart[i].acRefPart);
        strcat(doc->value.a_classer.trpart[j].rpart, GIVtrPart[i].acOriPart);
        strcpy(doc->value.a_classer.trpart[j].parent, GIVtrPart[i].acParentRefPart);
        for(k=0; (k< givNbPart && (0 != strcmp(GIVtrPart[i].acOriPart,givTabPart[k].tcPart))); k++);
        if (givNbPart == k)
        {
        	doc->value.a_classer.trpart[j].prod[0] = '\0';
        }
        else
        {
          strcpy(doc->value.a_classer.trpart[j].prod, givTabPart[k].tcProd);
        }
        GWTTrace (GWT_NIV_FONCT,
                ("Part : %s,%s\n", doc->value.a_classer.trpart[j].rpart, doc->value.a_classer.trpart[j].prod));
        j++;
      }
    }
    GIViNbTupleIapart = j;
  }
  doc->value.a_classer.iNbPart = GIViNbTupleIapart;

  /* Encodage du titre de civilite */
  if ((int4)GYBok !=  GIVvIndInscrip.sCivilI)
  {
    /* valeur par defaut : pas de titre de civilité */
    (void)strcpy(GIVvInscrip.acCivil, " ");
  }
  (void)strcpy(doc->value.intitule.civilite, GIVvInscrip.acCivil);
  GWTTrace (GWT_NIV_FONCT,
            ("CIVILITE : %s\n",doc->value.intitule.civilite));


  /* Encodage de la denomination */
  if ((int4)GYBok ==  GIVvIndInscrip.sDenomI)
  {
    strcpy(doc->value.intitule.denomination, GIVvInscrip.acDenom);
    GWTTrace (GWT_NIV_FONCT,
              ("DENOMINATION : %s\n", doc->value.intitule.denomination));
  }


  /* Encodage du complement de denomination */
  if ((int4)GYBok ==  GIVvIndInscrip.sComplnI)
  {
    strcpy(doc->value.intitule.complement_denomination, GIVvInscrip.acCompln);
    GWTTrace (GWT_NIV_FONCT,
              ("COMP_DENOMINATION : %s\n",doc->value.intitule.complement_denomination));
  }


  /* Encodage du sigle */
  if ((int4)GYBok ==  GIVvIndInscrip.sSigleI)
  {
    strcpy(doc->value.intitule.sigle, GIVvInscrip.acSigle);
    GWTTrace (GWT_NIV_FONCT,
              ("SIGLE : %s\n",doc->value.intitule.sigle));
  }



  /* Encodage des mots determinants */
  if ((int4)GYBok ==  GIVvIndInscrip.sMotdetI)
  {
    strcpy(doc->value.intitule.mots_determinants, GIVvInscrip.acMotdet);
    GWTTrace (GWT_NIV_FONCT,
              ("MOTDET : %s\n",doc->value.intitule.mots_determinants));
  }

  /* Obtention de la longueur du champ "mots_determinants" */
  lg = strlen(doc->value.intitule.mots_determinants);

  /* Dans le cas où il y a un contenu, il faut retirer les caractères "<" éventuellement présents à la fin */
  /* Il s'agit de la règle : Reg_Sel_3 */
  if (lg > 0)
  {
    for (i = lg - 1 ; i >= 0 ; i--)
    {
      if (doc->value.intitule.mots_determinants[i] == '<')
      {
        doc->value.intitule.mots_determinants[i] = 0x00;
      }
      else
      {
        break;
      }
    }
  }
  /* Fin de règle : Reg_Sel_3 */


  /* Encodage du prenom */
  if ((int4)GYBok ==  GIVvIndInscrip.sPrenomI)
  {
    memset(buf_concat, 0, sizeof(buf_concat));
    iIntRet = givMefPnom(GIVvInscrip.acPrenom, buf_concat);
    if (givcParuIPre != GIVvInscrip.acInparu[givcIndInitPre])
    {
      strcpy(doc->value.intitule.prenom, GIVvInscrip.acPrenom);
    }
    else
    {
      strcpy(doc->value.intitule.prenom, buf_concat);
    }
    GWTTrace (GWT_NIV_FONCT,
              ("PRENOM : %s\n",doc->value.intitule.prenom));
    strcpy(doc->value.intitule.initiale, buf_concat);
    GWTTrace (GWT_NIV_FONCT,
              ("INITIALE : %s\n",doc->value.intitule.initiale));
  }


  /* Date de fin de parution */
  if ((int4)GYBok ==  GIVvIndInscrip.sDateFinParutI)
  {
      memcpy(&doc->value.intitule.datefinparu[0], &GIVvInscrip.acDateFinParut[0],2);
      doc->value.intitule.datefinparu[2] = '/';
      memcpy(&doc->value.intitule.datefinparu[3], &GIVvInscrip.acDateFinParut[2],2);
      doc->value.intitule.datefinparu[5] = '/';
      memcpy(&doc->value.intitule.datefinparu[6], &GIVvInscrip.acDateFinParut[4],4);
  }


  if ((int4)GYBok ==  GIVvIndInscrip.sMenDomI)
  {
    strcpy(doc->value.rubriques.mendom, GIVvInscrip.acMenDom);
    GWTTrace (GWT_NIV_FONCT,
              ("MenDom  : ... %s\n", doc->value.rubriques.mendom));

  }

  if ((int4)GYBok ==  GIVvIndInscrip.sMentionI)
  {
    strcpy(doc->value.intitule.mention, GIVvInscrip.acMention);
    GWTTrace (GWT_NIV_FONCT,
              ("Mention  : ... %s\n", doc->value.intitule.mention));

  }

  if (((int4)GYBok ==  GIVvIndInscrip.sDepActI) && ((int4)GYBok ==  GIVvIndInscrip.sLocActI))
  {
    strcpy(doc->value.rubriques.depact, GIVvInscrip.acDepAct);
    GWTTrace (GWT_NIV_FONCT,
              ("DepAct  : ... %s\n", doc->value.rubriques.depact));
    strcpy(doc->value.rubriques.locact, GIVvInscrip.acLocAct);
    GWTTrace (GWT_NIV_FONCT,
              ("LocAct  : ... %s\n", doc->value.rubriques.locact));
    strcpy(doc->value.rubriques.arract,"");
    iDept = atoi(GIVvInscrip.acDepAct);
    switch (iDept)
    {
      case (int4)75 :
      {
        if (0 == memcmp (&GIVvInscrip.acLocAct[0],"056",(int4)3))
        {
          /* Paris */
          iArrond = atoi(&GIVvInscrip.acLocAct[3]);
          if (((int4)1 <= iArrond) && ((int4)20 >= iArrond))
          {
            strcpy(doc->value.rubriques.arract,&GIVvInscrip.acLocAct[3]);
            strcpy(&doc->value.rubriques.locact[3],"00");
          }
        }
        break;
      }
      case (int4)69 :
      {
        if (0 == memcmp (&GIVvInscrip.acLocAct[0],"123",(int4)3))
        {
          /* Lyon */
          iArrond = atoi(&GIVvInscrip.acLocAct[3]);
          if (((int4)1 <= iArrond) && ((int4)9 >= iArrond))
          {
            strcpy(doc->value.rubriques.arract,&GIVvInscrip.acLocAct[3]);
            strcpy(&doc->value.rubriques.locact[3],"00");
          }
        }
        break;
      }
      case (int4)13 :
      {
        if (0 == memcmp (&GIVvInscrip.acLocAct[0],"055",(int4)3))
        {
          /* Marseille */
          iArrond = atoi(&GIVvInscrip.acLocAct[3]);
          if (((int4)1 <= iArrond) && ((int4)16 >= iArrond))
          {
            strcpy(doc->value.rubriques.arract,&GIVvInscrip.acLocAct[3]);
            strcpy(&doc->value.rubriques.locact[3],"00");
          }
        }
        break;
      }
      default :
      {
        /* Pas d'arrondissement */
        strcpy(doc->value.rubriques.arract,"");
        break;
      }
    }


  }

  /* Encodage du compte utilisateur  */
  if ((int4)GYBok ==  GIVvIndInscrip.sCteUtilI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.cteutil, GIVvInscrip.acCteUtil);
    GWTTrace (GWT_NIV_FONCT,
              ("CteUtil : %s\n", doc->value.inscription[indice].moyen_de_com.cteutil));
  }

  /* Encodage du nom supplémentaire  */
  if ((int4)GYBok ==  GIVvIndInscrip.sNomSuppI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.nomsupplement, GIVvInscrip.acNomSupp);
    GWTTrace (GWT_NIV_FONCT,
              ("Nom Supplémentaire : %s\n", doc->value.inscription[indice].moyen_de_com.nomsupplement));
  }

  /* Encodage du masque numnat  */
  if ((int4)GYBok ==  GIVvIndInscrip.sMskNumI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.msknum, GIVvInscrip.acMskNum);
    GWTTrace (GWT_NIV_FONCT,
              ("MskNum : %s\n", doc->value.inscription[indice].moyen_de_com.msknum));
  }

  /* Encodage du masque mel  */
  if ((int4)GYBok ==  GIVvIndInscrip.sMskMelI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.mskmel, GIVvInscrip.acMskMel);
    GWTTrace (GWT_NIV_FONCT,
              ("MskMel : %s\n", doc->value.inscription[indice].moyen_de_com.mskmel));
  }


  /* Encodage de la date de maj CU  */
  if ((int4)GYBok ==  GIVvIndInscrip.sDatCUI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.datcu, GIVvInscrip.acDatCU);
    GWTTrace (GWT_NIV_FONCT,
              ("MskMel : %s\n", doc->value.inscription[indice].moyen_de_com.datcu));
  }


  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givMefMoyensTelecom ()                                         */
/*                                                                            */
/* But       : Mise en forme de l'ensemble "moyens de telecommunication"      */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Modification (Nov/13/1997 lgu) : V2 ajout adresse e-mail                   */
/* Modification (Fev/03/1998 lgu) : Adresse internet dans numero d'appel      */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 givMefMoyensTelecom (GYBrDOCUMENT *doc, int4 indice)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */

  nat1 ucCompteur, ucCptTmp;
  int1 cDrapeauNumap = (int1)GWCCodeKO;



  /* on a qu'une inscription dans doc */
  indice=0;

  /* Encodage du code produit */
  if ((int4)GYBok ==  GIVvIndInscrip.sCodproI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.code_produit, GIVvInscrip.acCodpro);
    GWTTrace (GWT_NIV_FONCT,
              ("CODE_PRODUIT : %s\n", doc->value.inscription[indice].moyen_de_com.code_produit));
  }
  /* Encodage du code produit étendu*/
  if ((int4)GYBok ==  GIVvIndInscrip.sCodproEtenduI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.code_produit_etd, GIVvInscrip.acCodproEtendu);
    GWTTrace (GWT_NIV_FONCT,
              ("CODE_PRODUIT_ETD : %s\n", doc->value.inscription[indice].moyen_de_com.code_produit_etd));
  }


  /* groupe des données associées au produit lui même */
  /**-------------------------------------------------*/


  /* Encodage du numero  */
  strcpy(doc->value.inscription[indice].moyen_de_com.numero, GIVvInscrip.acNumnat);
  GWTTrace (GWT_NIV_FONCT,
            ("NUMERO : %s\n", doc->value.inscription[indice].moyen_de_com.numero));

  /* numap pour monaco */
  if ((!strcmp(GIVvInscrip.acCoddep,giv_DEP_MONACO) && !strcmp(GIVvInscrip.acCodloc,giv_LOC_MONACO))
  	|| (!strcmp(GIVvInscrip.acDeppar,giv_DEP_MONACO) && !strcmp(GIVvInscrip.acLocpar,giv_LOC_MONACO)
  	    && (0 == strcmp("0000",GIVvInscrip.acNumls))))
  {
    GWTTrace (GWT_NIV_FONCT, ("traitement particulier monaco pour numap\n"));
    cDrapeauNumap = (int1)GWCCodeKO;

    /* Encodage du numero d'appel du produit */
    if( (GIVvInscrip.acNumnat[0]=='0') &&
        ((GIVvInscrip.acNumnat[1]=='6')||(GIVvInscrip.acNumnat[1]=='8')||(GIVvInscrip.acNumnat[1]=='9')) )
    {
      if ((int4)GYBok ==  GIVvIndInscrip.sNumapI)
      {
        /* Numap present on envoi telquel */
        strcpy(givcNumnat,GIVvInscrip.acNumap);
        cDrapeauNumap = (int1)GWCCodeOK;
      }
    }
    else
    {
      if ((int4)GYBok ==  GIVvIndInscrip.sNumapI)
      {
        /* Numap present */
        ucCompteur = 0;
        for(ucCptTmp=0;ucCptTmp<strlen(GIVvInscrip.acNumap);ucCptTmp++)
        {
          if ((GIVvInscrip.acNumap[ucCptTmp]>='0')&&(GIVvInscrip.acNumap[ucCptTmp]<='9')) ucCompteur++;
        }
        if (ucCompteur==10)
        {
          /* on met au format « 00 377 » + un espace + les 8 derniers
             chiffres du Numap en conservant leur mise en forme */
          ucCompteur = 0;
          for(ucCptTmp=strlen(GIVvInscrip.acNumap)-1; (int1)ucCptTmp>=0; ucCptTmp--)
          {
            if ((GIVvInscrip.acNumap[ucCptTmp]>='0')&&(GIVvInscrip.acNumap[ucCptTmp]<='9'))
            {
              ucCompteur++;
            }
            if (ucCompteur==8)
            {
              break;
            }
          }
          sprintf(givcNumnat,"00 377 %s",GIVvInscrip.acNumap+ucCptTmp);
          cDrapeauNumap = (int1)GWCCodeOK;
        }
        else
        {
          /* on transmet le numap telquel. */
          strcpy(givcNumnat,GIVvInscrip.acNumap);
          cDrapeauNumap = (int1)GWCCodeOK;
        }
      }
      else if ('0' == GIVvInscrip.acIndPart[0])
      {
        /*  Numap absent -> on met au format '00 377 XX XX XX XX' */
        sprintf(givcNumnat,"00 377 %c%c %c%c %c%c %c%c",
                GIVvInscrip.acNumnat[2],GIVvInscrip.acNumnat[3],
                GIVvInscrip.acNumnat[4],GIVvInscrip.acNumnat[5],
                GIVvInscrip.acNumnat[6],GIVvInscrip.acNumnat[7],
                GIVvInscrip.acNumnat[8],GIVvInscrip.acNumnat[9]);
        cDrapeauNumap = (int1)GWCCodeOK;
      }
    }

    if (cDrapeauNumap == GWCCodeOK)
    {
      strcpy(doc->value.inscription[indice].moyen_de_com.numero_parution, givcNumnat);
      GWTTrace (GWT_NIV_FONCT,
                ("NUMERO_PARUTION : %s\n", doc->value.inscription[indice].moyen_de_com.numero_parution));
    }

  }
  else
  {
    /* Encodage du numero parution */
    if ((int4)GYBok ==  GIVvIndInscrip.sNumapI)
    {
      (void)strcpy(givcNumnat,GIVvInscrip.acNumap);

      if ( ((int4)GYBok == GIVvIndInscrip.sCoddepI)
           && (0 == memcmp(GIVvInscrip.acCoddep,givcDepPays,strlen(GIVvInscrip.acCoddep))) )
      {
        /* recherche de l'indicatif du pays */
        iIntRet = GIVLectureTabPAYS (GIVvInscrip.acCoddep,
                                     GIVvInscrip.acCodloc);
        if ((int4)GIXCodeOK == iIntRet)
        {
          /* concaténation de l'indicatif avec le numap */
          (void) sprintf(givcNumnat, "00 %s %s", GIVvPays.acIndpays,GIVvInscrip.acNumap);
        }
      }
      strcpy(doc->value.inscription[indice].moyen_de_com.numero_parution, givcNumnat);
      GWTTrace (GWT_NIV_FONCT,
                ("NUMERO_PARUTION : %s\n", doc->value.inscription[indice].moyen_de_com.numero_parution));
    }
    else if ('0' == GIVvInscrip.acIndPart[0])
    {
      if ( ((int4)GYBok == GIVvIndInscrip.sCoddepI)
           && (0 == memcmp(GIVvInscrip.acCoddep,givcDepPays,strlen(GIVvInscrip.acCoddep))) )
      {
        (void)sprintf(givcNumnat,"%c%c %c%c %c%c %c%c %c%c",GIVvInscrip.acNumnat[0],GIVvInscrip.acNumnat[1],GIVvInscrip.acNumnat[2],
                      GIVvInscrip.acNumnat[3],GIVvInscrip.acNumnat[4],GIVvInscrip.acNumnat[5],
                      GIVvInscrip.acNumnat[6],GIVvInscrip.acNumnat[7],GIVvInscrip.acNumnat[8],GIVvInscrip.acNumnat[9]);
        /* recherche de l'indicatif du pays */
        iIntRet = GIVLectureTabPAYS (GIVvInscrip.acCoddep,
                                     GIVvInscrip.acCodloc);
        if ((int4)GIXCodeOK == iIntRet)
        {
          /* concatination de l'indicatif avec le numnat */
          (void) sprintf(givcNumnat, "00 %s %c%c %c%c %c%c %c%c %c%c", GIVvPays.acIndpays,GIVvInscrip.acNumnat[0],GIVvInscrip.acNumnat[1],GIVvInscrip.acNumnat[2],GIVvInscrip.acNumnat[3],GIVvInscrip.acNumnat[4],GIVvInscrip.acNumnat[5],GIVvInscrip.acNumnat[6],GIVvInscrip.acNumnat[7],GIVvInscrip.acNumnat[8],GIVvInscrip.acNumnat[9]);

        }
        strcpy(doc->value.inscription[indice].moyen_de_com.numero_parution, givcNumnat);
        GWTTrace (GWT_NIV_FONCT,
                  ("NUMERO_PARUTION : %s\n", doc->value.inscription[indice].moyen_de_com.numero_parution));
      }
    }

  }


  /* Encodage du mnemonique (telex ou teletel) */
  if ((int4)GYBok ==  GIVvIndInscrip.sMnemonI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.mnemonique, GIVvInscrip.acMnemon);
    GWTTrace (GWT_NIV_FONCT,
              ("MNEMONIC : %s\n", doc->value.inscription[indice].moyen_de_com.mnemonique));
  }

  /* Encodage du libellé d'url */
  if ((int4)GYBok ==  GIVvIndInscrip.sLibUrlI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.url, GIVvInscrip.acLibUrl);
    GWTTrace (GWT_NIV_FONCT,
              ("URL : %s\n", doc->value.inscription[indice].moyen_de_com.url));
  }

  if ((int4)GYBok ==  GIVvIndInscrip.sIpaysI)
  {
    /* Encodage de l'indicatif du pays */
    strcpy(doc->value.inscription[indice].adresse.ipays, GIVvInscrip.acIpays);
    GWTTrace (GWT_NIV_FONCT,
              ("IPAYS : %s\n", doc->value.inscription[indice].adresse.ipays));
  }


  /* groupe des données associées à la dénumérotation */
  /**-------------------------------------------------*/

  /* Encodage de l'adresse e-mail */
  if ((int4)GYBok ==  GIVvIndInscrip.sEmailI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.email, GIVvInscrip.acEmail);
    GWTTrace (GWT_NIV_FONCT,
              ("EMAIL : %s\n", doc->value.inscription[indice].moyen_de_com.email));
  }


  /* Encodage du tiliphone mobile */
  if ((int4)GYBok ==  GIVvIndInscrip.sEquitelI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.equiptel, GIVvInscrip.acEquitel);
    GWTTrace (GWT_NIV_FONCT,
              ("EQUIPTEL : %s\n", doc->value.inscription[indice].moyen_de_com.equiptel));
  }


  /* Encodage du tiliphone mobile */
  if ((int4)GYBok ==  GIVvIndInscrip.sServtelI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.servtel, GIVvInscrip.acServtel);
    GWTTrace (GWT_NIV_FONCT,
              ("SERVTEL : %s\n", doc->value.inscription[indice].moyen_de_com.servtel));
  }


  /* Encodage du tiliphone mobile */
  if ((int4)GYBok ==  GIVvIndInscrip.sTarifartI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.tarifart, GIVvInscrip.acTarifart);
    GWTTrace (GWT_NIV_FONCT,
              ("TARIFART : %s\n", doc->value.inscription[indice].moyen_de_com.tarifart));
  }


  /* Encodage du tiliphone mobile */
  if ((int4)GYBok == GIVvIndInscrip.sOpeartI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.operateur, GIVvInscrip.acOpeart);
    GWTTrace (GWT_NIV_FONCT,
              ("OPERATEUR : %s\n", doc->value.inscription[indice].moyen_de_com.operateur));
  }

  if ((int4)GYBok == GIVvIndInscrip.sNumRGI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.numrg, GIVvInscrip.acNumRG);
    GWTTrace (GWT_NIV_FONCT,
              ("NUMRG : %s\n", doc->value.inscription[indice].moyen_de_com.numrg));
  }

  if ((int4)GYBok == GIVvIndInscrip.sIndRGI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.indrg, GIVvInscrip.acIndRG);
    GWTTrace (GWT_NIV_FONCT,
              ("INDRG : %s\n", doc->value.inscription[indice].moyen_de_com.indrg));
  }

  if ((int4)GYBok == GIVvIndInscrip.sLaMarqueI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.lamarque, GIVvInscrip.acLaMarque);
    GWTTrace (GWT_NIV_FONCT,
              ("LAMARQUE : %s\n", doc->value.inscription[indice].moyen_de_com.lamarque));
  }

  if ((int4)GYBok == GIVvIndInscrip.sLaQualiteI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.laqualite, GIVvInscrip.acLaQualite);
    GWTTrace (GWT_NIV_FONCT,
              ("LAQUALITE : %s\n", doc->value.inscription[indice].moyen_de_com.laqualite));
  }

  if ((int4)GYBok == GIVvIndInscrip.sMntarifI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.tarif_exact, GIVvInscrip.acMntarif);
    GWTTrace (GWT_NIV_FONCT,
              ("TARIF_EXACT : %s\n", doc->value.inscription[indice].moyen_de_com.tarif_exact));
  }

  if ((int4)GYBok ==  GIVvIndInscrip.sCatNumI)
  {
    strcpy(doc->value.inscription[indice].moyen_de_com.catnum, GIVvInscrip.acCatNum);
    GWTTrace (GWT_NIV_FONCT,
              ("CAT_NUM : %s\n", doc->value.inscription[indice].moyen_de_com.catnum));
  }

  iCodRet = GWCCodeOK;

  /* Sortie de la fonction givMefMoyensTelecom */
  return (iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givMefLieuParution ()                                         */
/*                                                                            */
/* But       : Mise en forme de l'ensemble "lieu de parution"      */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 givMefLieuParution (GYBrDOCUMENT *doc, int4 indice)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */

  /* indicateur de parution */
  strcpy(doc->value.intitule.parution, GIVvInscrip.acInparu);

  /* groupe des données définissant le lieu de parution */
  /**---------------------------------------------------*/
  if ((int4)GYBok ==  GIVvIndInscrip.sDepparI)
  {
    strcpy(doc->value.inscription[0].cDeppar, GIVvInscrip.acDeppar);
    strcpy(doc->value.inscription[0].cLocpar, GIVvInscrip.acLocpar);
    strcpy(doc->value.inscription[0].cArrpar, GIVvInscrip.acArrpar);
    if ((int4)GWCCodeOK != iIntRet)
    {
      /* Erreur sur encodage TLV Deppar */
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur sur encodage TLV du code departement de parution ...\n"));
      iCodRet = (int4)GWCCodeKO;
    }

    if ((int4)GYBok ==  GIVvIndInscrip.sLocparI)
    {

      if ((int4)GWCCodeOK != iIntRet)
      {
        /* Erreur sur encodage TLV Locpar */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur sur encodage TLV du code localite de parution ...\n"));
        iCodRet = (int4)GWCCodeKO;
      }
    }
  }

  /* Sortie de la fonction givMefLieuParution */
  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givMefLieuInstallation ()                                      */
/*                                                                            */
/* But       : Mise en forme de l'ensemble "lieu d'installation"              */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Modification (Avr/25/2000 mb) : prise en compte des départment et localité */
/*                                 d'installation                             */
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Modification (Jan/10/2001 tw) : geocodage des inscriptions                 */
/*----------------------------------------------------------------------------*/

int4 givMefLieuInstallation (GYBrDOCUMENT *doc, int4 aindice)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */
  int4           iRetCP;
  int4           i,j,iIdx = 0;                       /* Index de boucle */
  char cBufAdrnr[sizeof(GIVvInscrip.acAdrnr)+1+sizeof(GIVvLocrep.acCodpos)+1+sizeof(GIVvLocrep.acLibloc)] = "";
  char cBufLibVoie[sizeof(GIVvInscrip.acTypvoi)+1+sizeof(GIVvInscrip.acLibvoi)] = "";
  char cAdrnr[sizeof(GIVvInscrip.acAdrnr)+1] = "";
  char *pcChaine = NULL;
  char *pcCp = NULL;
  char tcLibTypVoi[ GYBPetvoiLgLibvoi + 1 ];
  int4 iLocIns = 0;
  int4 indice=0;
  int4 iFaireGeocod;    /* si GWZOk on geocode */
  double dWgsLon;
  double dWgsLat;

  /* initialisation données locales */
  (void) memset(&cBufAdrnr[0], 0x00, sizeof(cBufAdrnr));
  (void) memset(&cBufLibVoie[0], 0x00, sizeof(cBufLibVoie));
  (void) memset(&cAdrnr[0], 0x00, sizeof(cAdrnr));
  (void) memset(&tcLibTypVoi[0], ' ', GYBPetvoiLgLibvoi);
  tcLibTypVoi[GYBPetvoiLgLibvoi] = '\0';


  /* Mise en forme de "ensemble de" lieux d'installation */

  if ((int4)GYBok ==  GIVvIndInscrip.sCoddepI)
  {
    strcpy(doc->value.inscription[0].cCoddep, GIVvInscrip.acCoddep);
    strcpy(doc->value.inscription[0].cCodloc, GIVvInscrip.acCodloc);
  }
  if ((int4)GYBok ==  GIVvIndInscrip.sArrondI)
  {
    strcpy(doc->value.inscription[0].cArrond,GIVvInscrip.acArrond);
  }

  /* indicateur de parution */
  strcpy(doc->value.inscription[0].adresse.parution, doc->value.intitule.parution);

  /* rang d'adresse non initialisé */
  doc->value.inscription[indice].adresse.irangadr = (int4)0;


  /* gestion de l'adresse */
  /**---------------------*/
  if (givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr])
  {
    /* parution de l'adresse */
    if (givcParuSSNo != GIVvInscrip.acInparu[givcIndParuAdr])
    {
      /* parution du numéro dans la voie */
      if ((int4)GYBok ==  GIVvIndInscrip.sNovoieI)
      {
        /* Encodage du numero dans la voie */
        strcpy(doc->value.inscription[indice].adresse.numero_voie, GIVvInscrip.acNovoie);
        GWTTrace (GWT_NIV_FONCT,
                  ("NoVOIE : %s\n", doc->value.inscription[indice].adresse.numero_voie));

        if ((int4)GYBok ==  GIVvIndInscrip.sCplnovI)
        {
          /* Encodage du complement de numero dans la voie */
          strcpy(doc->value.inscription[indice].adresse.complt_num_voie, GIVvInscrip.acCplnov);
          GWTTrace (GWT_NIV_FONCT,
                    ("COMP_NoVOIE : %s\n", doc->value.inscription[indice].adresse.complt_num_voie));
          switch( GIVvInscrip.acCplnov[0] )
          {
            /** Ne pas traduire A B C et D */
            case '1':
              break;
            case '2':
              strcpy( doc->value.inscription[indice].adresse.lib_complt_num_voie, "Bis" );
              break;
            case '3':
              strcpy( doc->value.inscription[indice].adresse.lib_complt_num_voie, "Ter" );
              break;
            case '4':
              strcpy( doc->value.inscription[indice].adresse.lib_complt_num_voie, "Quater" );
              break;
            case '5':
              strcpy( doc->value.inscription[indice].adresse.lib_complt_num_voie, "Quinquies" );
              break;
            case '6':
              strcpy( doc->value.inscription[indice].adresse.lib_complt_num_voie, "Sexto" );
              break;
            default:
              strcpy( doc->value.inscription[indice].adresse.lib_complt_num_voie, doc->value.inscription[indice].adresse.complt_num_voie );
              break;
          }
          GWTTrace (GWT_NIV_FONCT,
                    ("LIB_COMP_NoVOIE : %s\n", doc->value.inscription[indice].adresse.lib_complt_num_voie));
        }
      }
    }

    if ((int4)GYBok ==  GIVvIndInscrip.sCodvoiI)
    {
      /* Encodage du code voie repertoriee */
      strcpy(doc->value.inscription[indice].adresse.code_voie, GIVvInscrip.acCodvoi);
      GWTTrace (GWT_NIV_FONCT,
                ("CODE_VOIE : %s\n", doc->value.inscription[indice].adresse.code_voie));

    }

    if ((int4)GYBok ==  GIVvIndInscrip.sLibvoiI)
    {
      if ((int4)GYBok ==  GIVvIndInscrip.sTypvoiI)
      {
/** 14/09/1998 LGU ANO_xxxx Traduire le type de voie en fonction du contenu de GYTtabPetvoi */
        /* Traduire le type de voie */
        iCodRet = GIVTradTypvoi( GIVvInscrip.acTypvoi, tcLibTypVoi );
        if ( GWCCodeOK != iCodRet )
        {
          strcpy( tcLibTypVoi, GIVvInscrip.acTypvoi );
          iCodRet = GWCCodeOK;
        }

        /* Suppression des blancs éventuels derrière le type de voie*/
        for (iIdx = (strlen(tcLibTypVoi)-1) ; (0 <= iIdx) && (tcLibTypVoi[iIdx]== GIV_CHAR_BLANC) ; iIdx--)
        {
          tcLibTypVoi[iIdx] = '\0';
        }

        /* type de voie */
        strcpy(doc->value.inscription[indice].adresse.type_voie, tcLibTypVoi);
        GWTTrace (GWT_NIV_FONCT,
                  ("TYPE_VOIE : %s\n", doc->value.inscription[indice].adresse.type_voie));

        /* Concaténation du type de voie et du libellé de voie */
        (void) sprintf(&cBufLibVoie[0], "%s %s", tcLibTypVoi, GIVvInscrip.acLibvoi);
/** 14/09/1998 LGU ANO_xxxx fin de modif */
      }
      else
      {
        (void) strcpy(&cBufLibVoie[0], GIVvInscrip.acLibvoi);
      }


      /* Encodage du libelle de voie */
      if ((int4)GYBok ==  GIVvIndInscrip.sCodvoiI)
      {
        /* voie répertoriée */
        strcpy(doc->value.inscription[indice].adresse.lib_code_voie, cBufLibVoie);
        GWTTrace (GWT_NIV_FONCT,
                  ("LIBEL_VOIE : %s\n", doc->value.inscription[indice].adresse.lib_code_voie));
      }
      else
      {
        /* voie non répertoriée */
        strcpy(doc->value.inscription[indice].adresse.libel_voie, cBufLibVoie);
        GWTTrace (GWT_NIV_FONCT,
                  ("LIBEL_VOIE : %s\n", doc->value.inscription[indice].adresse.libel_voie));
      }

    }
    else
    {
      /* Si le libelle de voie n'est pas dans le référentiel inscription */
      /* s'il existe un code voie repertoriee */
      /*   le recuperer dans la table PEVREP*/
      /* S'il n'y a pas de code voie, ne rien faire */

      if ((int4)GYBok ==  GIVvIndInscrip.sCodvoiI)
      {
        iIntRet = GIVLectureTabPEVREP (GIVvInscrip.acDeppar,
                                       GIVvInscrip.acLocpar,
                                       GIVvInscrip.acCodvoi);

        if ((int4)GIXCodeOK == iIntRet)
        {
          /* Si le libelle de voie a ete trouve dans la table voies repertoriees */
          /* le charger dans le mouvement CD */
          if (0 != GIViNbTuplePevrep)
          {
            /* Encodage du libelle de voie */
            strcpy(doc->value.inscription[indice].adresse.lib_code_voie, GIVvVoirep.acLibvoi);
            GWTTrace (GWT_NIV_FONCT,
                      ("LIBEL_VOIE : %s\n", doc->value.inscription[indice].adresse.lib_code_voie));

          }
          else
          {
            /* Si le libelle de voie repertoriee n'existe pas dans la base PEVREP, generer une signalisation */
            GWTTrace (GWT_NIV_BIZAR,
                      ("Libelle de voie repertoriee non trouve ...\n"));
          }
        }
        else
        {
          /* La consultation de la table voie repertoriee s'est mal passee */
          GWTTrace (GWT_NIV_GRAVE,
                    ("Erreur sur acces a la table voie repertoriee  ...\n"));
          iCodRet = (int4)GWCCodeKO;
        }
      }
    }

    if ((int4)GYBok ==  GIVvIndInscrip.sEnsbatI)
    {
      /* Encodage de l'ensemble batiment */
      strcpy(doc->value.inscription[indice].adresse.ensemble_batiment, GIVvInscrip.acEnsbat);
      GWTTrace (GWT_NIV_FONCT,
                ("ENSEMBLE_BAT : %s\n", doc->value.inscription[indice].adresse.ensemble_batiment));
    }

    if ((int4)GYBok ==  GIVvIndInscrip.sLieuaeI)
    {
      /* Encodage du lieu dit AE*/
      strcpy(doc->value.inscription[indice].adresse.lieue_ae, GIVvInscrip.acLieuae);
      GWTTrace (GWT_NIV_FONCT,
                ("LIEU_AE : %s\n", doc->value.inscription[indice].adresse.lieue_ae));

    }
  }


  if ((givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]) ||
     ((0 == strcmp(GIVtcGeneSSAdr,"OUI"))
            && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr])))
  {
    /* traitement du champ adresse non répertoriée */
    /**--------------------------------------------*/
    /* on récupère l'adrnr de l'inscription si elle existe */
    if (((int4)GYBok ==  GIVvIndInscrip.sAdrnrI) && ( ( 0 == strcmp("0000", cNumls)) || (0 == strcmp(GIVtcGeneCP,"OUI")) ))
    {
      /* recherche de l'existence d'un code postal dans l'adresse */
      iIntRet = GWCCodeKO;
      iRetCP = GWCCodeOK;
      (void) strcpy(cAdrnr, GIVvInscrip.acAdrnr);
      pcChaine = strtok(cAdrnr, " ");
      while ((NULL != pcChaine) && (GWCCodeKO == iIntRet))
      {
        if ( (sizeof(GIVvLocrep.acCodpos) - 1) == strlen(pcChaine) )
        {
          for ( iIdx = 0 ; isdigit(pcChaine[iIdx]) ; iIdx++);
          if ( (sizeof(GIVvLocrep.acCodpos) - 1) == iIdx )
          {
            iIntRet = GWCCodeOK;
          }
        }
        /* passer au mot suivant */
        if ((GWCCodeOK == iRetCP) && (GWCCodeOK == iIntRet))
        {
          pcCp = pcChaine + strlen(pcChaine) + 1;
        }
        else
        {
          iRetCP = GWCCodeKO;
          pcChaine = strtok(NULL, " ");
        }
      }

      /* recherche du CODDEP dans l'adresse */
      if ( NULL != strstr(GIVvInscrip.acAdrnr, GIVvInscrip.acCoddep))
      {
        iIntRet = GWCCodeOK;
      }

      if ( 0 ==  strlen(cBufAdrnr))
      {
        (void) strcpy(&cBufAdrnr[0], GIVvInscrip.acAdrnr);
        if ((0 == strcmp(GIVtcGeneCP,"OUI")) && (GWCCodeOK == iIntRet) && (GWCCodeOK == iRetCP) && (0 != strcmp("0000", cNumls)))
        {
          (void) strcpy(&cBufAdrnr[0], pcCp);
          GIVvIndInscrip.sCodposI = (int4)GYBok;
          (void) strcpy(GIVvInscrip.acCodpos, cAdrnr);
        }
      }
      else
      {
        /* si l'adresse contient quelque chose qui ressemble à un code postal */
        /* ou s'il contient le CODDEP */
        /* on le laise en l'état */

        if (GWCCodeOK == iIntRet)
        {
          /* un code postal ou le CODDEP dans l'adrnr, on garde l'adrnr et l'état */
          (void) strcpy(&cBufAdrnr[0], GIVvInscrip.acAdrnr);
        }
        else
        {
          /* pas de code postal ou de CODDEP dans le libellé, on rajoute le CODDEP + localite */
          (void) sprintf(&cBufAdrnr[0], "%s %s %s", GIVvInscrip.acAdrnr, GIVvInscrip.acCoddep, GIVvLocrep.acLibloc);
        }
      }
    }
    else if (((int4)GYBok ==  GIVvIndInscrip.sAdrnrI) && ( 0 != strcmp("0000", cNumls)))
    {
      /* adrnr déjà formaté */
      (void) strcpy(cBufAdrnr, GIVvInscrip.acAdrnr);
    }

    if ((0 !=  strlen(cBufAdrnr)) && (givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]))
    {
      /* Encodage de l'adresse non repertoriee */
      strcpy(doc->value.inscription[indice].adresse.adrnr, cBufAdrnr);
      GWTTrace (GWT_NIV_FONCT,
                ("ADRNR : %s\n", doc->value.inscription[indice].adresse.adrnr));
    }
    else
    {
      /* pas Encodage de l'adresse non repertoriee */
      strcpy(doc->value.inscription[indice].adresse.adrnr, "");
      GWTTrace (GWT_NIV_FONCT,
                ("ADRNR : %s\n", doc->value.inscription[indice].adresse.adrnr));
    }
  }

  if ((int4)GYBok ==  GIVvIndInscrip.sArrondI)
  {
    if (((0 == strcmp(GIVtcGeneSSAdr,"OUI"))
         && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr]))
        || (givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]))
    {
      /* Encodage du code arrondissement */
      strcpy(doc->value.inscription[indice].adresse.arrondissement, GIVvInscrip.acArrond);
      GWTTrace (GWT_NIV_FONCT,
                ("ARROND : %s\n", doc->value.inscription[indice].adresse.arrondissement));

    }
  }

  /* les informations BP, code cedex et libellé cedex sont conditionnées par */
  /* presence du code cedex et un libellé existe en association avec ce code */
  if (((int4)GYBok ==  GIVvIndInscrip.sCodcdxI) && ((givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]) ||
((0 == strcmp(GIVtcGeneSSAdr,"OUI"))
            && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr]))))
  {
    /* Recuperation du libelle cedex */
    iIntRet = GIVLectureTabPECDEX (GIVvInscrip.acCodcdx);

    if ( (int4)0 < GIViNbTuplePecdex )
    {
      /* on a un tuple libellé cedex */

      /* Encodage du code Cedex */
      strcpy(doc->value.inscription[indice].adresse.code_cedex, GIVvInscrip.acCodcdx);
      strcpy(doc->value.inscription[indice].adresse.lib_cedex, GIVvCedex.acLibcdx);
      GWTTrace (GWT_NIV_FONCT,
                ("CODE_CEDEX : %s\n", doc->value.inscription[indice].adresse.code_cedex));

    }

  }
  else
  {
    /* le code postal n'a de sens qu'en absence du code cedex */
    if (((int4)GYBok ==  GIVvIndInscrip.sCodposI) && ((givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]) ||
((0 == strcmp(GIVtcGeneSSAdr,"OUI"))
            && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr]))))
    {
      /* Encodage du code postal */
      strcpy(doc->value.inscription[indice].adresse.code_postal, GIVvInscrip.acCodpos);
      GWTTrace (GWT_NIV_FONCT,
                ("CODE_POSTAL : %s\n", doc->value.inscription[indice].adresse.code_postal));

    }
  }

  if (((int4)GYBok ==  GIVvIndInscrip.sBoiteI) && (givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]))
  {
    /* Encodage du numero de la boite postale */
    strcpy(doc->value.inscription[indice].adresse.boite, GIVvInscrip.acBoite);
    GWTTrace (GWT_NIV_FONCT,
              ("BOITE : %s\n", doc->value.inscription[indice].adresse.boite));

  }

  /* localité d'installation */
  if (((0 == strcmp(GIVtcGeneSSAdr,"OUI"))
            && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr]))
           || (givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]))
  {
    if ((int4)GYBok == GIVvIndInscrip.sCoddepI)
    {
      sprintf(doc->value.inscription[indice].adresse.instal, "%s%s", GIVvInscrip.acCoddep, GIVvInscrip.acCodloc);
      if ((int4)GYBok ==  GIVvIndInscrip.sArrondI)
      {
        iIntRet = GIVLectureArrPELREP (GIVvInscrip.acCoddep,
                                       GIVvInscrip.acCodloc,
                                       GIVvInscrip.acArrond);
      }
      else
      {
        iIntRet = GIVLectureTabPELREP (GIVvInscrip.acCoddep,
                                       GIVvInscrip.acCodloc);
      }
    }
    else
    {
      sprintf(doc->value.inscription[indice].adresse.instal, "%s%s", GIVvInscrip.acDeppar, GIVvInscrip.acLocpar);
      if ((int4)GYBok ==  GIVvIndInscrip.sArrondI)
      {
        iIntRet = GIVLectureArrPELREP (GIVvInscrip.acDeppar,
                                       GIVvInscrip.acLocpar,
                                       GIVvInscrip.acArrond);
      }
      else
      {
        iIntRet = GIVLectureTabPELREP (GIVvInscrip.acDeppar,
                                       GIVvInscrip.acLocpar);
      }
    }

    if ((int4)GIXCodeOK == iIntRet)
    {
      /* libellé de localité */
      strcpy(doc->value.inscription[indice].adresse.libinstal,GIVvLocrep.acLibloc);
    }
    else if (0 == strcmp(GIVvInscrip.acLocpar,givcLocFictive))
    {
      strcpy(doc->value.inscription[indice].adresse.libinstal,"LOCALITE FICTIVE");
    }

    if (((int4)GYBok == GIVvIndInscrip.sDepActI) && ((int4)GYBok == GIVvIndInscrip.sLocActI) && (0 == strcmp(GIVtcGeneActiv,"OUI")))
    {
      if (0 != strlen(doc->value.rubriques.arract))
      {
        iIntRet = GIVLectureArrPELREP (doc->value.rubriques.depact,
                                     doc->value.rubriques.locact,
                                     doc->value.rubriques.arract);
      }
      else
      {
        iIntRet = GIVLectureTabPELREP (doc->value.rubriques.depact,
                                     doc->value.rubriques.locact);
      }
      if ((int4)GIXCodeOK == iIntRet)
      {
        /* libellé de localité */
        strcpy(doc->value.inscription[indice].adresse.libinstact,GIVvLocrep.acLibloc);
      }
    }
  }
  GWTTrace (GWT_NIV_FONCT,
            ("INSTAL : %s\n", doc->value.inscription[indice].adresse.instal));

  if ( ((int4)GYBok !=  GIVvIndInscrip.sCodposI) && ((int4)GYBok !=  GIVvIndInscrip.sCodcdxI) && ((int4)GYBok !=  GIVvIndInscrip.sBoiteI) && (0 == strcmp("0000", GIVvInscrip.acNumls)) && ((givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]) || ((0 == strcmp(GIVtcGeneSSAdr,"OUI"))
            && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr])))
)
  {
    /* Encodage du code postal */
    strcpy(doc->value.inscription[indice].adresse.code_postal, GIVvLocrep.acCodpos);
    GWTTrace (GWT_NIV_FONCT,
              ("CODE_POSTAL LO : %s\n", doc->value.inscription[indice].adresse.code_postal));


  }


  /* groupe de données de géocodage */
  /* ------------------------------ */

  GWTTrace (GWT_NIV_FONCT,
            ("Valeurs de la rGeocod avant encodage: <iStatus=%d>,<tcX=%s>, <tcY=%s>, <tcQualite=%s>\n", GIVvGeocod.iStatus,
             GIVvGeocod.tcX,GIVvGeocod.tcY,GIVvGeocod.tcQualite));


  strcpy(doc->value.inscription[indice].adresse.geoloc.precision, GIVvGeocod.tcQualite);
  GWTTrace (GWT_NIV_FONCT,
            ("QUALITE : %s\n", doc->value.inscription[indice].adresse.geoloc.precision));

  strcpy(doc->value.inscription[indice].adresse.geoloc.precMappy, GIVvGeocod.tcPrecMappy);

  if ((GIVGeocodSEnvXYQ == GIVvGeocod.iStatus) || (GIVGeocodSEnvXY == GIVvGeocod.iStatus))
  {
    strcpy(doc->value.inscription[indice].adresse.geoloc.longitude, GIVvGeocod.tcLongitude);
    GWTTrace (GWT_NIV_FONCT,
              ("LONGITUDE : %s\n", doc->value.inscription[indice].adresse.geoloc.longitude));

    strcpy(doc->value.inscription[indice].adresse.geoloc.latitude, GIVvGeocod.tcLatitude);
    GWTTrace (GWT_NIV_FONCT,
              ("LATITUDE : %s\n", doc->value.inscription[indice].adresse.geoloc.latitude));

    GWTTrace (GWT_NIV_FONCT,
              ("LONGITUDE WGS : %s\n", doc->value.inscription[indice].adresse.geoloc.longitude));
    GWTTrace (GWT_NIV_FONCT,
              ("LATITUDE WGS : %s\n", doc->value.inscription[indice].adresse.geoloc.latitude));

  }

  /* Sortie de la fonction givMefLieuInstallation */
  return (iCodRet);
}





/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givMefProfessionnel ()                                         */
/*                                                                            */
/* But       : Mise en forme de l'ensemble "professionnel"                    */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 givMefProfessionnel (GYBrDOCUMENT *doc, int4 aindice)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */

  int4            i,giviInsertTLV   = 0; /* indice de deplacement dans le tableau AN9 de depart */
  char           givcAn9Courant[GYBPaprofLgCodan9 + 1] = givcR00000000;
  char           givcOrigCourant[GYBIaprofLgOrigine + 1] = """";
  /* Initialisation du nombre d'An9 */
  char          conf[50];

  nb_an9 = 0;
  nb_marque = 0;

  GWTTrace (GWT_NIV_FONCT,
            (" Entrer CodeAn9... %s\n" ));

    if (GIXCodeOK == (int1)GIVcPresenceAn9)
    {

      /* Mise en forme de l'ensemble "critere professionnel" */
      /* tant qu'il existe des elements dans le tableau des AN9 */
      giviInsertTLV = GIViNbTupleIaprof;
      while(giviInsertTLV < GIViNbMaxTabAn9)
      {
        if ( (0 != strcmp(givcAn9Courant,GIVtrProfIns[giviInsertTLV].acCodan8))
             || ( 0 != strcmp(givcOrigCourant,GIVtrProfIns[giviInsertTLV].acOrigine)) )
        {
          if ( 0 != memcmp("78",GIVtrProfIns[giviInsertTLV].acCodan8,strlen("78")) )
          {
            /* ne pas garder les rubriques "rue commerçante" */
            if ( MAX_AN9 == nb_an9 )
            {
              /* probleme max AN9 atteint */
              GWTTrace(GWT_NIV_GRAVE,
                       ("probleme max AN9 atteint"));
              iCodRet = GIXCodeKO;
              break;
            }
            /* Changement d'AN9, demarrage d'un critère professionnel */
            /* préalablement on supprime les marques / spécialités  associées à l'AN9 précédent s'il est vide */
            /* sous réserve que l'on ait déjà traité un AN9 */

            strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan9, GIVtrProfIns[giviInsertTLV].acCodan8);
             strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan8, GIVtrProfIns[giviInsertTLV].acCodInit);
             strcpy(doc->value.rubriques.Tan9[nb_an9].nature, GIVtrProfIns[giviInsertTLV].acNature);
            doc->value.rubriques.Tan9[nb_an9].orig = GIVtrProfIns[giviInsertTLV].acOrigine[0];
            doc->value.rubriques.Tan9[nb_an9].paru = GIVtrProfIns[giviInsertTLV].acParuloc[0];
            doc->value.rubriques.Tan9[nb_an9].dnex = GIVtrProfIns[giviInsertTLV].acPjdc;
            GWTTrace (GWT_NIV_FONCT,
                      (" CodeAn9... %s\n", doc->value.rubriques.Tan9[nb_an9].val_codan9));
            GWTTrace (GWT_NIV_FONCT,
                      (" CodeAn8... %s\n", doc->value.rubriques.Tan9[nb_an9].val_codan8));
            GWTTrace (GWT_NIV_FONCT,
                      (" Nature... %s\n", doc->value.rubriques.Tan9[nb_an9].nature));
            GWTTrace (GWT_NIV_FONCT,
                      (" Paruloc... %c\n", doc->value.rubriques.Tan9[nb_an9].paru));


            GWTTrace (GWT_NIV_FONCT,
                      (" No_indice : ... %d\n", nb_an9));
            nb_an9++;
          }

        }

        /* Memorisation du dernier AN9 traite */
        (void)strcpy(givcAn9Courant,GIVtrProfIns[giviInsertTLV].acCodan8);
        (void)strcpy(givcOrigCourant,GIVtrProfIns[giviInsertTLV].acOrigine);

        giviInsertTLV ++;
      }

    }
    else if ('0' == GIVvInscrip.acIndPart[0])
    {
      if ( MAX_AN9 == nb_an9 )
      {
        /* probleme max AN9 atteint */
        GWTTrace(GWT_NIV_GRAVE,
                 ("probleme max AN9 atteint"));
        iCodRet = GIXCodeKO;
      }
      else
      {
        /* defaut absence de rubrique */
        strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan9, givcR00000000);
        doc->value.rubriques.Tan9[nb_an9].paru = '0';
        doc->value.rubriques.Tan9[nb_an9].dnex = '0';
        GWTTrace (GWT_NIV_FONCT,
                  (" CodeAn9... %s\n", doc->value.rubriques.Tan9[nb_an9].val_codan9));
        nb_an9++;
      }
    }

    if ((GIXCodeOK != (int1)GIVcPresenceAn9) && ('0' != GIVvInscrip.acIndPart[0]))
    {
      for(i=0; i< GIViNbTupleIapart; i++)
      {
        (void)strcpy(givtcOriPart, GIVtrPart[i].acOriPart);
        (void) sprintf(conf, "%s_%s","GIV_AN9_PART",GIVtrPart[i].acOriPart);
        iIntRet = GWTLireConf(conf,givtcAn9Part);
        if ( GWTok != iIntRet )
        {
          /* defaut absence de rubrique */
          (void)strcpy(givtcAn9Part, givcR00000000);
        }
        (void) sprintf(conf, "%s_%s","GIV_AN8_PART",GIVtrPart[i].acOriPart);
        iIntRet = GWTLireConf(conf,givtcAn8Part);
        if ( MAX_AN9 == nb_an9 )
        {
          /* probleme max AN9 atteint */
          GWTTrace(GWT_NIV_GRAVE,
                   ("probleme max AN9 atteint"));
          iCodRet = GIXCodeKO;
        }
        else
        {
          strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan9, givtcAn9Part);
          strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan8, givtcAn8Part);
          doc->value.rubriques.Tan9[nb_an9].orig = '1';
          doc->value.rubriques.Tan9[nb_an9].paru = '0';
          doc->value.rubriques.Tan9[nb_an9].dnex = '0';
          GWTTrace (GWT_NIV_FONCT,
                    (" CodeAn9 Part %s\n", doc->value.rubriques.Tan9[nb_an9].val_codan9));
          nb_an9++;
        }
      }
      if (0 ==  GIViNbTupleIapart)
      {
        /* defaut absence de rubrique */
        strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan9, givcR00000000);
        doc->value.rubriques.Tan9[nb_an9].paru = '0';
        doc->value.rubriques.Tan9[nb_an9].dnex = '0';
        GWTTrace (GWT_NIV_FONCT,
                  (" CodeAn9... %s\n", doc->value.rubriques.Tan9[nb_an9].val_codan9));
        nb_an9++;
      }
    }
  doc->value.rubriques.iNban9 = nb_an9;

  /* Mise en place de la mention professionnelle : ODA payante prioritaire et 14D gratuite */
  /* dans deux champs différents */

  if ((int4)GYBok ==  GIVvIndInscrip.sMenormI)
  {
    strcpy(doc->value.rubriques.mpg, GIVvInscrip.acMenorm);
    GWTTrace (GWT_NIV_FONCT,
              ("MPG  : ... %s\n", doc->value.rubriques.mpg));
  }

  if ((int4)GYBok ==  GIVvIndInscrip.sMenadjI)
  {
    strcpy(doc->value.rubriques.mogmoi, GIVvInscrip.acMenadj);
    GWTTrace (GWT_NIV_FONCT,
              ("MOGMOI  : ... %s\n", doc->value.rubriques.mogmoi));

  }

  /* Sortie de la fonction givMefProfessionnel */
  return (iCodRet);
}



/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givMefCRC ()                                         */
/*                                                                            */
/* But       : Mise en forme de l'ensemble critère complémentaire             */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 givMefCRC (GYBrDOCUMENT *doc, int4 indice)
{

  int4			iCodRet;	/* Code retour de la fonction */
  int4			iIntRet;	/* Code retour des appels internes */
  int1			indFinFetch;	/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT	vErreurSQL;   /* Traitement des erreurs SQL */
  int4                   i;              /* indice de boucle */
  int4                   nb_crc;
  EXEC SQL begin declare section;
  GYBrPeCRCT    *pvCrc;
  GYBrIndPeCRCT *pvIndCrc;
  EXEC SQL end declare section;

  GWTTrace (GWT_NIV_FONCT,
            ("givLectureCRC\n"));

  indice=0;

  /* Initialisation du nombre de CRC */
  nb_crc = 0;
  iIntRet = givPreparerLectureCRC();

  if ((int4)GYBok != iIntRet)
  {
    /* Erreur sur prepare curseur SQL */
    GWTTrace (GWT_NIV_GRAVE,
              ("Erreur  crsLectureCRC ...\n"));

    iCodRet = (int4)GIXCodeKO;
  }
  else
  {

    /* Initialisation des variables locales */
    iCodRet = (int4)GIXCodeOK;
    iIntRet = (int4)GIXCodeOK;
    indFinFetch = (int1)GIXCodeOK;

    /* Valorisation du pointeur vers la structure de description de la table PAYS */
    pvCrc    = &GIVvCrc;
    pvIndCrc = &GIVvIndCrc;

    /* Valorisation du pointeur vers la structure de description */
    /*   du tableau de recuperation des crc */

    (void)memcpy (&pvCrc->acDepart[0],
                  &doc->value.inscription[0].adresse.instal[0],
                  strlen(GIVvInscrip.acDeppar)
                  );
    pvCrc->acDepart[strlen(GIVvInscrip.acDeppar)] = '\0';
    (void)strcpy ((char *)pvCrc->acNumloc,
                  (const char *)&doc->value.inscription[0].adresse.instal[strlen(GIVvInscrip.acDeppar)]);
    (void)strcpy ((char *)pvCrc->acNumnat,
                  (const char *)GIVvInscrip.acNumnat);


    for(i=0; i<nb_an9; i++)
    {
      /* rubrique courante */
      (void)strcpy ((char *)pvCrc->acCodan9,
                    (const char *)doc->value.rubriques.Tan9[i].val_codan9);

      /* Ouverture curseur SQL (car requete type SELECT) */
      (void)strcpy (vErreurSQL.acOrdre_sql,
                    "open crsLectureCRC");
      EXEC SQL
        open crsLectureCRC
        using :pvCrc->acDepart,
        :pvCrc->acNumloc,
        :pvCrc->acNumnat,
        :pvCrc->acCodan9
        ;

      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ((int4)GYBok != iIntRet)
      {
        /* Erreur sur declaration curseur SQL */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur OPEN crsLectureCRC ...\n"));

        iCodRet = (int4)GIXCodeKO;
      }
      else
      {
        /* Execution requete de denombrement (FETCH du curseur) */
        indFinFetch = (int1)GIXCodeOK;

        while ((int1)GIXCodeOK == indFinFetch)
        {
          (void)strcpy (vErreurSQL.acOrdre_sql,
                        "fetch crsLectureCRC");
          EXEC SQL
            fetch crsLectureCRC into
            :pvCrc->acCodCrc:pvIndCrc->sCodCrcI,
            :pvCrc->acLibCrc:pvIndCrc->sLibCrcI,
            :pvCrc->acNavCrc:pvIndCrc->sNavCrcI
            ;

          iIntRet = GIVBlocErreur (&vErreurSQL);

          /* Analyse du code retour SQL */
          switch (iIntRet)
          {
            case (int4)GYBok :
            {
              strcpy(doc->value.crc.trCrc[nb_crc].acCodCrc, GIVvCrc.acCodCrc);
              strcpy(doc->value.crc.trCrc[nb_crc].acLibCrc, GIVvCrc.acLibCrc);
              strcpy(doc->value.crc.trCrc[nb_crc].acNavCrc, GIVvCrc.acNavCrc);
              GWTTrace (GWT_NIV_FONCT,
                        (" CRC... %s ,%s ,%s\n", GIVvCrc.acCodCrc, GIVvCrc.acLibCrc, GIVvCrc.acNavCrc));
              nb_crc++;
              indFinFetch = (int1)GIXCodeOK;
              iCodRet = (int4)GIXCodeOK;
              break;
            }

            case (int4)GYBnodata :
            {
              /* la localite n'existe pas */
              /* generer une signalisation */

              indFinFetch = (int1)GIXCodeKO;
              iCodRet = (int4)GIXCodeKO;
              break;
            }

            default :
            {
              /* la consultation de la base s'est mal passee */
              GWTTrace (GWT_NIV_GRAVE,
                        ("Erreur execute rqtLectureCRC : [COD=%d TXT=%s]\n",
                         iIntRet,
                         vErreurSQL.acDonnees_retour));
              indFinFetch = (int1)GIXCodeKO;
              iCodRet = (int4)GIXCodeKO;
              break;
            }
          }
        }

        /* Fermeture du curseur */
        (void)strcpy (vErreurSQL.acOrdre_sql,
                      "close crsLectureCRC");
        EXEC SQL
          close crsLectureCRC;

        iIntRet = GIVBlocErreur (&vErreurSQL);
        if ((int4)GYBok != iIntRet)
        {
          /* Erreur sur fermeture curseur SQL */
          GWTTrace (GWT_NIV_GRAVE,
                    ("Erreur CLOSE crsLectureCRC ...\n"));
        }
        /* an9 suivant */
      }
    }
  }
  doc->value.crc.iNbCrc = nb_crc;
  /* Sortie de la fonction */
  GWTTrace (GWT_NIV_FONCT,
            ("GIVLectureCRC\n"));


  /* Sortie de la fonction givMefCRC */
  return (iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givMefPublicite ()                                             */
/*                                                                            */
/* But       : Mise en forme de l'ensemble "publicite"                        */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Modification (Nov/14/1997 lgu) : V2 ajout objet 11 micro                   */
/*                                                                            */
/*----------------------------------------------------------------------------*/


static int4 givMefPublicite (GYBrDOCUMENT *doc, int4 indice)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  nat2        usSaveLgMod     = 0;
  /* longueur d'un sous ensemble TLV module */
  nat2        usSaveLgNoy     = 0;
  /* longueur d'un sous ensemble TLV noyau */
  nat2        usSaveLgMic     = 0;            /** -- V2 lgu 14/11/1997 -- */
  /* longueur d'un sous ensemble TLV objet micro */
  nat2        usSaveLgEnsMod  = 0;
  /* longueur d'un ensemble TL module */
  nat2        usSaveLgEnsNoy  = 0;
  /* longueur d'un ensemble TL noyau */
  nat2        usSaveLgEnsPub  = 0;
  /* longueur d'un ensemble TL publicite */
  nat2        usSaveLgEnsMic  = 0;            /** -- V2 lgu 14/11/1997 -- */
  /* longueur d'un ensemble TL objet micro */
  nat2        usLgPubTot      = 0;
  /* longueur de travail */
  int4                   giviInsertTLV   = 0;
  /* indice de deplacement dans le tableau de depart */
  char                  cTypeObjMicro = 0;
  /* type d'objet micro */ /** -- V2 lgu 27/11/1997 -- */
  char                  cNoyauCondense[8 + 1];
  /* zone receptrice du compactage du numero de noyau */
  char                  cModuleCondense[8 + 1];
  /* zone receptrice du compactage du numero de module */
  char                  cMicroCondense[8 + 1];            /** -- V2 lgu 14/11/1997 -- */
  /* zone receptrice du compactage du numero d'objet micro */
  char tcType[2+1];

  nb_noyau = 0;
  nb_micro = 0;
  nb_module = 0;
  /* Traitement des noyaux */
  /**----------------------*/
  /* N'appeler la mise en forme de l'ensemble de noyaux que s'il existe des noyaux */
  if (GIXCodeOK == (int1)GIVcPresenceNoyau)
  {
    /* initialiser l'indice de deplacement dans le tableau de depart */
    giviInsertTLV = 0;

    GWTTrace (GWT_NIV_FONCT,
              ("NOYAU EXISTE : %s\n", doc->value.objets_pub.noyau[nb_noyau].type));


    while(giviInsertTLV < GIViNbTupleIanoy)
    {

      /* encodage TLV du type d'objet */
      doc->value.objets_pub.noyau[nb_noyau].type[0] = givcTypNoyau;

      GWTTrace (GWT_NIV_FONCT,
                ("TYPE : %s\n", doc->value.objets_pub.noyau[nb_noyau].type));


      /* encodage TLV du sous-type d'objet */
      strcpy(doc->value.objets_pub.noyau[nb_noyau].stype, GIVtrNoyau[giviInsertTLV].acGstaff);
      GWTTrace (GWT_NIV_FONCT,
                ("STYPE : %s\n", doc->value.objets_pub.noyau[nb_noyau].stype));


      /* encodage TLV du numero d'objet (noyau) apres appel de la fonction de compactage */
      GWCCompacterIdObj(GIVtrNoyau[giviInsertTLV].acNoyau, cNoyauCondense);
      strcpy(doc->value.objets_pub.noyau[nb_noyau].id, GIVtrNoyau[giviInsertTLV].acNoyau);
      GWTTrace (GWT_NIV_FONCT,
                ("STYPE : %s\n", doc->value.objets_pub.noyau[nb_noyau].stype));

      nb_noyau++;
      giviInsertTLV ++;
    }

  }

  /* traitement des modules */
  /**-----------------------*/
  /* N'appeler la mise en forme de l'ensemble de modules que s'il existe des modules */
  if (GIXCodeOK == (int1)GIVcPresenceModule)
  {
    /* initialiser l'indice de deplacement dans le tableau de depart */
    giviInsertTLV = 0;
    GWTTrace (GWT_NIV_FONCT,
              ("MODULE EXISTE : %s\n", doc->value.objets_pub.module[nb_module].type));



    while(giviInsertTLV < GIViNbTupleIamod)
    {

      /* encodage TLV du type d'objet pour les modules */
      doc->value.objets_pub.module[nb_module].type[0] = givcTypModule;

      GWTTrace (GWT_NIV_FONCT,
                ("TYPE : %s\n", doc->value.objets_pub.module[nb_module].type));


      /* encodage TLV du sous-type d'objet (type de module) */
      strcpy(doc->value.objets_pub.module[nb_module].stype, GIVtrModule[giviInsertTLV].acTypmod);
      GWTTrace (GWT_NIV_FONCT,
                ("STYPE : %s\n", doc->value.objets_pub.module[nb_module].stype));



      /* encodage TLV du module apres compactage du numero de module */
      GWCCompacterIdObj(GIVtrModule[giviInsertTLV].acModule, cModuleCondense);
      strcpy(doc->value.objets_pub.module[nb_module].id, GIVtrModule[giviInsertTLV].acModule);
      GWTTrace (GWT_NIV_FONCT,
                ("ID_PUB : %s\n", doc->value.objets_pub.module[nb_module].id));

      nb_module++;
      giviInsertTLV ++;
    }

  }

/** -- V2 lgu 14/11/1997 -- */
  /* Traitement des objet publicitaire 11 Micro */
  /**-------------------------------------------*/
  /* N'appeler la mise en forme de l'ensemble d'objet 11 micro que s'il en existe */
  if (GIXCodeOK == (int1)GIVcPresenceObjMicro)
  {
    /* initialiser l'indice de deplacement dans le tableau de depart */
    giviInsertTLV = 0;

    GWTTrace (GWT_NIV_FONCT,
              ("MICRO EXISTE : %s\n", doc->value.objets_pub.noyau[nb_micro].type));



    while(giviInsertTLV < GIViNbTupleIamic)
    {

      /* encodage TLV du type d'objet */
      switch( GIVtrObjMicro[giviInsertTLV].acTypobj[0] )
      {
        case 'N' :
          cTypeObjMicro = 'C';
          break;
        case 'M' :
          cTypeObjMicro = 'X';
          break;
        default :
          cTypeObjMicro = GIVtrObjMicro[giviInsertTLV].acTypobj[0];
          break;
      }

      /* Encodage du type */
      doc->value.objets_pub.micro[nb_micro].type[0] = cTypeObjMicro;
      GWTTrace (GWT_NIV_FONCT,
                ("TYPE : %s\n", doc->value.objets_pub.micro[nb_micro].type));


      /* encodage TLV de la date d'activation */
      strcpy(doc->value.objets_pub.micro[nb_micro].tcdatact, GIVtrObjMicro[giviInsertTLV].acDatact);

      /* type de CVI */
      doc->value.objets_pub.micro[nb_micro].iCVI = GIVtrObjMicro[giviInsertTLV].iFlagCVI;
      strcpy(doc->value.objets_pub.micro[nb_micro].stypcvi, GIVtrObjMicro[giviInsertTLV].acTpdcvi);

      /* encodage TLV du sous-type d'objet */
      strcpy(doc->value.objets_pub.micro[nb_micro].stype, GIVtrObjMicro[giviInsertTLV].acTpdobj);

      /* encodage TLV du sous-type interne d'objet */
      strcpy(doc->value.objets_pub.micro[nb_micro].stypint, GIVtrObjMicro[giviInsertTLV].acTpobint);
      GWTTrace (GWT_NIV_FONCT,
                ("STYPINT : %s\n", doc->value.objets_pub.micro[nb_micro].stypint));

      /* Si sous-type sur un caractère, mettre un blanc devant */
      if ( strlen(doc->value.objets_pub.micro[nb_micro].stype) == 1 )
      {
        doc->value.objets_pub.micro[nb_micro].stype[1] = doc->value.objets_pub.micro[nb_micro].stype[0];
        doc->value.objets_pub.micro[nb_micro].stype[0] = ' ';
      }
      GWTTrace (GWT_NIV_FONCT,
                ("STYPE : %s\n", doc->value.objets_pub.micro[nb_micro].stype));

      /* encodage TLV du sous-sous-type d'objet */
      /********************* OA11 ******************/
      if (0 ==  strlen(GIVtrObjMicro[giviInsertTLV].acStobj))
      {
        strcpy(doc->value.objets_pub.micro[nb_micro].sstype, doc->value.objets_pub.micro[nb_micro].stype);
      }
      else
      {
        strcpy(doc->value.objets_pub.micro[nb_micro].sstype, GIVtrObjMicro[giviInsertTLV].acStobj);
      }
      doc->value.objets_pub.micro[nb_micro].valeur[0] ='\0';
      GWTTrace (GWT_NIV_FONCT,
                ("SSTYPE : %s\n", doc->value.objets_pub.micro[nb_micro].sstype));

      GWC_ISO88591_To_MajSansAccent ((unsigned char *)doc->value.objets_pub.micro[nb_micro].stype, (unsigned char *) tcType);

      if (0 == strcmp(doc->value.objets_pub.micro[nb_micro].stype, tcType))
      {
        /* encodage TLV du numero d'objet micro apres appel de la fonction de compactage */
        GWCCompacterIdObj(GIVtrObjMicro[giviInsertTLV].acNumobj, cMicroCondense);
        strcpy(doc->value.objets_pub.micro[nb_micro].id, GIVtrObjMicro[giviInsertTLV].acNumobj);
        GWTTrace (GWT_NIV_FONCT,
                  ("ID : %s\n", doc->value.objets_pub.micro[nb_micro].id));

        nb_micro++;
      }
      giviInsertTLV ++;
    }
    doc->value.objets_pub.nb_micro = nb_micro;
  }
  /* Sortie de la fonction */
  return(iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givMefEnsemble ()                                              */
/*                                                                            */
/* But       : Mise en forme de l'ensemble                                    */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Modification (Nov/14/1997 lgu) : V2 ajout objet 11 micro                   */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 givMefEnsemble (GYBrDOCUMENT *doc, int4 indice)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */
  int4           i,j,k,q ;                             /* indice boucle doubles */
  GYBrMouvementsT rMouvement;
  /* init données de tri en sous-blocs */
     doc->iIndice = indice;
     doc->iRang = (int4)0;

  iCodRet = givMefDonneesGestion(doc, indice);

  iCodRet = givMefDonneesParution(doc, indice);

  iCodRet = givMefMoyensTelecom(doc, indice);

  iCodRet = givMefLieuParution(doc, indice);

  /* Initialisation du nombre d'An9 */
  nb_an9 = 0;
  nb_marque = 0;

  /* Lecture de la table liens codes AN8 */
  /* et de la table liens Epj AN8 si IO */
  if ( ((-1 != GIVvIndInscrip.sIndprfI)  &&
      ('1' == GIVvInscrip.acIndprf[0])) ||
      ((0 == strcmp("0000",doc->value.inscription[0].val_ls)) &&
      ((int4)GYBok ==  GIVvIndInscrip.sEtabI)) )
  {
      strcpy(rMouvement.acNumnat,GIVvInscrip.acNumnat);
      strcpy(rMouvement.acNumlo,GIVvInscrip.acNumlo);
      strcpy(rMouvement.acNumls,GIVvInscrip.acNumls);
      iIntRet = GIVLectureTabIAPROF (&rMouvement);

      if ((int4)GIXCodeOK != iIntRet)
      {
        /* Echec de la lecture de la table liens codes AN8 */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Echec lecture table liens codes AN8 ...\n"));
        iCodRet = (int4)GIXCodeKO;
      }
  }
  else
  {
    GIVcPresenceAn9 = (int1)GIXCodeKO;
    GIViNbTupleIaprof = (int4)0;
  }

  snprintf(GIVvGeocod.tcQualite,GIVGeocodLgQualite+1,"%2d",GIVGeocodQIgnorer);

  GIVvGeocod.iStatus = GIVGeocodSEnvRien;     /* par défaut rien n'est envoyé au CD */

  /* toute inscription est géocodée au CG2G */
  GWTTrace (GWT_NIV_FONCT,("Appel de GIVGeocod...\n"));
  GIVGeocod(&GIVvGeocod,GIXcDepartement);   /* à partir de IEINSC structure rGeocod */

  iCodRet = givMefProfessionnel(doc, indice);

  iCodRet = givMefLieuInstallation(doc, indice);

  /* géocodage du centre de localité */
  GIVvGeocod.iStatus = GIVGeocodSEnvRien;     /* par défaut rien */
  strcpy(GIVvGeocod.tcQualite,doc->value.inscription[0].adresse.geoloc.precision);

  iCodRet = GIVGeoCentreLoc(&GIVvGeocod);

  if ((GIVGeocodSEnvXYQ == GIVvGeocod.iStatus) || (GIVGeocodSEnvXY == GIVvGeocod.iStatus))
  {
    strcpy(doc->value.inscription[0].adresse.centreloc.precision, GIVvGeocod.tcQualite);
    GWTTrace (GWT_NIV_FONCT,
            ("QUALITE Centre : %s\n", doc->value.inscription[0].adresse.centreloc.precision));
    strcpy(doc->value.inscription[0].adresse.centreloc.precision, "0");
    strcpy(doc->value.inscription[0].adresse.centreloc.longitude, GIVvGeocod.tcLongitude);
    GWTTrace (GWT_NIV_FONCT,
              ("LONGITUDE Centre : %s\n", doc->value.inscription[0].adresse.centreloc.longitude));

    strcpy(doc->value.inscription[0].adresse.centreloc.latitude, GIVvGeocod.tcLatitude);
    GWTTrace (GWT_NIV_FONCT,
              ("LATITUDE Centre : %s\n", doc->value.inscription[0].adresse.centreloc.latitude));
  }

  /* Initialisation du nombre d'objets publicitaires */
  nb_noyau = 0;
  nb_micro = 0;
  nb_module = 0;

  if ((GIXCodeOK == (int1)GIVcPresenceNoyau)
      || (GIXCodeOK == (int1)GIVcPresenceModule)
      || (GIXCodeOK == (int1)GIVcPresenceObjMicro))
  {
    iCodRet = givMefPublicite(doc, indice);
  }


  /* Initialisation du nombre de crc */
  if (0 != nb_an9)
  {
    doc->value.crc.iNbCrc = 0;
  }

  /* anotation de l'intitulé */
  if (-1 != GIVvIndInscrip.sIntlAnnotI)
  {
    strcpy(doc->value.intitule.tcIntlAnnot,GIVvInscrip.acIntlAnnot);
  }

  /* Sortie de la fonction */
  return(iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givMefProfInstal ()                                                */
/*                                                                            */
/* But       : Mise en forme dues associations rub.geo                        */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Modification :                                                             */
/*                                                                            */
/*----------------------------------------------------------------------------*/

static int4 givMefProfInstal (GYBrDOCUMENT *doc, int4 aindice)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */
  int4           iFusRet = GWCCodeKO;            /* Code retour interne localité fusionnée */
  int4           i,j,k,l,iIdx = 0;                       /* Index de boucle */
  int4 iGeo;
  int4 iNbrParu,iNbrParuMax,iNbrInst,iNbrInstMax;
  /* indicateurs de sélection géographique */

  if ((0 != strlen(doc->value.rubriques.depact)) && (0 != strlen(doc->value.rubriques.locact)))
  {
    /* utilisation des données d'activité */
    strcpy(doc->value.inscription[0].cCoddep, doc->value.rubriques.depact);
    strcpy(doc->value.inscription[0].cCodloc, doc->value.rubriques.locact);
    /* arrondissement */
    strcpy(doc->value.inscription[0].cArrond,doc->value.rubriques.arract);
  }

  /* géographie sur première rubrique */
  k = 0;
  iNbrParu = givrListParu.iNbr;
  iNbrInst = givrListInst.iNbr;

  if ((MAX_LIST == givrListInst.iNbr) || (MAX_LIST == givrListParu.iNbr))
  {
    /* Trop d'entrées internes */
    GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
    /* Sortie de la fonction */
    return(iCodRet);
  }
  if (0 != strlen(doc->value.inscription[0].cCoddep))
  {
    /* arrondissement d'installation */
    iGeo = givrListInst.iNbr;
    (void)strcpy(givrListInst.trEltList[iGeo].rub,doc->value.rubriques.Tan9[k].val_codan9);
    (void)strcpy(givrListInst.trEltList[iGeo].dep,doc->value.inscription[0].cCoddep);
    if (0 != strcmp (givcLocFictive,doc->value.inscription[0].cCodloc))
    {
      (void)strcpy(givrListInst.trEltList[iGeo].loc,doc->value.inscription[0].cCodloc);
    }
    else
    {
      (void)strcpy(givrListInst.trEltList[iGeo].loc,givcLocIndf);
    }
    (void)strcpy(givrListInst.trEltList[iGeo].arr,doc->value.inscription[0].cArrond);
    /* région */
    iIntRet =  givLectureTabRegion (doc->value.inscription[0].cCoddep);
    if ((int4)GIXCodeOK == iIntRet)
    {
      (void)strcpy(givrListInst.trEltList[iGeo].reg,GIVvRegion.acRegion);
    }
    else
    {
      (void)strcpy(givrListInst.trEltList[iGeo].reg,"99");
    }
    (void)strcpy(doc->value.inscription[0].cReg,givrListInst.trEltList[iGeo].reg);
    (void)strcpy(doc->value.inscription[0].cAncReg,givrListInst.trEltList[iGeo].reg);
    (void)strcpy(doc->value.inscription[0].cLocFus,"");
    givrListInst.trEltList[iGeo].iRgLigne = aindice;
    givrListInst.trEltList[iGeo].iGeo = 99;
    givrListInst.trEltList[iGeo].iGeoReg = 99;
    givrListInst.trEltList[iGeo].iGeoDept = 99;
    givrListInst.trEltList[iGeo].iGeoLoc = 99;
    givrListInst.trEltList[iGeo].iGeoArr = 99;
    givrListInst.trEltRangList[iGeo] = iGeo;
    givrListInst.iNbr++;
    if (0 == strlen(givrListInst.trEltList[iGeo].arr))
    {
      (void)strcpy(givrListInst.trEltList[iGeo].arr,"99");
    }
    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIXCodeOK == iIntRet) && (MAX_LIST != givrListInst.iNbr))
    {
    	/* ancienne région */
      (void)strcpy(doc->value.inscription[0].cAncReg,GIVvRegion.acAncReg);
    	memcpy(&givrListInst.trEltList[iGeo+1],&givrListInst.trEltList[iGeo], sizeof(givrEltListT));
      strcpy(givrListInst.trEltList[iGeo+1].reg, GIVvRegion.acAncReg);
      givrListInst.trEltRangList[iGeo+1] = iGeo+1;
      givrListInst.iNbr++;
    }
    /* localité fusionnée */
    iFusRet =  givLectureTabLocFus (doc->value.inscription[0].cCoddep, doc->value.inscription[0].cCodloc);
    if ((int4)GIXCodeOK == iFusRet)
    {
  if (MAX_LIST == givrListInst.iNbr)
  {
    /* Trop d'entrées internes */
    GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
    /* Sortie de la fonction */
    iCodRet = GWCCodeKO;
    return(iCodRet);
  }
      (void)strcpy(doc->value.inscription[0].cLocFus,GIVvPole.acLocPole);
    	memcpy(&givrListInst.trEltList[givrListInst.iNbr],&givrListInst.trEltList[iGeo], sizeof(givrEltListT));
      (void)strcpy(givrListInst.trEltList[givrListInst.iNbr].dep,GIVvPole.acDepPole);
      (void)strcpy(givrListInst.trEltList[givrListInst.iNbr].loc,GIVvPole.acLocPole);
      givrListInst.trEltRangList[givrListInst.iNbr] = givrListInst.iNbr;
      givrListInst.iNbr++;
    }
  }
  else if ((0 == strlen(doc->value.inscription[0].cCoddep)) && (0 != strcmp (givcDepFictif,doc->value.inscription[0].cDeppar)))
  {
    /* arrondisement d'installation */
    iGeo = givrListInst.iNbr;
    (void)strcpy(givrListInst.trEltList[iGeo].rub,doc->value.rubriques.Tan9[k].val_codan9);
    (void)strcpy(givrListInst.trEltList[iGeo].dep,doc->value.inscription[0].cDeppar);
    if (0 != strcmp (givcLocFictive,doc->value.inscription[0].cLocpar))
    {
      (void)strcpy(givrListInst.trEltList[iGeo].loc,doc->value.inscription[0].cLocpar);
    }
    else
    {
      (void)strcpy(givrListInst.trEltList[iGeo].loc,givcLocIndf);
    }
    (void)strcpy(givrListInst.trEltList[iGeo].arr,doc->value.inscription[0].cArrond);
    /* région */
    iIntRet =  givLectureTabRegion (doc->value.inscription[0].cDeppar);
    if ((int4)GIXCodeOK == iIntRet)
    {
      (void)strcpy(givrListInst.trEltList[iGeo].reg,GIVvRegion.acRegion);
    }
    else
    {
      (void)strcpy(givrListInst.trEltList[iGeo].reg,"99");
    }
    (void)strcpy(doc->value.inscription[0].cReg,givrListInst.trEltList[iGeo].reg);
    (void)strcpy(doc->value.inscription[0].cAncReg,givrListInst.trEltList[iGeo].reg);
    givrListInst.trEltList[iGeo].iRgLigne = aindice;
    givrListInst.trEltList[iGeo].iGeo = 99;
    givrListInst.trEltList[iGeo].iGeoReg = 99;
    givrListInst.trEltList[iGeo].iGeoDept = 99;
    givrListInst.trEltList[iGeo].iGeoLoc = 99;
    givrListInst.trEltList[iGeo].iGeoArr = 99;
    givrListInst.trEltRangList[iGeo] = iGeo;
    givrListInst.iNbr++;
    if (0 == strlen(givrListInst.trEltList[iGeo].arr))
    {
      (void)strcpy(givrListInst.trEltList[iGeo].arr,"99");
    }
    i = iGeo;
    GWTTrace (GWT_NIV_FONCT, ("Installation 1 [%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\n", givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc, givrListInst.trEltList[i].iGeoArr));
    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIXCodeOK == iIntRet) && (MAX_LIST != givrListInst.iNbr))
    {
    	/* ancienne région */
      (void)strcpy(doc->value.inscription[0].cAncReg,GIVvRegion.acAncReg);
    	memcpy(&givrListInst.trEltList[iGeo+1],&givrListInst.trEltList[iGeo], sizeof(givrEltListT));
      strcpy(givrListInst.trEltList[iGeo+1].reg, GIVvRegion.acAncReg);
      givrListInst.trEltRangList[iGeo+1] = iGeo+1;
      givrListInst.iNbr++;
    }
    /* localité fusionnée */
    if (0 != strcmp (givcLocFictive,doc->value.inscription[0].cLocpar))
    {
      iFusRet =  givLectureTabLocFus (doc->value.inscription[0].cDeppar, doc->value.inscription[0].cLocpar);
    }
    if ((int4)GIXCodeOK == iFusRet)
    {
  if (MAX_LIST == givrListInst.iNbr)
  {
    /* Trop d'entrées internes */
    GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
    /* Sortie de la fonction */
    iCodRet = GWCCodeKO;
    return(iCodRet);
  }
      (void)strcpy(doc->value.inscription[0].cLocFus,GIVvPole.acLocPole);
    	memcpy(&givrListInst.trEltList[givrListInst.iNbr],&givrListInst.trEltList[iGeo], sizeof(givrEltListT));
      (void)strcpy(givrListInst.trEltList[givrListInst.iNbr].dep,GIVvPole.acDepPole);
      (void)strcpy(givrListInst.trEltList[givrListInst.iNbr].loc,GIVvPole.acLocPole);
      givrListInst.trEltRangList[givrListInst.iNbr] = givrListInst.iNbr;
      givrListInst.iNbr++;
      i = givrListInst.iNbr-1;
    GWTTrace (GWT_NIV_FONCT, ("Installation 2 [%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\n", givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc, givrListInst.trEltList[i].iGeoArr));
    }
  }

    /* arrondisement de parution */
    iGeo = givrListParu.iNbr;
    (void)strcpy(givrListParu.trEltList[iGeo].rub,doc->value.rubriques.Tan9[k].val_codan9);
    (void)strcpy(givrListParu.trEltList[iGeo].rubinit,doc->value.rubriques.Tan9[k].val_codan8);
    (void)strcpy(givrListParu.trEltList[iGeo].nature,doc->value.rubriques.Tan9[k].nature);
    givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;
    givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;
    (void)strcpy(givrListParu.trEltList[iGeo].dep,doc->value.inscription[0].cDeppar);
    (void)strcpy(givrListParu.trEltList[iGeo].loc,doc->value.inscription[0].cLocpar);
    (void)strcpy(givrListParu.trEltList[iGeo].arr,doc->value.inscription[0].cArrpar);
    /* région */
    iIntRet =  givLectureTabRegion (doc->value.inscription[0].cDeppar);
    if ((int4)GIXCodeOK == iIntRet)
    {
      (void)strcpy(givrListParu.trEltList[iGeo].reg,GIVvRegion.acRegion);
    }
    else
    {
      (void)strcpy(givrListParu.trEltList[iGeo].reg,"99");
    }
    givrListParu.trEltList[iGeo].iDbl = -1;
    givrListParu.trEltList[iGeo].iRgLigne = aindice;
    givrListParu.trEltList[iGeo].iGeo = 99;
    givrListParu.trEltList[iGeo].iGeoReg = 99;
    givrListParu.trEltList[iGeo].iGeoDept = 99;
    givrListParu.trEltList[iGeo].iGeoLoc = 99;
    givrListParu.trEltList[iGeo].iGeoArr = 99;
    givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
    givrListParu.trEltList[iGeo].iZU = (int4)GIXCodeKO;
    givrListParu.trEltRangList[iGeo] = iGeo;
    givrListParu.iNbr++;
    if (0 == strlen(givrListParu.trEltList[iGeo].arr))
    {
      (void)strcpy(givrListParu.trEltList[iGeo].arr,"99");
    }
    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))
    {
    	/* ancienne région */
    	memcpy(&givrListParu.trEltList[iGeo+1],&givrListParu.trEltList[iGeo], sizeof(givrEltListT));
      strcpy(givrListParu.trEltList[iGeo+1].reg, GIVvRegion.acAncReg);
        (void)strcpy(givrListParu.trEltList[iGeo+1].dep,"999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].loc,"99999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].arr,"99");
      givrListParu.trEltRangList[iGeo+1] = iGeo+1;
      givrListParu.iNbr++;
    }
    if ((0 != strlen(doc->value.inscription[0].cCoddep)) &&
    	(0 != strcmp (givcLocFictive,doc->value.inscription[0].cLocpar)) &&
    	( (0 != strcmp (doc->value.inscription[0].cCodloc,doc->value.inscription[0].cLocpar)) ||
    	(0 != strcmp (doc->value.inscription[0].cCoddep,doc->value.inscription[0].cDeppar)) ))
    {
      iFusRet =  givLectureTabLocFus (doc->value.inscription[0].cDeppar, doc->value.inscription[0].cLocpar);
    }
    if ((int4)GIXCodeOK == iFusRet)
    {
  if (MAX_LIST == givrListParu.iNbr)
  {
    /* Trop d'entrées internes */
    GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
    /* Sortie de la fonction */
    iCodRet = GWCCodeKO;
    return(iCodRet);
  }
    	memcpy(&givrListParu.trEltList[givrListParu.iNbr],&givrListParu.trEltList[iGeo], sizeof(givrEltListT));
      (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].dep,GIVvPole.acDepPole);
      (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].loc,GIVvPole.acLocPole);
      (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].arr,"99");
      givrListParu.trEltRangList[givrListParu.iNbr] = givrListParu.iNbr;
      givrListParu.iNbr++;
    }


  if ((0 == strcmp (givcLocFictive,doc->value.inscription[0].cLocpar)) && (0 != strcmp (givcLocFictive,doc->value.inscription[0].cCodloc)) && (0 == strcmp (doc->value.inscription[0].cCoddep,doc->value.inscription[0].cDeppar)))
  {
    /* arrondisement de parution */
    iGeo = givrListParu.iNbr;
    (void)strcpy(givrListParu.trEltList[iGeo].rub,doc->value.rubriques.Tan9[k].val_codan9);
    (void)strcpy(givrListParu.trEltList[iGeo].rubinit,doc->value.rubriques.Tan9[k].val_codan8);
    (void)strcpy(givrListParu.trEltList[iGeo].nature,doc->value.rubriques.Tan9[k].nature);
    givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;
    givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;
    (void)strcpy(givrListParu.trEltList[iGeo].dep,doc->value.inscription[0].cCoddep);
    (void)strcpy(givrListParu.trEltList[iGeo].loc,doc->value.inscription[0].cCodloc);
    (void)strcpy(givrListParu.trEltList[iGeo].arr,doc->value.inscription[0].cArrond);
    /* région */
    iIntRet =  givLectureTabRegion (doc->value.inscription[0].cDeppar);
    if ((int4)GIXCodeOK == iIntRet)
    {
      (void)strcpy(givrListParu.trEltList[iGeo].reg,GIVvRegion.acRegion);
    }
    else
    {
      (void)strcpy(givrListParu.trEltList[iGeo].reg,"99");
    }
    givrListParu.trEltList[iGeo].iDbl = -1;
    givrListParu.trEltList[iGeo].iRgLigne = (int4)GIXCodeKO ;
    givrListParu.trEltList[iGeo].iRgLigne = aindice ;
    givrListParu.trEltList[iGeo].iGeo = 99;
    givrListParu.trEltList[iGeo].iGeoReg = 99;
    givrListParu.trEltList[iGeo].iGeoDept = 99;
    givrListParu.trEltList[iGeo].iGeoLoc = 99;
    givrListParu.trEltList[iGeo].iGeoArr = 99;
    givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
    givrListParu.trEltList[iGeo].iZU = (int4)GIXCodeKO;
    givrListParu.trEltRangList[iGeo] = iGeo;
    givrListParu.iNbr++;
    if (0 == strlen(givrListParu.trEltList[iGeo].arr))
    {
      (void)strcpy(givrListParu.trEltList[iGeo].arr,"99");
    }
    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))
    {
    	/* ancienne région */
    	memcpy(&givrListParu.trEltList[iGeo+1],&givrListParu.trEltList[iGeo], sizeof(givrEltListT));
      strcpy(givrListParu.trEltList[iGeo+1].reg, GIVvRegion.acAncReg);
        (void)strcpy(givrListParu.trEltList[iGeo+1].dep,"999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].loc,"99999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].arr,"99");
      givrListParu.trEltRangList[iGeo+1] = iGeo+1;
      givrListParu.iNbr++;
    }
    if ((int4)GIXCodeOK == iFusRet)
    {
  if (MAX_LIST == givrListParu.iNbr)
  {
    /* Trop d'entrées internes */
    GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
    /* Sortie de la fonction */
    iCodRet = GWCCodeKO;
    return(iCodRet);
  }
    	memcpy(&givrListParu.trEltList[givrListParu.iNbr],&givrListParu.trEltList[iGeo], sizeof(givrEltListT));
      (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].dep,GIVvPole.acDepPole);
      (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].loc,GIVvPole.acLocPole);
      (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].arr,"99");
      givrListParu.trEltRangList[givrListParu.iNbr] = givrListParu.iNbr;
      givrListParu.iNbr++;
    }
  }

  /* Pole de zone urbaine */
  if ( ( (0 == strlen(doc->value.inscription[0].cCoddep)) && (0 != strcmp(doc->value.inscription[0].cLocpar,givcLocFictive)) ) || ( (0 != strcmp (givcLocFictive,doc->value.inscription[0].cCodloc)) && (0 != strlen(doc->value.inscription[0].cCoddep)) && (0 == memcmp(doc->value.inscription[0].cLocpar,doc->value.inscription[0].cCodloc,strlen(doc->value.inscription[0].cCodloc))) && (0 == memcmp(doc->value.inscription[0].cDeppar,doc->value.inscription[0].cCoddep,strlen(doc->value.inscription[0].cCoddep))) ) )
  {
    doc->iGeoLoc = giv_LOC;
    iIntRet =  givLectureTabZU (doc->value.inscription[0].cDeppar, doc->value.inscription[0].cLocpar);
    if ((MAX_LIST == givrListParu.iNbr) && ((int4)GIXCodeOK == iIntRet))
    {
      /* Trop d'entrées internes */
      GWTTrace (GWT_NIV_GRAVE,
          ("Taille liste interne dépassée\n"));
      iIntRet =  (int4)GIXCodeKO;
    }
    if ((int4)GIXCodeOK == iIntRet)
    {
      /* pole de parution */
      iGeo = givrListParu.iNbr;
      (void)strcpy(givrListParu.trEltList[iGeo].rub,doc->value.rubriques.Tan9[k].val_codan9);
      (void)strcpy(givrListParu.trEltList[iGeo].rubinit,doc->value.rubriques.Tan9[k].val_codan8);
      (void)strcpy(givrListParu.trEltList[iGeo].nature,doc->value.rubriques.Tan9[k].nature);
      givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;
      givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;
      (void)strcpy(givrListParu.trEltList[iGeo].dep,GIVvPole.acDepPole);
      (void)strcpy(givrListParu.trEltList[iGeo].loc,GIVvPole.acLocPole);
      (void)strcpy(givrListParu.trEltList[iGeo].arr,"00");
      /* région */
      iIntRet =  givLectureTabRegion (GIVvPole.acDepPole);
      if ((int4)GIXCodeOK == iIntRet)
      {
        (void)strcpy(givrListParu.trEltList[iGeo].reg,GIVvRegion.acRegion);
      }
      else
      {
        (void)strcpy(givrListParu.trEltList[iGeo].reg,"99");
      }
      givrListParu.trEltList[iGeo].iDbl = -1;
      givrListParu.trEltList[iGeo].iRgLigne = aindice ;
      givrListParu.trEltList[iGeo].iGeo = 99;
      givrListParu.trEltList[iGeo].iGeoReg = 99;
      givrListParu.trEltList[iGeo].iGeoDept = 99;
      givrListParu.trEltList[iGeo].iGeoLoc = 99;
      givrListParu.trEltList[iGeo].iGeoArr = 99;
      givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
      givrListParu.trEltList[iGeo].iZU = (int4)GIXCodeOK;
      givrListParu.trEltRangList[iGeo] = iGeo;
      givrListParu.iNbr++;
    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))
    {
    	/* ancienne région */
    	memcpy(&givrListParu.trEltList[iGeo+1],&givrListParu.trEltList[iGeo], sizeof(givrEltListT));
      strcpy(givrListParu.trEltList[iGeo+1].reg, GIVvRegion.acAncReg);
        (void)strcpy(givrListParu.trEltList[iGeo+1].dep,"999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].loc,"99999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].arr,"99");
      givrListParu.trEltRangList[iGeo+1] = iGeo+1;
      givrListParu.iNbr++;
    }
    }
  }
  else
  {
    if ((0 == memcmp(doc->value.inscription[0].cDeppar,doc->value.inscription[0].cCoddep,strlen(doc->value.inscription[0].cCoddep))) || (0 == strlen(doc->value.inscription[0].cCoddep)))
    {
      if ((0 == strcmp (givcLocFictive,doc->value.inscription[0].cLocpar)) && (0 != strcmp (givcLocFictive,doc->value.inscription[0].cCodloc)) && (0 != strlen(doc->value.inscription[0].cCoddep)))
        {
          doc->iGeoLoc = giv_LOC;
        }
      else if (0 != strcmp (givcDepFictif,doc->value.inscription[0].cDeppar))
        {
          doc->iGeoLoc = giv_DEPT;
        }
      else
        {
          doc->iGeoLoc = giv_EXTL;
        }
        /* pôle de zone urbaine d'installation  */
        iIntRet =  givLectureTabZU (doc->value.inscription[0].cDeppar, doc->value.inscription[0].cCodloc);
        if ((MAX_LIST == givrListParu.iNbr) && ((int4)GIXCodeOK == iIntRet))
        {
          /* Trop d'entrées internes */
          GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
          iIntRet =  (int4)GIXCodeKO;
        }
        if ((int4)GIXCodeOK == iIntRet)
        {
          /* pole de parution */
          iGeo = givrListParu.iNbr;
          (void)strcpy(givrListParu.trEltList[iGeo].rub,doc->value.rubriques.Tan9[k].val_codan9);
          (void)strcpy(givrListParu.trEltList[iGeo].rubinit,doc->value.rubriques.Tan9[k].val_codan8);
          (void)strcpy(givrListParu.trEltList[iGeo].nature,doc->value.rubriques.Tan9[k].nature);
          givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;
          givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;
          (void)strcpy(givrListParu.trEltList[iGeo].dep,GIVvPole.acDepPole);
          (void)strcpy(givrListParu.trEltList[iGeo].loc,GIVvPole.acLocPole);
          (void)strcpy(givrListParu.trEltList[iGeo].arr,"00");
          /* région */
          iIntRet =  givLectureTabRegion (GIVvPole.acDepPole);
          if ((int4)GIXCodeOK == iIntRet)
          {
            (void)strcpy(givrListParu.trEltList[iGeo].reg,GIVvRegion.acRegion);
          }
          else
          {
            (void)strcpy(givrListParu.trEltList[iGeo].reg,"99");
          }
          givrListParu.trEltList[iGeo].iDbl = -1;
          givrListParu.trEltList[iGeo].iRgLigne = aindice ;
          givrListParu.trEltList[iGeo].iGeo = 99;
          givrListParu.trEltList[iGeo].iGeoReg = 99;
          givrListParu.trEltList[iGeo].iGeoDept = 99;
          givrListParu.trEltList[iGeo].iGeoLoc = 99;
          givrListParu.trEltList[iGeo].iGeoArr = 99;
          givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
          givrListParu.trEltList[iGeo].iZU = (int4)GIXCodeOK;
          givrListParu.trEltRangList[iGeo] = iGeo;
          givrListParu.iNbr++;
    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))
    {
    	/* ancienne région */
    	memcpy(&givrListParu.trEltList[iGeo+1],&givrListParu.trEltList[iGeo], sizeof(givrEltListT));
      strcpy(givrListParu.trEltList[iGeo+1].reg, GIVvRegion.acAncReg);
        (void)strcpy(givrListParu.trEltList[iGeo+1].dep,"999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].loc,"99999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].arr,"99");
      givrListParu.trEltRangList[iGeo+1] = iGeo+1;
      givrListParu.iNbr++;
    }
        if (MAX_LIST == givrListParu.iNbr)
        {
          /* Trop d'entrées internes */
          GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
        }
        else if ((0 == strcmp (givcLocFictive,doc->value.inscription[0].cLocpar)) && (0 != strcmp (givcLocFictive,doc->value.inscription[0].cCodloc))
        	&& (0 != strlen(doc->value.inscription[0].cCoddep))
        	&& (0 == strcmp(doc->value.inscription[0].cDeppar,doc->value.inscription[0].cCoddep))
        	&& (0 == strcmp(doc->value.inscription[0].cDeppar,GIVvPole.acDepPole)))
        {
          GWTTrace (GWT_NIV_FONCT,
            ("ZU et LF : %s,%s,%s,%s,%s,%s\n", doc->value.inscription[0].cLocpar,
            doc->value.inscription[0].cDeppar,
            doc->value.inscription[0].cCoddep,
            doc->value.inscription[0].cCodloc,
            GIVvPole.acDepPole,GIVvPole.acLocPole));
          /* implicitement parution sur le pôle */
          (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].rub, givrListParu.trEltList[iGeo].rub);
          (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].rubinit, givrListParu.trEltList[iGeo].rubinit);
          (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].nature, givrListParu.trEltList[iGeo].nature);
          givrListParu.trEltList[givrListParu.iNbr].orig = givrListParu.trEltList[iGeo].orig;
          givrListParu.trEltList[givrListParu.iNbr].cParuloc = givrListParu.trEltList[iGeo].cParuloc;
          (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].dep,GIVvPole.acDepPole);
          (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].loc,GIVvPole.acLocPole);
          (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].arr,"00");
          /* région */
          if ((int4)GIXCodeOK == iIntRet)
          {
            (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].reg,GIVvRegion.acRegion);
          }
          else
          {
            (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].reg,"99");
          }
          givrListParu.trEltList[givrListParu.iNbr].iDbl = -1;
          givrListParu.trEltList[givrListParu.iNbr].iRgLigne = aindice ;
          givrListParu.trEltList[givrListParu.iNbr].iGeo = 99;
          givrListParu.trEltList[givrListParu.iNbr].iGeoReg = 99;
          givrListParu.trEltList[givrListParu.iNbr].iGeoDept = 99;
          givrListParu.trEltList[givrListParu.iNbr].iGeoLoc = 99;
          givrListParu.trEltList[givrListParu.iNbr].iGeoArr = 99;
          givrListParu.trEltList[givrListParu.iNbr].iLF = (int4)GIXCodeKO;
          givrListParu.trEltList[givrListParu.iNbr].iZU = (int4)GIXCodeKO;
          givrListParu.trEltRangList[givrListParu.iNbr] = givrListParu.iNbr;
          givrListParu.iNbr++;
        }


        }
    }
    else
    {
      doc->iGeoLoc = giv_EXTL;
      if (0 != strlen(doc->value.inscription[0].cCoddep))
      {
        /* pôle de zone urbaine d'installation  */
        iIntRet =  givLectureTabZU (doc->value.inscription[0].cCoddep, doc->value.inscription[0].cCodloc);
        if ((MAX_LIST == givrListParu.iNbr) && ((int4)GIXCodeOK == iIntRet))
        {
          /* Trop d'entrées internes */
          GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
          iIntRet =  (int4)GIXCodeKO;
        }
        if ((int4)GIXCodeOK == iIntRet)
        {
          /* pole de parution */
          iGeo = givrListParu.iNbr;
          (void)strcpy(givrListParu.trEltList[iGeo].rub,doc->value.rubriques.Tan9[k].val_codan9);
          (void)strcpy(givrListParu.trEltList[iGeo].rubinit,doc->value.rubriques.Tan9[k].val_codan8);
          (void)strcpy(givrListParu.trEltList[iGeo].nature,doc->value.rubriques.Tan9[k].nature);
          givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;
          givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;
          (void)strcpy(givrListParu.trEltList[iGeo].dep,GIVvPole.acDepPole);
          (void)strcpy(givrListParu.trEltList[iGeo].loc,GIVvPole.acLocPole);
          (void)strcpy(givrListParu.trEltList[iGeo].arr,"00");
          /* région */
          iIntRet =  givLectureTabRegion (GIVvPole.acDepPole);
          if ((int4)GIXCodeOK == iIntRet)
          {
            (void)strcpy(givrListParu.trEltList[iGeo].reg,GIVvRegion.acRegion);
          }
          else
          {
            (void)strcpy(givrListParu.trEltList[iGeo].reg,"99");
          }
          givrListParu.trEltList[iGeo].iDbl = -1;
          givrListParu.trEltList[iGeo].iRgLigne = aindice ;
          givrListParu.trEltList[iGeo].iGeo = 99;
          givrListParu.trEltList[iGeo].iGeoReg = 99;
          givrListParu.trEltList[iGeo].iGeoDept = 99;
          givrListParu.trEltList[iGeo].iGeoLoc = 99;
          givrListParu.trEltList[iGeo].iGeoArr = 99;
          givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
          givrListParu.trEltList[iGeo].iZU = (int4)GIXCodeOK;
          givrListParu.trEltRangList[iGeo] = iGeo;
          givrListParu.iNbr++;
    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))
    {
    	/* ancienne région */
    	memcpy(&givrListParu.trEltList[iGeo+1],&givrListParu.trEltList[iGeo], sizeof(givrEltListT));
      strcpy(givrListParu.trEltList[iGeo+1].reg, GIVvRegion.acAncReg);
        (void)strcpy(givrListParu.trEltList[iGeo+1].dep,"999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].loc,"99999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].arr,"99");
      givrListParu.trEltRangList[iGeo+1] = iGeo+1;
      givrListParu.iNbr++;
    }

        }
      }
    }
  }
  GWTTrace (GWT_NIV_FONCT,
            ("GeoLoc : %d\n", doc->value.rubriques.iNban9));

  /* géographie sur rubriques suivantes */
  iNbrInstMax = givrListInst.iNbr - iNbrInst;
  iNbrParuMax = givrListParu.iNbr - iNbrParu;

  for( k = 1 ; k < doc->value.rubriques.iNban9; k++)
  {
    for( l = 0 ; l < iNbrInstMax; l++)
    {
      iGeo = givrListInst.iNbr;
      if (MAX_LIST == iGeo)
      {
        /* Trop d'entrées internes */
        GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
        break;
      }
      (void)strcpy(givrListInst.trEltList[iGeo].rub,doc->value.rubriques.Tan9[k].val_codan9);
      (void)strcpy(givrListInst.trEltList[iGeo].dep,givrListInst.trEltList[iNbrInst+l].dep);
      (void)strcpy(givrListInst.trEltList[iGeo].loc,givrListInst.trEltList[iNbrInst+l].loc);
      (void)strcpy(givrListInst.trEltList[iGeo].arr,givrListInst.trEltList[iNbrInst+l].arr);
      (void)strcpy(givrListInst.trEltList[iGeo].reg,givrListInst.trEltList[iNbrInst+l].reg);
      givrListInst.trEltList[iGeo].iRgLigne = givrListInst.trEltList[iNbrInst+l].iRgLigne ;
      givrListInst.trEltList[iGeo].iGeo = 99;
      givrListInst.trEltList[iGeo].iGeoReg = 99;
      givrListInst.trEltList[iGeo].iGeoDept = 99;
      givrListInst.trEltList[iGeo].iGeoLoc = 99;
      givrListInst.trEltList[iGeo].iGeoArr = 99;
      givrListInst.trEltRangList[iGeo] = iGeo;
      givrListInst.iNbr++;
    }
    GWTTrace (GWT_NIV_FONCT,
            ("ParuLoc 0: %c\n", doc->value.rubriques.Tan9[k].paru));

    for( l = 0 ; l < iNbrParuMax; l++)
    {
      iGeo = givrListParu.iNbr;
      if (MAX_LIST == iGeo)
      {
        /* Trop d'entrées internes */
        GWTTrace (GWT_NIV_GRAVE,
              ("Taille liste interne dépassée\n"));
        break;
      }
      (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);
      (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);
      (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);
      givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;
      givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;
      GWTTrace (GWT_NIV_FONCT,
            ("ParuLoc 1: %c\n", givrListParu.trEltList[iGeo].cParuloc));
      (void)strcpy(givrListParu.trEltList[iGeo].dep,givrListParu.trEltList[iNbrParu+l].dep);
      (void)strcpy(givrListParu.trEltList[iGeo].loc,givrListParu.trEltList[iNbrParu+l].loc);
      (void)strcpy(givrListParu.trEltList[iGeo].arr,givrListParu.trEltList[iNbrParu+l].arr);
      (void)strcpy(givrListParu.trEltList[iGeo].reg,givrListParu.trEltList[iNbrParu+l].reg);
      givrListParu.trEltList[iGeo].iDbl = givrListParu.trEltList[iNbrParu+l].iDbl ;
      givrListParu.trEltList[iGeo].iRgLigne = givrListParu.trEltList[iNbrParu+l].iRgLigne ;
      givrListParu.trEltList[iGeo].iGeo = 99;
      givrListParu.trEltList[iGeo].iGeoReg = 99;
      givrListParu.trEltList[iGeo].iGeoDept = 99;
      givrListParu.trEltList[iGeo].iGeoLoc = 99;
      givrListParu.trEltList[iGeo].iGeoArr = 99;
      givrListParu.trEltList[iGeo].iZU = givrListParu.trEltList[iNbrParu+l].iZU;
      givrListParu.trEltList[iGeo].iLF = givrListParu.trEltList[iNbrParu+l].iLF;
      givrListParu.trEltRangList[iGeo] = iGeo;
      givrListParu.iNbr++;
    }

  }

  GWTTrace (GWT_NIV_FONCT,
            ("GeoLoc : %d\n", doc->iGeoLoc));
  GWTTrace (GWT_NIV_FONCT,
            (" Doubles %d,%d\n", givrListInst.iNbr,givrListParu.iNbr));
  /* Sortie de la fonction */
  return(iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givMefProfParu ()                                                */
/*                                                                            */
/* But       : Mise en forme des parutions rub.geo                        */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Modification :                                                             */
/*                                                                            */
/*----------------------------------------------------------------------------*/

extern int4 GIVMefProfParu (GYBrIaparuT *apIaparu, int4 aiDbl, int4 aiRef)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */
  int4           k = 0;                       /* Index de boucle */
  int4 iGeo, iIndice;
  GYBrDOCUMENT rDoc;
  GYBrDOCUMENT * doc;

  /* indicateurs de sélection géographique */
  doc = &rDoc;
  (void)strcpy(doc->value.inscription[0].cDeppar,apIaparu->acDeppar);
  (void)strcpy(doc->value.inscription[0].cLocpar,apIaparu->acLocpar);
  (void)strcpy(doc->value.inscription[0].cArrpar,apIaparu->acArrpar);
  (void)strcpy(doc->value.inscription[0].cCoddep,givrListInst.trEltList[aiRef].dep);
  (void)strcpy(doc->value.inscription[0].cCodloc,givrListInst.trEltList[aiRef].loc);
  (void)strcpy(doc->value.inscription[0].cArrond,givrListInst.trEltList[aiRef].arr);
  (void)strcpy(doc->value.rubriques.Tan9[0].val_codan9,givrListParu.trEltList[aiRef].rub);
  (void)strcpy(doc->value.rubriques.Tan9[0].val_codan8,givrListParu.trEltList[aiRef].rubinit);
  (void)strcpy(doc->value.rubriques.Tan9[0].nature,givrListParu.trEltList[aiRef].nature);
  doc->value.rubriques.Tan9[0].orig = givrListParu.trEltList[aiRef].orig;
  doc->value.rubriques.Tan9[0].paru = givrListParu.trEltList[aiRef].cParuloc;

    /* géographie sur première rubrique */
  k = 0;
  iIndice = 0;

    /* arrondisement de parution */
    iGeo = givrListParu.iNbr;
    (void)strcpy(givrListParu.trEltList[iGeo].rub,doc->value.rubriques.Tan9[k].val_codan9);
    (void)strcpy(givrListParu.trEltList[iGeo].rubinit,doc->value.rubriques.Tan9[k].val_codan8);
    (void)strcpy(givrListParu.trEltList[iGeo].nature,doc->value.rubriques.Tan9[k].nature);
    givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;
    givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;
    (void)strcpy(givrListParu.trEltList[iGeo].dep,doc->value.inscription[0].cDeppar);
    (void)strcpy(givrListParu.trEltList[iGeo].loc,doc->value.inscription[0].cLocpar);
    (void)strcpy(givrListParu.trEltList[iGeo].arr,doc->value.inscription[0].cArrpar);
    /* région */
    iIntRet =  givLectureTabRegion (doc->value.inscription[0].cDeppar);
    if ((int4)GIXCodeOK == iIntRet)
    {
      (void)strcpy(givrListParu.trEltList[iGeo].reg,GIVvRegion.acRegion);
    }
    else
    {
      (void)strcpy(givrListParu.trEltList[iGeo].reg,"99");
    }
    givrListParu.trEltList[iGeo].iDbl = aiDbl;
    givrListParu.trEltList[iGeo].iRgLigne = iIndice;
    givrListParu.trEltList[iGeo].iGeo = 99;
    givrListParu.trEltList[iGeo].iGeoReg = 99;
    givrListParu.trEltList[iGeo].iGeoDept = 99;
    givrListParu.trEltList[iGeo].iGeoLoc = 99;
    givrListParu.trEltList[iGeo].iGeoArr = 99;
    givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
    givrListParu.trEltList[iGeo].iZU = (int4)GIXCodeKO;
    givrListParu.trEltRangList[iGeo] = iGeo;
    givrListParu.iNbr++;
    if (0 == strlen(givrListParu.trEltList[iGeo].arr))
    {
      (void)strcpy(givrListParu.trEltList[iGeo].arr,"99");
    }
    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))
    {
    	/* ancienne région */
    	memcpy(&givrListParu.trEltList[iGeo+1],&givrListParu.trEltList[iGeo], sizeof(givrEltListT));
      strcpy(givrListParu.trEltList[iGeo+1].reg, GIVvRegion.acAncReg);
        (void)strcpy(givrListParu.trEltList[iGeo+1].dep,"999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].loc,"99999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].arr,"99");
      givrListParu.trEltRangList[iGeo+1] = iGeo+1;
      givrListParu.iNbr++;
    }

  if ((0 == strcmp (givcLocFictive,doc->value.inscription[0].cLocpar)) && (0 != strcmp (givcLocFictive,doc->value.inscription[0].cCodloc)) && (0 == strcmp (doc->value.inscription[0].cCoddep,doc->value.inscription[0].cDeppar)))
  {
    /* arrondisement de parution */
    iGeo = givrListParu.iNbr;
    (void)strcpy(givrListParu.trEltList[iGeo].rub,doc->value.rubriques.Tan9[k].val_codan9);
    (void)strcpy(givrListParu.trEltList[iGeo].rubinit,doc->value.rubriques.Tan9[k].val_codan8);
    (void)strcpy(givrListParu.trEltList[iGeo].nature,doc->value.rubriques.Tan9[k].nature);
    givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;
    givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;
    (void)strcpy(givrListParu.trEltList[iGeo].dep,doc->value.inscription[0].cCoddep);
    (void)strcpy(givrListParu.trEltList[iGeo].loc,doc->value.inscription[0].cCodloc);
    (void)strcpy(givrListParu.trEltList[iGeo].arr,doc->value.inscription[0].cArrond);
    /* région */
    iIntRet =  givLectureTabRegion (doc->value.inscription[0].cDeppar);
    if ((int4)GIXCodeOK == iIntRet)
    {
      (void)strcpy(givrListParu.trEltList[iGeo].reg,GIVvRegion.acRegion);
    }
    else
    {
      (void)strcpy(givrListParu.trEltList[iGeo].reg,"99");
    }
    givrListParu.trEltList[iGeo].iDbl = aiDbl;
    givrListParu.trEltList[iGeo].iRgLigne = (int4)GIXCodeKO ;
    givrListParu.trEltList[iGeo].iGeo = 99;
    givrListParu.trEltList[iGeo].iGeoReg = 99;
    givrListParu.trEltList[iGeo].iGeoDept = 99;
    givrListParu.trEltList[iGeo].iGeoLoc = 99;
    givrListParu.trEltList[iGeo].iGeoArr = 99;
    givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
    givrListParu.trEltList[iGeo].iZU = (int4)GIXCodeKO;
    givrListParu.trEltRangList[iGeo] = iGeo;
    givrListParu.iNbr++;
    if (0 == strlen(givrListParu.trEltList[iGeo].arr))
    {
      (void)strcpy(givrListParu.trEltList[iGeo].arr,"99");
    }
    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))
    {
    	/* ancienne région */
    	memcpy(&givrListParu.trEltList[iGeo+1],&givrListParu.trEltList[iGeo], sizeof(givrEltListT));
      strcpy(givrListParu.trEltList[iGeo+1].reg, GIVvRegion.acAncReg);
        (void)strcpy(givrListParu.trEltList[iGeo+1].dep,"999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].loc,"99999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].arr,"99");
      givrListParu.trEltRangList[iGeo+1] = iGeo+1;
      givrListParu.iNbr++;
    }
  }

  /* Pole de zone urbaine */
  if ( ( (0 == strlen(doc->value.inscription[0].cCoddep)) && (0 != strcmp(doc->value.inscription[0].cLocpar,givcLocFictive)) ) || ( (0 != strcmp (givcLocFictive,doc->value.inscription[0].cCodloc)) && (0 != strlen(doc->value.inscription[0].cCoddep)) && (0 == memcmp(doc->value.inscription[0].cLocpar,doc->value.inscription[0].cCodloc,strlen(doc->value.inscription[0].cCodloc))) && (0 == memcmp(doc->value.inscription[0].cDeppar,doc->value.inscription[0].cCoddep,strlen(doc->value.inscription[0].cCoddep))) ) )
  {
    doc->iGeoLoc = giv_LOC;
    iIntRet =  givLectureTabZU (doc->value.inscription[0].cDeppar, doc->value.inscription[0].cLocpar);
    if ((int4)GIXCodeOK == iIntRet)
    {
      /* pole de parution */
      iGeo = givrListParu.iNbr;
      (void)strcpy(givrListParu.trEltList[iGeo].rub,doc->value.rubriques.Tan9[k].val_codan9);
      (void)strcpy(givrListParu.trEltList[iGeo].rubinit,doc->value.rubriques.Tan9[k].val_codan8);
      (void)strcpy(givrListParu.trEltList[iGeo].nature,doc->value.rubriques.Tan9[k].nature);
      givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;
      givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;
      (void)strcpy(givrListParu.trEltList[iGeo].dep,GIVvPole.acDepPole);
      (void)strcpy(givrListParu.trEltList[iGeo].loc,GIVvPole.acLocPole);
      (void)strcpy(givrListParu.trEltList[iGeo].arr,"00");
      /* région */
      iIntRet =  givLectureTabRegion (GIVvPole.acDepPole);
      if ((int4)GIXCodeOK == iIntRet)
      {
        (void)strcpy(givrListParu.trEltList[iGeo].reg,GIVvRegion.acRegion);
      }
      else
      {
        (void)strcpy(givrListParu.trEltList[iGeo].reg,"99");
      }
      givrListParu.trEltList[iGeo].iDbl = aiDbl;
      givrListParu.trEltList[iGeo].iRgLigne = iIndice ;
      givrListParu.trEltList[iGeo].iGeo = 99;
      givrListParu.trEltList[iGeo].iGeoReg = 99;
      givrListParu.trEltList[iGeo].iGeoDept = 99;
      givrListParu.trEltList[iGeo].iGeoLoc = 99;
      givrListParu.trEltList[iGeo].iGeoArr = 99;
      givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
      givrListParu.trEltList[iGeo].iZU = (int4)GIXCodeOK;
      givrListParu.trEltRangList[iGeo] = iGeo;
      givrListParu.iNbr++;
    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))
    {
    	/* ancienne région */
    	memcpy(&givrListParu.trEltList[iGeo+1],&givrListParu.trEltList[iGeo], sizeof(givrEltListT));
      strcpy(givrListParu.trEltList[iGeo+1].reg, GIVvRegion.acAncReg);
        (void)strcpy(givrListParu.trEltList[iGeo+1].dep,"999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].loc,"99999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].arr,"99");
      givrListParu.trEltRangList[iGeo+1] = iGeo+1;
      givrListParu.iNbr++;
    }
    }
  }
  else
  {
    if ((0 == memcmp(doc->value.inscription[0].cDeppar,doc->value.inscription[0].cCoddep,strlen(doc->value.inscription[0].cCoddep))) || (0 == strlen(doc->value.inscription[0].cCoddep)))
    {
      if ((0 == strcmp (givcLocFictive,doc->value.inscription[0].cLocpar)) && (0 != strcmp (givcLocFictive,doc->value.inscription[0].cCodloc)) && (0 != strlen(doc->value.inscription[0].cCoddep)))
        {
          doc->iGeoLoc = giv_LOC;
        }
      else if (0 != strcmp (givcDepFictif,doc->value.inscription[0].cDeppar))
        {
          doc->iGeoLoc = giv_DEPT;
        }
      else
        {
          doc->iGeoLoc = giv_EXTL;
        }
        /* pôle de zone urbaine d'installation  */
        iIntRet =  givLectureTabZU (doc->value.inscription[0].cDeppar, doc->value.inscription[0].cCodloc);
        if ((int4)GIXCodeOK == iIntRet)
        {
          /* pole de parution */
          iGeo = givrListParu.iNbr;
          (void)strcpy(givrListParu.trEltList[iGeo].rub,doc->value.rubriques.Tan9[k].val_codan9);
          (void)strcpy(givrListParu.trEltList[iGeo].rubinit,doc->value.rubriques.Tan9[k].val_codan8);
          (void)strcpy(givrListParu.trEltList[iGeo].nature,doc->value.rubriques.Tan9[k].nature);
          givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;
          givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;
          (void)strcpy(givrListParu.trEltList[iGeo].dep,GIVvPole.acDepPole);
          (void)strcpy(givrListParu.trEltList[iGeo].loc,GIVvPole.acLocPole);
          (void)strcpy(givrListParu.trEltList[iGeo].arr,"00");
          /* région */
          iIntRet =  givLectureTabRegion (GIVvPole.acDepPole);
          if ((int4)GIXCodeOK == iIntRet)
          {
            (void)strcpy(givrListParu.trEltList[iGeo].reg,GIVvRegion.acRegion);
          }
          else
          {
            (void)strcpy(givrListParu.trEltList[iGeo].reg,"99");
          }
          givrListParu.trEltList[iGeo].iDbl = aiDbl;
          givrListParu.trEltList[iGeo].iRgLigne = iIndice ;
          givrListParu.trEltList[iGeo].iGeo = 99;
          givrListParu.trEltList[iGeo].iGeoReg = 99;
          givrListParu.trEltList[iGeo].iGeoDept = 99;
          givrListParu.trEltList[iGeo].iGeoLoc = 99;
          givrListParu.trEltList[iGeo].iGeoArr = 99;
          givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
          givrListParu.trEltList[iGeo].iZU = (int4)GIXCodeOK;
          givrListParu.trEltRangList[iGeo] = iGeo;
          givrListParu.iNbr++;
    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))
    {
    	/* ancienne région */
    	memcpy(&givrListParu.trEltList[iGeo+1],&givrListParu.trEltList[iGeo], sizeof(givrEltListT));
      strcpy(givrListParu.trEltList[iGeo+1].reg, GIVvRegion.acAncReg);
        (void)strcpy(givrListParu.trEltList[iGeo+1].dep,"999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].loc,"99999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].arr,"99");
      givrListParu.trEltRangList[iGeo+1] = iGeo+1;
      givrListParu.iNbr++;
    }
        if ((0 == strcmp (givcLocFictive,doc->value.inscription[0].cLocpar)) && (0 != strcmp (givcLocFictive,doc->value.inscription[0].cCodloc)) && (0 != strlen(doc->value.inscription[0].cCoddep)))
        {
          /* implicitement parution sur le pôle */
          (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].rub, givrListParu.trEltList[iGeo].rub);
          (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].rubinit, givrListParu.trEltList[iGeo].rubinit);
          (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].nature, givrListParu.trEltList[iGeo].nature);
          givrListParu.trEltList[givrListParu.iNbr].orig = givrListParu.trEltList[iGeo].orig;
          givrListParu.trEltList[givrListParu.iNbr].cParuloc = givrListParu.trEltList[iGeo].cParuloc;
          (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].dep,GIVvPole.acDepPole);
          (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].loc,GIVvPole.acLocPole);
          (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].arr,"00");
          /* région */
          if ((int4)GIXCodeOK == iIntRet)
          {
            (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].reg,GIVvRegion.acRegion);
          }
          else
          {
            (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].reg,"99");
          }
          givrListParu.trEltList[givrListParu.iNbr].iDbl = aiDbl;
          givrListParu.trEltList[givrListParu.iNbr].iRgLigne = iIndice ;
          givrListParu.trEltList[givrListParu.iNbr].iGeo = 99;
          givrListParu.trEltList[givrListParu.iNbr].iGeoReg = 99;
          givrListParu.trEltList[givrListParu.iNbr].iGeoDept = 99;
          givrListParu.trEltList[givrListParu.iNbr].iGeoLoc = 99;
          givrListParu.trEltList[givrListParu.iNbr].iGeoArr = 99;
          givrListParu.trEltList[givrListParu.iNbr].iLF = (int4)GIXCodeKO;
          givrListParu.trEltList[givrListParu.iNbr].iZU = (int4)GIXCodeKO;
          givrListParu.trEltRangList[givrListParu.iNbr] = givrListParu.iNbr;
          givrListParu.iNbr++;
        }


        }
    }
    else
    {
      doc->iGeoLoc = giv_EXTL;
      if (0 != strlen(doc->value.inscription[0].cCoddep))
      {
        /* pôle de zone urbaine d'installation  */
        iIntRet =  givLectureTabZU (doc->value.inscription[0].cCoddep, doc->value.inscription[0].cCodloc);
        if ((int4)GIXCodeOK == iIntRet)
        {
          /* pole de parution */
          iGeo = givrListParu.iNbr;
          (void)strcpy(givrListParu.trEltList[iGeo].rub,doc->value.rubriques.Tan9[k].val_codan9);
          (void)strcpy(givrListParu.trEltList[iGeo].rubinit,doc->value.rubriques.Tan9[k].val_codan8);
          (void)strcpy(givrListParu.trEltList[iGeo].nature,doc->value.rubriques.Tan9[k].nature);
          givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;
          givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;
          (void)strcpy(givrListParu.trEltList[iGeo].dep,GIVvPole.acDepPole);
          (void)strcpy(givrListParu.trEltList[iGeo].loc,GIVvPole.acLocPole);
          (void)strcpy(givrListParu.trEltList[iGeo].arr,"00");
          /* région */
          iIntRet =  givLectureTabRegion (GIVvPole.acDepPole);
          if ((int4)GIXCodeOK == iIntRet)
          {
            (void)strcpy(givrListParu.trEltList[iGeo].reg,GIVvRegion.acRegion);
          }
          else
          {
            (void)strcpy(givrListParu.trEltList[iGeo].reg,"99");
          }
          givrListParu.trEltList[iGeo].iDbl = aiDbl;
          givrListParu.trEltList[iGeo].iRgLigne = iIndice ;
          givrListParu.trEltList[iGeo].iGeo = 99;
          givrListParu.trEltList[iGeo].iGeoReg = 99;
          givrListParu.trEltList[iGeo].iGeoDept = 99;
          givrListParu.trEltList[iGeo].iGeoLoc = 99;
          givrListParu.trEltList[iGeo].iGeoArr = 99;
          givrListParu.trEltList[iGeo].iLF = (int4)GIXCodeKO;
          givrListParu.trEltList[iGeo].iZU = (int4)GIXCodeOK;
          givrListParu.trEltRangList[iGeo] = iGeo;
          givrListParu.iNbr++;
    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))
    {
    	/* ancienne région */
    	memcpy(&givrListParu.trEltList[iGeo+1],&givrListParu.trEltList[iGeo], sizeof(givrEltListT));
      strcpy(givrListParu.trEltList[iGeo+1].reg, GIVvRegion.acAncReg);
        (void)strcpy(givrListParu.trEltList[iGeo+1].dep,"999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].loc,"99999");
        (void)strcpy(givrListParu.trEltList[iGeo+1].arr,"99");
      givrListParu.trEltRangList[iGeo+1] = iGeo+1;
      givrListParu.iNbr++;
    }

        }
      }
    }
  }

  GWTTrace (GWT_NIV_FONCT,
            ("GeoLocParu : %d\n", doc->iGeoLoc));
  GWTTrace (GWT_NIV_FONCT,
            ("Nb Parutions  %d,%d\n", givrListInst.iNbr,givrListParu.iNbr));
  /* Sortie de la fonction */
  return(iCodRet);
}

static int4 givMefMultProfParu (GYBrDOCUMENT *doc, int4 aiParuMax)
{
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */
  int4           k,l = 0;                       /* Index de boucle */
  int4 iGeo;
  int4 iNbrParu,iNbrParuMax;

  /* géographie sur rubriques suivantes */
  iNbrParu = givrListParu.iNbr - aiParuMax;
  iNbrParuMax = aiParuMax;

  for( k = 1 ; k < doc->value.rubriques.iNban9; k++)
  {

    for( l = 0 ; l < iNbrParuMax; l++)
    {
      iGeo = givrListParu.iNbr;
      (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);
      (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);
      (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);
      givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;
      givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;
      (void)strcpy(givrListParu.trEltList[iGeo].dep,givrListParu.trEltList[iNbrParu+l].dep);
      (void)strcpy(givrListParu.trEltList[iGeo].loc,givrListParu.trEltList[iNbrParu+l].loc);
      (void)strcpy(givrListParu.trEltList[iGeo].arr,givrListParu.trEltList[iNbrParu+l].arr);
      (void)strcpy(givrListParu.trEltList[iGeo].reg,givrListParu.trEltList[iNbrParu+l].reg);
      givrListParu.trEltList[iGeo].iDbl = givrListParu.trEltList[iNbrParu+l].iDbl ;
      givrListParu.trEltList[iGeo].iRgLigne = givrListParu.trEltList[iNbrParu+l].iRgLigne ;
      givrListParu.trEltList[iGeo].iGeo = 99;
      givrListParu.trEltList[iGeo].iGeoReg = 99;
      givrListParu.trEltList[iGeo].iGeoDept = 99;
      givrListParu.trEltList[iGeo].iGeoLoc = 99;
      givrListParu.trEltList[iGeo].iGeoArr = 99;
      givrListParu.trEltList[iGeo].iZU = givrListParu.trEltList[iNbrParu+l].iZU;
      givrListParu.trEltList[iGeo].iLF = givrListParu.trEltList[iNbrParu+l].iLF;
      givrListParu.trEltRangList[iGeo] = iGeo;
      givrListParu.iNbr++;
    }

  }

  GWTTrace (GWT_NIV_FONCT,
            ("GeoLocParu : %d\n", doc->iGeoLoc));
  GWTTrace (GWT_NIV_FONCT,
            ("Nb Parutions  %d,%d\n", givrListInst.iNbr,givrListParu.iNbr));
  /* Sortie de la fonction */
  return(iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givBlocs ()                                                    */
/*                                                                            */
/* But       : Ecriture des blocs                                             */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Modification (Nov/14/1997 lgu) : V2 ajout objet 11 micro                   */
/*                                                                            */
/*----------------------------------------------------------------------------*/


static int4 givBlocs (char **buf_pos_in, GYBrDOCUMENT *docEPJ, GYBrDOCUMENT *docIG, int4 indice)
{
  char *buf_pos;
  char *buf_pos_ref;
  char  *pcVersion = NULL;
  int4           iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4           iIntRet = GWCCodeOK;            /* Code retour interne */
  int4           i,j,k,l;                            /* indices de boucle */
  int4 lg_write;
  int4 iNbrInstMax, iNbrParuMax;
  int4 iNbMicro;
  GYBrIaparuT    rIaparu; /* accès GYTtabIaParu */

  buf_pos = *buf_pos_in;
  /* Pointeur sur debut du bloc */
  buf_pos_ref = buf_pos;

  iCodRet = giv_ecrit_partie_1(&buf_pos, docIG,indice);
  if ((int4)GWCCodeOK == iCodRet)
  {GWTTrace (GWT_NIV_FONCT, ("ECRITURE PARTIE_1 ...\n")); }


  /* écriture de bloc */
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Parution [%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d],[%d\n", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].iRgLigne));
  }

  for(j=0; j<(givrListInst.iNbr); j++)
  {
    i = givrListInst.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Installation [%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\n", givrListInst.trEltList[i].iRangTri, givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc, givrListInst.trEltList[i].iGeoArr));
  }

  for(i=0; i<(indice); i++)
  {
    iCodRet = givMefProfInstal((docIG+i), i);
    (docIG+i)->iSource = 1;
  }
  /* Ajout des parutions multiples */
  for(i=0; i<(indice); i++)
  {
  if ( giv_cCHRO == (docIG+i)->value.inscription[0].val_num[0])
  {
    j = givrListParu.iNbr;
    (void)strcpy (rIaparu.acNumnat, (docIG+i)->value.inscription[0].val_num);
    (void)strcpy (rIaparu.acNumlo, (docIG+i)->value.inscription[0].val_lo);
    (void)strcpy (rIaparu.acNumls, (docIG+i)->value.inscription[0].val_ls);
    iCodRet = GIVLectureIAPARU (&rIaparu, 0);
    if (0 != (docIG+i)->value.rubriques.iNban9 && 1 != (docIG+i)->value.rubriques.iNban9)
    {
      iCodRet = givMefMultProfParu ((docIG+i), (givrListParu.iNbr-j));
    }
  }
  }

  /* Analyse ZU selon LF */
  iCodRet = givTriZU();
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Parution [%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d],[%d]\n", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgLigne, givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].iRgLigne));
  }

  for(j=0; j<(givrListInst.iNbr); j++)
  {
    i = givrListInst.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Installation [%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\n", givrListInst.trEltList[i].iRangTri, givrListInst.trEltList[i].iRgLigne, givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc, givrListInst.trEltList[i].iGeoArr));
  }

  /* nombre de CRC (balise <normale>) */
  giviNbCRC = 0;
  givrListCRC.iNbr = 0;
  /* objets par établissement */
  iNbMicro = docIG->value.objets_pub.nb_micro;
  /* lecture des objets de l'etablissement */
  iCodRet = givLectureObjetsEtab(docIG->value.a_classer.etab, docIG, indice);
  /* objets par établissement de type Grand Compte */
  strcpy(docIG->value.objets_pub.libUrlGCpt, "");
  /* lecture des objets de l'etablissement */
  iCodRet = givLectureObjetsGCpt(docIG->value.a_classer.etab, docIG, indice);
  iNbMicro = docIG->value.objets_pub.nb_micro - iNbMicro;
  /* ajout des objets de l'etablissement à chaque MC */
  for(i=1; i<indice; i++)
  {
    k = docIG->value.objets_pub.nb_micro - iNbMicro;
    l = (docIG+i)->value.objets_pub.nb_micro;
    for(j=0; j<iNbMicro; j++)
    {
        strcpy((docIG+i)->value.objets_pub.micro[l + j].type, "X");
        strcpy((docIG+i)->value.objets_pub.micro[l + j].stype, docIG->value.objets_pub.micro[k + j].stype);
        strcpy((docIG+i)->value.objets_pub.micro[l + j].sstype, docIG->value.objets_pub.micro[k + j].sstype);
        strcpy((docIG+i)->value.objets_pub.micro[l + j].id, docIG->value.objets_pub.micro[k + j].id);
        strcpy((docIG+i)->value.objets_pub.libUrlGCpt, docIG->value.objets_pub.libUrlGCpt);
    }
    (docIG+i)->value.objets_pub.nb_micro = l + iNbMicro;
  }

  /* description des objets au niveau global du bloc epj */
  iIntRet = givInitTriObj (docIG,indice, giv_RUB);

  iCodRet = giv_ecrit_partie_2_1(&buf_pos, docEPJ, docIG, indice);
  if ((int4)GWCCodeOK == iCodRet)
  {GWTTrace (GWT_NIV_FONCT, ("ECRITURE PARTIE_2_1 ...\n")); }

  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Parution [%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d],[%d],[%d]\n", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].iDbl, givrListParu.trEltList[i].iRgLigne));
  }

  for(j=0; j<(givrListInst.iNbr); j++)
  {
    i = givrListInst.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Installation [%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\n", givrListInst.trEltList[i].iRangTri, givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc, givrListInst.trEltList[i].iGeoArr));
  }

  lg_write = giv_ecrit_noeud_simple(buf_pos,"parutions");
  buf_pos = buf_pos + lg_write;
  /* tri d'init des rangs d'objet */
  givrListParu.iNbrTot = givrListParu.iNbr;
  givrListInst.iNbrTot = givrListInst.iNbr;

  iIntRet = givInitTriObjGeo (docIG,indice, giv_RUB);
  iIntRet = givInitTriAn9Geo();
  iIntRet = givInitTriDenomGeo(giv_RUB);
  /* Tri global sur An9 */
  iIntRet = givTriGeo (docIG,indice, giv_RUB);

  /* Ecriture dans le fichier de sortie en UTF8 */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);

  iCodRet = giv_ecrit_partie_3 (&buf_pos, docIG, indice, giv_RUB);
  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
  }
  if ((int4)GWCCodeOK == iCodRet)
  {GWTTrace (GWT_NIV_FONCT, ("ECRITURE PARTIE_3 An9 ...\n")); }
  for(j=0; j<(givrListParu.iNbrTot); j++)
  {
      i = givrListParu.trEltRangList[j];
      if ( (j < givrListParu.iNbr) && ((int4)GIXCodeOK == givrListParu.trEltList[i].iZU) )
      {
      	/* restauration parution ZU Pôle */
  	    givrListParu.trEltList[i].iZU = (int4)GIXCodeKO;
      }
      givrListParu.trEltList[i].iGeo = 99;
      givrListParu.trEltList[i].iGeoReg = 99;
      givrListParu.trEltList[i].iGeoDept = 99;
      givrListParu.trEltList[i].iGeoLoc = 99;
      givrListParu.trEltList[i].iGeoArr = 99;
  }
  for(i=0; i<(givrListInst.iNbrTot); i++)
  {
      givrListInst.trEltList[i].iGeo = 99;
      givrListInst.trEltList[i].iGeoReg = 99;
      givrListInst.trEltList[i].iGeoDept = 99;
      givrListInst.trEltList[i].iGeoLoc = 99;
      givrListInst.trEltList[i].iGeoArr = 99;
  }
  givrListParu.iNbr = givrListParu.iNbrTot;
  givrListInst.iNbr = givrListInst.iNbrTot;
  /* tri d'init des rangs de dénomination */
  iIntRet = givInitTriDenomGeo(giv_DNOM);
  /* Tri global sur Denom */
  iIntRet = givTriGeo (docIG,indice, giv_DNOM);

  /* Ecriture dans le fichier de sortie en UTF8 */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);

  iCodRet = giv_ecrit_partie_3 (&buf_pos, docIG, indice, giv_DNOM);
  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = giv_sortie (&buf_pos, GIVfDescFicBloc);
  }
  if ((int4)GWCCodeOK == iCodRet)
  {GWTTrace (GWT_NIV_FONCT, ("ECRITURE PARTIE_3 Denom...\n")); }
  for(j=0; j<(givrListParu.iNbrTot); j++)
  {
      i = givrListParu.trEltRangList[j];
      if ( (j < givrListParu.iNbr) && ((int4)GIXCodeOK == givrListParu.trEltList[i].iZU))
      {
      	/* restauration parution ZU Pôle */
  	    givrListParu.trEltList[i].iZU = (int4)GIXCodeKO;
  	    givrListParu.trEltList[i].iRgDnom = -1;
      }
      if (-1 == givrListParu.trEltList[i].iRgGeoTri)
      {
  	    givrListParu.trEltList[i].iRgDnom = -1;
      }
      givrListParu.trEltList[i].iGeo = 99;
      givrListParu.trEltList[i].iGeoReg = 99;
      givrListParu.trEltList[i].iGeoDept = 99;
      givrListParu.trEltList[i].iGeoLoc = 99;
      givrListParu.trEltList[i].iGeoArr = 99;
  }
  for(i=0; i<(givrListInst.iNbrTot); i++)
  {
      givrListInst.trEltList[i].iGeo = 99;
      givrListInst.trEltList[i].iGeoReg = 99;
      givrListInst.trEltList[i].iGeoDept = 99;
      givrListInst.trEltList[i].iGeoLoc = 99;
      givrListInst.trEltList[i].iGeoArr = 99;
  }
  givrListParu.iNbr = givrListParu.iNbrTot;
  givrListInst.iNbr = givrListInst.iNbrTot;
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Pôle ZU Dnom [%d],[%d],[%d],[%s],[%s]\n", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgDnom, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc));
  }

  /* init type des contenus de l'établissement */
  giviNbContEtab = 0;
  iIntRet = givLectureTypeContEtab((docIG)->value.a_classer.etab);

  for(i=0; i<giviNbContEtab; i++)
  {
    GWTTrace (GWT_NIV_FONCT, ("Type contenu EPJ [%s],[%s],[%s]\n", givrListContEtab[i].tcEtab,givrListContEtab[i].tcType,givrListContEtab[i].tcThm));
  }
  /* init des contenus prof de l'établissement */
  giviNbProfEtab = 0;
  iIntRet = givLectureContProfEtab((docIG)->value.a_classer.etab);

  for(i=0; i<giviNbProfEtab; i++)
  {
    GWTTrace (GWT_NIV_FONCT, ("contenu Prof EPJ [%s],[%s],[%s],[%c]\n", givrListProfEtab[i].tcType,givrListProfEtab[i].tcEtab,givrListProfEtab[i].tcAn8,givrListProfEtab[i].cIndic));
  }

  /* tri d'init des rangs d'objet */
  iIntRet = givInitTriObjGeo (docIG,indice, giv_OBJ);
  /* Tri global sur objet */
  if (0 != givrListParu.iNbrTri)
  {
    /* présence d'objet */
    iIntRet = givTriGeo (docIG,indice, giv_OBJ);

    iCodRet = giv_ecrit_partie_3 (&buf_pos, docIG, indice, giv_OBJ);
    if ('\0' != GIVBuffXML[0])
    {
      /* Ecriture dans le fichier de sortie */
      iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
    }
  }
  {GWTTrace (GWT_NIV_FONCT, ("ECRITURE PARTIE_3 Objet...\n")); }

  lg_write = giv_ecrit_fin_noeud(&buf_pos,"parutions");
  buf_pos = buf_pos + lg_write;

  if (0 != givrListObj.iNbrTri)
  {
    /* liens objets-rubriques */
    iCodRet = giv_ecrit_partie_3_obj (&buf_pos, docIG);
  }

  lg_write = giv_ecrit_noeud_simple(buf_pos,"inscriptions");
  buf_pos = buf_pos + lg_write;

  for(j=0; j<(givrListParu.iNbrTot); j++)
  {
      i = givrListParu.trEltRangList[j];
      if ( (j < givrListParu.iNbr) && ((int4)GIXCodeOK == givrListParu.trEltList[i].iZU) && (0 != givrListParu.iNbrTri) )
      {
      	/* restauration parution ZU Pôle */
  	    givrListParu.trEltList[i].iZU = (int4)GIXCodeKO;
      }
      givrListParu.trEltList[i].iGeo = 99;
      givrListParu.trEltList[i].iGeoReg = 99;
      givrListParu.trEltList[i].iGeoDept = 99;
      givrListParu.trEltList[i].iGeoLoc = 99;
      givrListParu.trEltList[i].iGeoArr = 99;
  }
  for(i=0; i<(givrListInst.iNbrTot); i++)
  {
      givrListInst.trEltList[i].iGeo = 99;
      givrListInst.trEltList[i].iGeoReg = 99;
      givrListInst.trEltList[i].iGeoDept = 99;
      givrListInst.trEltList[i].iGeoLoc = 99;
      givrListInst.trEltList[i].iGeoArr = 99;
  }
  givrListParu.iNbr = givrListParu.iNbrTot;
  givrListInst.iNbr = givrListInst.iNbrTot;
  /* analyse Pôle de ZU */
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Pôle ZU [%d],[%d],[%d],[%s],[%s]\n", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgDnom, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc));
  }
  for (j = 0 ;j < givrListParu.iNbr; j++)
  {
    i = givrListParu.trEltRangList[j];
    givrListParu.trEltList[i].iRangTri = (int4)0;
    if ((int4)GIXCodeOK != givrListParu.trEltList[i].iZU)
    {
    	continue;
    }
    /* validation d'un pôle de ZU */
    for (l = 0 ;l < givrListParu.iNbr; l++)
    {
    	if (l == j)
    	{
    		continue;
    	}
      k = givrListParu.trEltRangList[l];
      if ( (0 == strcmp(givrListParu.trEltList[i].dep, givrListParu.trEltList[k].dep))
      	&& (0 == strcmp(givrListParu.trEltList[i].loc, givrListParu.trEltList[k].loc))
      	&& ((int4)GIXCodeOK != givrListParu.trEltList[k].iZU) )
      {
      	/* validation */
      	givrListParu.trEltList[k].iRangTri = (int4)-1;
        break;
      }
    }
    if (givrListParu.iNbr == l)
    {
    	/* pas de validation */
    	givrListParu.trEltList[i].iRangTri = (int4)-1;
    }
  }
  for (j = 0 ;j < givrListParu.iNbr; j++)
  {
    i = givrListParu.trEltRangList[j];
    if ((-1 == givrListParu.trEltList[i].iRgDnom) && (0 == givrListParu.trEltList[i].iRangTri) && ((int4)GIXCodeOK != givrListParu.trEltList[i].iZU))
    {
    	givrListParu.trEltList[i].iRangTri = -1;
    }
  }
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    i = givrListParu.trEltRangList[j];
    GWTTrace (GWT_NIV_FONCT, ("Pôle ZU Ins [%d],[%d],[%d],[%s],[%s]\n", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgDnom, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc));
  }
  for(i=0; i<indice; i++)
  {
    /* Tri par ligne */
    iIntRet = givTriGeoIns (docIG+i,i);

    iCodRet = giv_ecrit_partie_2_2(&buf_pos, docIG+i, i, docIG, indice);
    if ((int4)GWCCodeOK == iCodRet)
    {GWTTrace (GWT_NIV_FONCT, ("ECRITURE PARTIE_2_2 ...\n"));}
    iCodRet = giv_ecrit_partie_3_ins (&buf_pos, docIG+i, indice);
    if ('\0' != GIVBuffXML[0])
    {
      /* Ecriture dans le fichier de sortie */
      iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
    }
    if ((int4)GWCCodeOK == iCodRet)
    {GWTTrace (GWT_NIV_FONCT, ("ECRITURE PARTIE_3_INS ...\n")); }
  }

  iCodRet = giv_ecrit_partie_2_3(&buf_pos, docIG, indice);
  if ((int4)GWCCodeOK == iCodRet)
  {GWTTrace (GWT_NIV_FONCT, ("ECRITURE PARTIE_2_3 ...\n")); }

  /* Fin document */
  lg_write = giv_ecrit_fin_noeud(&buf_pos,"document");
  buf_pos = buf_pos + lg_write;

  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
  }

  /* enrichissement du bloc */
  if ((int4)GIXCodeOK == giviEnrich)
  {
      GIVAnnulerBlocCGenTest = 0;
      iIntRet = GIVEnrichirTest(docIG->value.a_classer.etab, GIVBuffTest, givtcMoteur);
      if (iIntRet != GWZOk)
      {
          sprintf(GIVBuffTest,"<!-- Non-generation du bloc EPJ pour l'etab %s pour cause d'echec CGenTest -->\n", docIG->value.a_classer.etab);
          GWTTrace(GWT_NIV_GRAVE, ("Non-generation du bloc EPJ pour l'etab %s pour cause d'echec CGenTest\n", docIG->value.a_classer.etab));
          GIVAnnulerBlocCGenTest = 1;
      }
  }

  pcVersion = strchr(pcVersionInsFour[0], (char)'.');
  pcVersion++;

  iIntRet = givFin (&buf_pos, docIG->parution_id);
  if ((int4)GWCCodeOK != iIntRet)
  {
    /* Erreur sur ecriture fin document */
    GWTTrace (GWT_NIV_GRAVE,
              ("Erreur sur ecriture fin document dans partie_3 ...\n"));
    iCodRet = (int4)GWCCodeKO;
  }
  /* Pointeur sur debut du buffer */
  buf_pos = GIVBuffXML;

  /* Effacement du buffer */
  GIVBuffXML[0] = '\0';

  *buf_pos_in = buf_pos;

  /* Sortie de la fonction */
  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givDelIeBlocCRC                                                */
/*                                                                            */
/* But       : suppression des CRC du bloc dans GYTtabIeBlocCRC               */
/*             de l'ensemble du bloc                                          */
/*                                                                            */
/* Entree(s) : un buffer, documents                                           */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Création (Oct/04/2012 - mb)                                            */
/*----------------------------------------------------------------------------*/

static int4 givDelIeBlocCRC (char * acBlocid)

{
  int4 iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  EXEC SQL begin declare section;
  char cBlocid[26+1];
  char tcRequete[1024];
  EXEC SQL end declare section ;
  GYBrParam_erreurT     vErreurSQL;             /* Traitement des erreurs SQL */
    (void)strcpy(vErreurSQL.acOrdre_sql,"Suppression anciens blocs GYTtabIeBlocCRC");
    (void)strcpy(cBlocid,acBlocid);
    GWTTrace (GWT_NIV_FONCT,
              ("blocid  : %s\n",cBlocid));
    EXEC SQL
      execute rqtDelIeBlocCRC
      using :cBlocid;

    iCodRet = GIVBlocErreur (&vErreurSQL);
    /* Analyse du code resultat SQL */
    if (((int4)GWCCodeOK != iCodRet) && ((int4)GYBnodata != iCodRet))
    {
      GWTTrace (GWT_NIV_BIZAR,
                ( "Erreur : [COD=%d TXT=%s]\n",
                  iCodRet,
                  vErreurSQL.acOrdre_sql));
    }

  return(iCodRet);

}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givInsIeBlocCRC                                                */
/*                                                                            */
/* But       : insertion d'un CRC du bloc dans GYTtabIeBlocCRC                */
/*                                                                            */
/* Entree(s) : un buffer, documents                                           */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Création (Oct/04/2012 - mb)                                            */
/*----------------------------------------------------------------------------*/

static int4 givInsIeBlocCRC (void)

{
  int4 iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 i,p;
  EXEC SQL begin declare section;
  GYBrPrioCRCT * prOraPrioCRC;
  char cBlocid[26+1];
  char tcRequete[1024];
  char *pcVersion;
  /* tables pour insertion globale */
  int4 j;
  char tcVersion[MAX_LIST_CRC][GXWLgIdDonnees]; /* version du bloc */
  GYBstrBlocBlocidT trBlocid[MAX_LIST_CRC];   /* numero de bloc */
  GYBstrPrioTypeT trType [MAX_LIST_CRC]; /* type de crc */
  char tcCodan8[MAX_LIST_CRC][GYBIaprofLgCodan8 + 1];   /* code AN8 */
  char tcTpdsob[MAX_LIST_CRC][GYBIamicLgTpdsob + 1];   /* source (type dans l objet) */
  GYBstrIeinscEtabT trEtab[MAX_LIST_CRC];   /* code etablissement */
  GYBstrPrioCRCT trCRC[MAX_LIST_CRC];         /* contenu  CRC */
  EXEC SQL end declare section ;
  GYBrParam_erreurT     vErreurSQL;             /* Traitement des erreurs SQL */
  static int4 iDejaPrepare = (int4)GWCCodeKO;

  /* version du bloc */
  pcVersion = strchr(pcVersionInsFour[0], (char)'.');
  pcVersion++;
  j = 0;
    for(i=0; i<givrListCRC.iNbr; i++)
    {
      p= givrListCRC.trEltRangList[i];
      if ((0 != strlen(givrListCRC.trEltList[p].acEtab)) &&
        (-1 != givrListCRC.trEltList[p].iRgEtab) &&
        (-1 != givrListCRC.trEltList[p].iRgCRC))
      {
          /* insetion CRC sur blocid dans GYTtabIeBlocCRC */
          (void)strcpy (tcVersion[j],pcVersion);
          (void)strcpy (trBlocid[j],nom_bloc_ref);
          (void)strcpy (tcCodan8[j],givrListCRC.trEltList[p].acCodan8);
          (void)strcpy (tcTpdsob[j],givrListCRC.trEltList[p].acTpdsob);
          (void)strcpy (trType[j],givrListCRC.trEltList[p].acType);
          (void)strcpy (trEtab[j],givrListCRC.trEltList[p].acEtab);
          (void)strcpy (trCRC[j],givrListCRC.trEltList[p].acCRC);
          j++;
      }
    }
  if (0 == j)
  {
    return(iCodRet);
  }

  if ( (int4)GWCCodeOK != iDejaPrepare )
  {
    (void)sprintf ( tcRequete, GIV_INS_IEBLOC_CRC, GIXcNomDest );
    (void)strcpy(vErreurSQL.acOrdre_sql,"Insertion bloc GYTtabIeBlocCRC");
    EXEC SQL
      prepare rqtInsIeBlocCRC from :tcRequete;

    iDejaPrepare = (int4)GWCCodeOK;
  }
    GWTTrace (GWT_NIV_FONCT,
              ("blocid  : %s\n",nom_bloc_ref));

    EXEC SQL FOR :j
      execute rqtInsIeBlocCRC
      using :trBlocid,
            :trEtab,
            :trCRC,
            :trType,
            :tcCodan8,
            :tcTpdsob,
            :tcVersion;

    iCodRet = GIVBlocErreur (&vErreurSQL);
    /* Analyse du code resultat SQL */
    if ((int4)GWCCodeOK != iCodRet)
    {
      GWTTrace (GWT_NIV_BIZAR,
              ("echec insert crc : %s,%s\n",
                             nom_bloc_ref,
                              pcVersion));
      GWTTrace (GWT_NIV_BIZAR,
                ( "Erreur : [COD=%d TXT=%s]\n",
                  iCodRet,
                  vErreurSQL.acOrdre_sql));
    }

  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givGroupement ()                                               */
/*                                                                            */
/* But       : Ecriture des blocs groupement simples et clones                */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Modification (Nov/14/1997 lgu) : V2 ajout objet 11 micro                   */
/*                                                                            */
/*----------------------------------------------------------------------------*/


static int4 givGroupement (char **buf_pos_in, GYBrDOCUMENT *docEPJ, GYBrDOCUMENT *docIG, int4 indice)
{
  char *buf_pos;
  int4 i,m,n,p;
  int4 iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  EXEC SQL begin declare section;
  char cBlocid[26+1];
  char tcRequete[1024];
  char cDepart[GYBIeinscLgDeppar+1];
  EXEC SQL end declare section ;
  GYBrParam_erreurT     vErreurSQL;             /* Traitement des erreurs SQL */
  buf_pos = *buf_pos_in;
  GYBstrIeinscDenomT rDenom;
  int4 iRang;

  giviPart = (int4)GWCCodeOK;
  for(p=0; p< indice; p++)
  {
    if (('0' <= (docIG+p)->value.inscription[0].val_num[0]) &&
          ('9' >= (docIG+p)->value.inscription[0].val_num[0]))
    {
      giviPart = (int4)GWCCodeKO;
      break;
    }
  }
  GWTTrace (GWT_NIV_FONCT,
                  ("part :'%s', '%d'\n",docIG->value.inscription[0].val_num,giviPart));
  for(p=1; p< indice; p++)
  {
    if (docIG->iRang != (docIG+p)->iRang)
    {
      break;
    }
  }
  /* enrichissement du bloc */
  giviEnrich = (int4)GIXCodeKO;
  for(n=0; n<GIViNbEPJTest; n++)
  {
    if (0 == strcmp(docIG->value.a_classer.etab,GIVtrEPJTest[n]))
    {
    	/* enrichissement configuré */
    	giviEnrich = (int4)GIXCodeOK;
      break;
    }
  }
  GWTTrace (GWT_NIV_FONCT,
                  ("Enrichissement :'%d'\n",giviEnrich));

  /* Rang de tri de dénomination dans document d'une ligne */
  strcpy(rDenom, "      ");
  iRang = -1;
  for(n=0; n< indice; n++)
  {
    if ((0 != strcmp(rDenom,(docIG+n)->value.intitule.denomination)) || (0 == n))
    {
      /* rang denom identique au rang de doc */
      iRang = n;
      strcpy(rDenom, (docIG+n)->value.intitule.denomination);
    }
    (docIG+n)->value.intitule.iRgDnom = iRang;
    sprintf((docIG+n)->value.intitule.tcRgDnom, "%04d",iRang);
    GWTTrace (GWT_NIV_FONCT,
                  ("dénom triées :'%d', '%s'\n",iRang,(docIG+n)->value.intitule.tcRgDnom));
  }
  /* Report du numéro de client sur toutes les lignes */
  for(n=0; n< indice; n++)
  {
    if (0 != strlen((docIG+n)->value.numero_client))
    {
      for(m=0; m< indice; m++)
      {
        if (0 == strlen((docIG+m)->value.numero_client))
        {
          strcpy((docIG+m)->value.numero_client, (docIG+n)->value.numero_client);
        }
      }
      break;
    }
  }

  /* au moins un bloc à écrire */
  iMaxBlocEcritAvant++;

    giviCodRetEcr = (int4)GIXCodeOK;

    /* Bloc ordonné par rang  */
    iCodRet = givBlocs(&buf_pos, docEPJ, docIG, indice);

    if ((int4)GIXCodeOK != giviCodRetEcr)
    {
      *buf_pos_in=buf_pos;
      givrListParu.iNbr = 0;
      givrListInst.iNbr = 0;
    }
    if (!GIVAnnulerBlocCGenTest)
    {
       if (0 == strcmp(GIVtcGeneIeBloc,"OUI"))
       {
       /* suppressions de lignes du blocid */
        (void)strcpy(vErreurSQL.acOrdre_sql,"Suppression anciens blocs GYTtabIeBloc");
        (void)strcpy((char *)cDepart,(const char *)GIXcDepartement);
        (void)strcpy(cBlocid,nom_bloc_ref);
        GWTTrace (GWT_NIV_FONCT,
                  ("blocid  : %s\n",cBlocid));
        EXEC SQL
          execute rqtDelIeBloc
          using
          :cDepart,
          :cBlocid;

        iCodRet = GIVBlocErreur (&vErreurSQL);
        /* Analyse du code resultat SQL */
        if (((int4)GWCCodeOK != iCodRet) && ((int4)GYBnodata != iCodRet))
        {
          GWTTrace (GWT_NIV_BIZAR,
                    ( "Erreur : [COD=%d TXT=%s]\n",
                      iCodRet,
                      vErreurSQL.acOrdre_sql));
        }

        /* maj table des blocs pour un bloc à la source */
        for(i=0; (i<indice); i++)
        {
          /* ligne par ligne */
          iCodRet = giv_ecrit_tabIeBloc(docIG+i);
        }

        if ((0 == strcmp ("OUI",givtcGeneIeBlocCRC)) && (0 != strcmp(givRecreerCD,GIXcNomFour)))
        {
          /* suppression sur blocid dans GYTtabIeBlocCRC */
          iCodRet = givDelIeBlocCRC(nom_bloc_ref);
        }
        /* mise à jour TabIeBlocCRC */
        if (0 == strcmp ("OUI",givtcGeneIeBlocCRC))
        {
          iCodRet = givInsIeBlocCRC ();
        }

   }
    if ((int4)GWCCodeOK == iCodRet)
    {GWTTrace (GWT_NIV_FONCT, ("ECRITURE TABLE BLOCS DE PARUTIONS ...\n")); }
   }
    *buf_pos_in=buf_pos;

    /* init liste des codes géographiques du bloc */
    givrListParu.iNbr = 0;
    givrListInst.iNbr = 0;

  /* Sortie de la fonction */
  return(iCodRet);

}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritContenu()                                              */
/*                                                                            */
/* But       : ecrit les contenus SGIPRO                                      */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, valeur_id_parution                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	(Jui/20/2006 - mb) : création de plusieurs fichiers de sortie */
/*----------------------------------------------------------------------------*/

static int4 givEcritContenu (char *obj, char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice, int4 *picvi)

{
  int4 lg_ecr_micro = 0;
  int4 lg_ecr = 0;
  int4 i,k,kk = 0;
  int4 lg_write;
  char *buf_pos, *buf_pos_ref;
  char *pt_fin_liste;
  char *pt_debut_element;
  char *pt_fin_element;
  char *pt_mil_element;
  char *pt_suite_element;
  int4 iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 iRet = GWCCodeKO;            /* Code retour de la fonction */
  char tcType[3+1];
  char tcObj[3+1] = "";
  char tcBalise[50+1];
  int4 lg_a_ecrire;
  int4 iRang,iObj,iRef,iMC,iBalise;
  GYBrIamicT rIamic;

  /* Pointeur sur debut du buffer */
  buf_pos = *buf_pos_in;

  /* Ecriture dans le fichier de sortie */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);

  if (0 != strlen(obj))
  {
    strcpy(tcObj, obj);
    tcObj[0] = toupper(tcObj[0]);
    tcObj[1] = toupper(tcObj[1]);
  }

  GWTTrace (GWT_NIV_FONCT,("Ecriture Contenu %s, %s\n", obj, tcObj));

  pt_fin_liste = givtcObjCont + strlen(givtcObjCont);
  for (pt_debut_element = givtcObjCont; pt_debut_element < pt_fin_liste; )
  {
    pt_fin_element=strchr(pt_debut_element, ',');
    if (pt_fin_element == 0)
    {
      pt_fin_element = pt_fin_liste;
    }
    pt_mil_element=strchr(pt_debut_element, '/');
    if (pt_mil_element == 0)
    {
      break;
    }
    pt_suite_element=0;
    iRet = (int4)GIXCodeKO;
    buf_pos_ref = buf_pos;
  while (pt_suite_element < pt_mil_element)
  {
    pt_suite_element=strchr(pt_debut_element, '|');
    if (pt_suite_element == 0 || pt_suite_element > pt_mil_element)
    {
      pt_suite_element=pt_mil_element;
    }
    /* analyse type et balise associés */
    /*memcpy(tcType, pt_debut_element, (pt_mil_element - pt_debut_element));*/
    memcpy(tcType, pt_debut_element, (pt_suite_element - pt_debut_element));
    tcType[(pt_mil_element - pt_debut_element)] = '\0';
    tcType[0] = toupper(tcType[0]);
    tcType[1] = toupper(tcType[1]);
    memcpy(tcBalise, (pt_mil_element+1), (pt_fin_element - pt_mil_element - 1));
    tcBalise[(pt_fin_element - pt_mil_element - 1)] = '\0';
    iRang = -1;
    iRef = -1;
    iMC = -1;
    iBalise = GIXCodeKO;
    GIVBuffInter[0] = '\0';
    GIVBuffClob[0] = '\0';
    if ((0 != strlen(obj)) && (0 != strcmp(tcType, tcObj)) && ((int4)GIXCodeKO == iRet))
    {
      /* hors configuration prioritaire */
      break;
    }
    else for(i=0; i<givrListObj.iNbr; i++)
    {
      GWTTrace (GWT_NIV_FONCT,("Ecriture Contenu %s, %s, %s\n", obj, tcObj, tcType));
      k = givrListObj.trEltRangListObj[i];
      kk = givrListObj.trEltListObj[k].iRgLigne;
      iObj = givrListObj.trEltListObj[k].iRgObj;
      if ((0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].type, "X")) && (iRang != givrListObj.trEltListObj[k].iRangTri))
      {
        iRang = givrListObj.trEltListObj[k].iRangTri;
      	GWTTrace (GWT_NIV_FONCT,("Annonceur : %d,%d,%s\n",(doc+kk)->value.objets_pub.micro[iObj].iCVI, *picvi, (doc+kk)->value.objets_pub.micro[iObj].id ));
        GWTTrace (GWT_NIV_FONCT,("Objet Contenu %s, %s\n", (doc+kk)->value.objets_pub.micro[iObj].stype,(doc+kk)->value.objets_pub.micro[iObj].sstype));
        if ( (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "SC")) &&
                 (0 != strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype, "PV")) )
        {
        	/* contenu valide uniquement pour SC-PV */
          continue;
        }
        else if ( (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "LC")) &&
                 (0 != strcmp((doc+kk)->value.objets_pub.micro[iObj].sstype, "CH")) )
        {
        	/* contenu valide uniquement pour chronoresto LC-CH */
          continue;
        }
        if (0 == strcmp(tcType, (doc+kk)->value.objets_pub.micro[iObj].stype))
        {
        	if (GIXCodeKO == *picvi && 2 == (doc+kk)->value.objets_pub.micro[iObj].iCVI)
          {
        	  /* nouveau CVI traité à part */
            continue;
          }
        	if (GIXCodeKO != *picvi && 2 != (doc+kk)->value.objets_pub.micro[iObj].iCVI)
          {
        	  /* hors nouveau CVI traité à part */
            continue;
          }
          (doc+kk)->value.objets_pub.micro[iObj].iCont = 1;
        }
        else
        {
          continue;
        }

        /* écriture SGIPRO */
        if (0 == strcmp(tcObj, obj))
        {
        	/* accès à un fichier */
        	if (GIXCodeKO == *picvi)
        	{
            iCodRet = givEcritSgiPro(&buf_pos, doc, kk, iObj, indice, tcBalise, GIXCodeKO);
          }
        	else if (GIXCodeOK == *picvi)
        	{
            iCodRet = givEcritSgiPro(&buf_pos, doc, kk, iObj, indice, "affcviv", iRet);
          }
        	else
        	{
        		/* nouvel objet CVI */
            iCodRet = givEcritSgiPro(&buf_pos, doc, kk, iObj, indice, tcBalise, GIXCodeOK);
          }
        }
        else
        {
        	/* accès à la base */

        	if (0 == strcmp("MO",(doc+kk)->value.objets_pub.micro[iObj].stype))
          {
    	      if ((0 != memcmp(&rIamic.acNumobj[4],&(doc+kk)->value.objets_pub.micro[iObj].id[4],8)) &&
    	      	  (0 != strlen(GIVBuffInter)))
            {
              GWTTrace (GWT_NIV_FONCT,("Ecriture Mots Cles 1 %d\n", iRef));
              if (GIXCodeKO == iBalise)
              {
                iCodRet = givEcritureMotsCles(&buf_pos, doc, iRef, iMC, indice, tcBalise);
                iBalise = GIXCodeOK;
              }
              else
              {
                iCodRet = givEcritureMotsCles(&buf_pos, doc, iRef, iMC, indice, "");
              }
              GIVBuffInter[0] = '\0';
              GIVBuffClob[0] = '\0';
            }
            (void)strcpy(rIamic.acNumobj,(doc+kk)->value.objets_pub.micro[iObj].id);
            iCodRet = givLectureMotsCles(&rIamic);
            if (0 != strlen(GIVBuffInter))
            {
              iRef = kk;
              iMC = iObj;
            }
          }
        	else if (GIXCodeKO == *picvi)
        	{
             iCodRet = givEcritDonAnnonceur(&buf_pos, doc, kk, iObj, indice, tcBalise, GIXCodeKO);
          }
        	else if (GIXCodeOK == *picvi)
        	{
             iCodRet = givEcritDonAnnonceur(&buf_pos, doc, kk, iObj, indice, "affcviv", iRet);
          }
        	else
        	{
        		/* nouvel objet CVI */
             iCodRet = givEcritDonAnnonceur(&buf_pos, doc, kk, iObj, indice, tcBalise, GIXCodeOK);
          }
        }
        GWTTrace (GWT_NIV_FONCT,("En-tête 1 : %d,%d\n",iCodRet, iRet));
        if ((int4)GIXCodeOK == iCodRet)
        {
          iRet = (int4)GIXCodeOK;
          if ((GIXCodeKO == *picvi) && (0 != strcmp("MO",(doc+kk)->value.objets_pub.micro[iObj].stype)))
          {
            lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBalise);
            buf_pos = buf_pos + lg_write;
          }
        }
        else if ((int4)GIXCodeOK != iRet)
        {
          iRet = (int4)GIXCodeRIEN;
        }
        if ((GIXCodeOK == *picvi) && ((int4)GIXCodeOK != iCodRet))
        {
        	/* nouvel objet CVI sans contenu associé */
        	(doc+kk)->value.objets_pub.micro[iObj].iCVI = 3;
        }
        GWTTrace (GWT_NIV_FONCT,("En-tête 2 : %d,%d\n",iCodRet, iRet));
      }
    } /* Fin boucle */

    GWTTrace (GWT_NIV_FONCT,("En-tête 3 : %d,%d\n",iRet, *picvi));
    if ((int4)GIXCodeOK == iRet)
    {
    	if ((0 == strcmp("MO",tcType))
           && (0 != strlen(GIVBuffInter)))
      {
        GWTTrace (GWT_NIV_FONCT,("Ecriture Mots Cles 3 %d\n", iRef));
        if (GIXCodeKO == iBalise)
        {
          iCodRet = givEcritureMotsCles(&buf_pos, doc, iRef, iMC, indice, tcBalise);
          iBalise = GIXCodeOK;
        }
        else
        {
          iCodRet = givEcritureMotsCles(&buf_pos, doc, iRef, iMC, indice, "");
        }
        GIVBuffInter[0] = '\0';
        GIVBuffClob[0] = '\0';
      }
      if (GIXCodeOK == iBalise)
      {
        GWTTrace (GWT_NIV_FONCT,("Ecriture Mots Cles 4 %d\n", iRef));
        lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBalise);
        buf_pos = buf_pos + lg_write;
        iBalise = GIXCodeKO;
      }
      if (GIXCodeOK == *picvi)
      {
      	*picvi = GIXCodeRIEN;
      }
      pt_suite_element=pt_mil_element;
    }
    else if ((int4)GIXCodeRIEN == iRet)
    {
      pt_debut_element=pt_suite_element+1;
    }
    else
    {
      pt_suite_element=pt_mil_element;
    }
  }

    pt_debut_element=pt_fin_element+1;
  }

  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
  }

  *buf_pos_in=buf_pos;


  GWTTrace (GWT_NIV_FONCT,
            ("Sortie Ecriture Contenu\n"));

  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritPart()                                              */
/*                                                                            */
/* But       : ecrit les contenus SGIPRO de partenaires                       */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, valeur_id_parution                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	(Jui/20/2006 - mb) : création de plusieurs fichiers de sortie */
/*----------------------------------------------------------------------------*/

static int4 givEcritPart (char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice)

{
  int4 lg_ecr_micro = 0;
  int4 lg_ecr = 0;
  int4 i,q = 0;
  int4 lg_write;
  int4 iDebut;
  char *buf_pos;
  char *buf_pos_part;
  char *pt_fin_liste;
  char *pt_debut_element;
  char *pt_fin_element;
  char *pt_suite_element;
  char *pt_mil_element;
  char *pt_fin_lst;
  char *pt_debut;
  char *pt_fin;
  int4 iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  char tcType[3+1];
  char tcTYPE[3+1];
  char tcBalise[50+1];
  char tcBalises[50+2];
  char tcElmt[29+1];                         /* partenaire*/
  int4 lg_a_ecrire;
  int4 pipe;                          /* Flag pour ajout pipe */
  int4 iRet;

  /* pas de gestion de conflit */
  giviConflitCRC = GWCCodeKO;

  /* Pointeur sur debut du buffer */
  buf_pos = *buf_pos_in;

  /* Ecriture dans le fichier de sortie */
  iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  *buf_pos_in=buf_pos;

  pt_fin_liste = givtcObjCont + strlen(givtcObjCont);

  for (pt_debut_element = givtcObjCont; pt_debut_element < pt_fin_liste; )
  {
    pt_fin_element=strchr(pt_debut_element, ',');
    if (pt_fin_element == 0)
    {
      pt_fin_element = pt_fin_liste;
    }
    pt_mil_element=strchr(pt_debut_element, '/');
    if (pt_mil_element == 0)
    {
      break;
    }
    /* analyse premier type et balise associés */
    pt_suite_element=strchr(pt_debut_element, '|');
    if ((pt_suite_element != 0) && (pt_suite_element < pt_mil_element))
    {
      memcpy(tcType, pt_debut_element, (pt_suite_element - pt_debut_element));
      tcType[(pt_suite_element - pt_debut_element)] = '\0';
    }
    else
    {
      memcpy(tcType, pt_debut_element, (pt_mil_element - pt_debut_element));
      tcType[(pt_mil_element - pt_debut_element)] = '\0';
    }
    strcpy(tcTYPE,tcType);
    tcTYPE[0] = toupper(tcTYPE[0]);
    tcTYPE[1] = toupper(tcTYPE[1]);
    memcpy(tcBalise, (pt_mil_element+1), (pt_fin_element - pt_mil_element - 1));
    tcBalise[(pt_fin_element - pt_mil_element - 1)] = '\0';
    strcpy(tcBalises,tcBalise);
    /* strcat(tcBalises,"s"); */

    if ((0 == strcmp(tcTYPE, "DC")) || (0 == strcmp(tcTYPE, "RA")))
    {
      /* enrichissement des partenaires */
      /* écriture SGIPRO */
      iDebut = 1;
      if ((0 != strlen(doc->value.a_classer.etab)) && (0 == strcmp(tcTYPE, "DC")))
      {
        /* établissement */
        if (0 == strcmp(tcTYPE,tcType))
        {
        	/* accès à un fichier */
          iCodRet = givEcritSgiProPart(&buf_pos, doc, doc->value.a_classer.etab, doc->value.a_classer.etab, tcType, tcBalise, &iDebut);
        }
        else
        {
          /* accès à la base */
          iCodRet = givEcritDonEtab(tcTYPE, tcBalise, &buf_pos, *buf_pos_in, doc, "", "", "", &iDebut);
        }
      }
      else if ((0 != strlen(doc->value.a_classer.etab)) && (0 == strcmp(tcTYPE, "RA")))
      {
        if (0 == strcmp(tcTYPE,tcType))
        {
        	/* accès à un fichier */
          iCodRet = givEcritSgiProBOC(&buf_pos, doc, indice, doc->value.a_classer.etab, tcType, tcBalise);
        }
        else
        {
          /* accès à la base */
          iCodRet = givEcritDonEtab(tcTYPE, tcBalise, &buf_pos, *buf_pos_in, doc, "", "", "", &iDebut);
        }
      }
    }

    pt_debut_element=pt_fin_element+1;
  }

  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
  }

  *buf_pos_in=buf_pos;
  memset(buf_concat, 0, strlen(buf_concat));

  GWTTrace (GWT_NIV_FONCT,
            ("Sortie Ecriture Contenu\n"));

  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givAffCRCEtab                                                  */
/*                                                                            */
/* But       : liste des balises NORMALE par epj                              */
/*             de l'ensemble du bloc                                          */
/*                                                                            */
/* Entree(s) : un buffer, documents                                           */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Création	(Oct/01/2012 - mb)                                            */
/*----------------------------------------------------------------------------*/

static int4 givAffCRCEtab (char **buf_pos_in)

{
  int4 lg_write,lg_ecr = 0;
  int4 lg;
  int4 i,j,k,l,p,q,r,rr;
  char *buf_pos;
  int4  iCodRet, iRet = GWCCodeOK;            /* Code retour de la fonction */
  char *pt_fin_lst;
  char *pt_debut;
  char *pt_fin;
  char tcElmt[GYBLgPrioCRC2]; /* CRC normale */
  GYBrPrioCRCT rPrioCRC;
  int4 iNbEtabCRC,iNbCRCCRC;
  int4 iRgEtabCRC,iRgCRCCRC;
  int4 iRgEtab,iRgCRC;
  int4 iRangDeb;
  int4 iBLEtab;

  if (0 == giviNbCRC)
  {
    /* pas de nouveau CRC */
    return(iCodRet);
  }
  givrListCRC.iNbr = giviNbCRC;

  for(i=0; i<givrListCRC.iNbr; i++)
  {
    p= givrListCRC.trEltRangList[i];
    GWTTrace (GWT_NIV_FONCT,("crc init : %d,%d,%d,%s\n",givrListCRC.iNbr,i,p,givrListCRC.trEltList[p].acEtab));
  }
  /* trier en fonction des crc */
  qsort(givrListCRC.trEltRangList,givrListCRC.iNbr,sizeof(int4),givCompListCRC);
  /* suppression autres crc sans epj */
  for(i=0; i < giviNbCRC ; i++)
  {
    p = givrListCRC.trEltRangList[i];
    if (0 == strlen(givrListCRC.trEltList[p].acEtab))
    {
    	break;
    }
  }
  if (0 != i)
  {
    givrListCRC.iNbr = i;
  }
  /* référence courante */
  (void)strcpy (rPrioCRC.acEtab,"00000000");
  (void)strcpy (rPrioCRC.acCodan8,"");
  iRgEtab = -1;
  iRgCRC = -1;
  iBLEtab = -1;
  /* rang de chaque etab et de chaque crc */
  for(i=0; i<givrListCRC.iNbr; i++)
  {
    p= givrListCRC.trEltRangList[i];
    if ((0 != strcmp(rPrioCRC.acEtab,givrListCRC.trEltList[p].acEtab)) || (0 == i))
    {
      iRgEtab++;
      iRgCRC = 0;
    }
    else if (0 != strcmp(rPrioCRC.acCodan8,givrListCRC.trEltList[p].acCodan8))
    {
      iRgCRC++;
    }
    givrListCRC.trEltList[p].iRgEtab = iRgEtab;
    givrListCRC.trEltList[p].iRgCRC = iRgCRC;
    if (((0 != strcmp(rPrioCRC.acEtab,givrListCRC.trEltList[p].acEtab)) || (0 == i))
    	&& (0 != strlen(givrListCRC.trEltList[p].acEtab)))
    {
    	/* analyse du black-listage en fiche détaillée sur EPJ */
      iCodRet = givLectureBListEPJFD(givrListCRC.trEltList[p].acEtab);
      if ((int4)GIXCodeOK == iCodRet)
      {
        givrListCRC.trEltList[p].iRgEtab = -1;
        givrListCRC.trEltList[p].iRgCRC = -1;
        iBLEtab = 0;
      }
      else
      {
        iBLEtab = -1;
      }
    }
    else if ((0 == strcmp(rPrioCRC.acEtab,givrListCRC.trEltList[p].acEtab)) &&
        (0 == strcmp(rPrioCRC.acTpdsob,givrListCRC.trEltList[p].acTpdsob)) &&
        (0 == strcmp(rPrioCRC.acCRC,givrListCRC.trEltList[p].acCRC)) &&
        (0 == strcmp(rPrioCRC.acCodan8,givrListCRC.trEltList[p].acCodan8)) &&
        (0 == strcmp(rPrioCRC.acType,givrListCRC.trEltList[p].acType)))
    {
      /* crc en double */
      givrListCRC.trEltList[p].iRgEtab = -1;
      givrListCRC.trEltList[p].iRgCRC = -1;
    }
    else if ((0 == strcmp(rPrioCRC.acEtab,givrListCRC.trEltList[p].acEtab)) && (0 == iBLEtab))
    {
      	/* bl sur même epj */
        givrListCRC.trEltList[p].iRgEtab = -1;
        givrListCRC.trEltList[p].iRgCRC = -1;
    }
    strcpy(rPrioCRC.acEtab, givrListCRC.trEltList[p].acEtab);
    strcpy(rPrioCRC.acTpdsob, givrListCRC.trEltList[p].acTpdsob);
    strcpy(rPrioCRC.acCRC, givrListCRC.trEltList[p].acCRC);
    strcpy(rPrioCRC.acCodan8, givrListCRC.trEltList[p].acCodan8);
    strcpy(rPrioCRC.acType, givrListCRC.trEltList[p].acType);
  }

  iNbEtabCRC = 0;
  iRgEtab = 0;
  iRangDeb = 0;
  /* rang dans chaque etab */
  for(j=0; j<(givrListCRC.iNbr); j++)
  {
    i = givrListCRC.trEltRangList[j];
    if ((iRgEtab != givrListCRC.trEltList[i].iRgEtab) && (-1 != givrListCRC.trEltList[i].iRgEtab))
    {
      iRgEtabCRC = 0;
      for(l=iRangDeb; l<j; l++)
      {
        k = givrListCRC.trEltRangList[l];
        givrListCRC.trEltList[k].iNbEtabCRC = iNbEtabCRC;
        givrListCRC.trEltList[k].iRgEtabCRC = iRgEtabCRC;
        givrListCRC.trEltList[k].iNbCRCCRC = 1;
        givrListCRC.trEltList[k].iRgCRCCRC = 0;
        iRgEtabCRC++;
      }
      iRgEtab = givrListCRC.trEltList[i].iRgEtab;
      iNbEtabCRC = 0;
      iRangDeb = j;
    }
    iNbEtabCRC++;
    if ((givrListCRC.iNbr - 1) == j)
    {
      iRgEtabCRC = 0;
      for(l=iRangDeb; l<(givrListCRC.iNbr) ; l++)
      {
        k = givrListCRC.trEltRangList[l];
        givrListCRC.trEltList[k].iNbEtabCRC = iNbEtabCRC;
        givrListCRC.trEltList[k].iRgEtabCRC = iRgEtabCRC;
        givrListCRC.trEltList[k].iNbCRCCRC = 1;
        givrListCRC.trEltList[k].iRgCRCCRC = 0;
        iRgEtabCRC++;
      }
    }
  }
  /* rang dans chaque crc */
  iNbCRCCRC = 0;
  iRgEtab = 0;
  iRgCRC = 0;
  iRangDeb = 0;
  for(j=0; j<(givrListCRC.iNbr); j++)
  {
    i = givrListCRC.trEltRangList[j];
    if ( ((iRgEtab != givrListCRC.trEltList[i].iRgEtab) || (iRgCRC != givrListCRC.trEltList[i].iRgCRC))
    	&& (-1 != givrListCRC.trEltList[i].iRgEtab) && (-1 != givrListCRC.trEltList[i].iRgCRC) )
    {
      iRgCRCCRC = 0;
      for(l=iRangDeb; l<j; l++)
      {
        k = givrListCRC.trEltRangList[l];
        givrListCRC.trEltList[k].iNbCRCCRC = iNbCRCCRC;
        givrListCRC.trEltList[k].iRgCRCCRC = iRgCRCCRC;
        iRgCRCCRC++;
      }
      iRgEtab = givrListCRC.trEltList[i].iRgEtab;
      iRgCRC = givrListCRC.trEltList[i].iRgCRC;
      iNbCRCCRC = 0;
      iRangDeb = j;
    }
    iNbCRCCRC++;
    if ((givrListCRC.iNbr - 1) == j)
    {
      iRgCRCCRC = 0;
      for(l=iRangDeb; l<(givrListCRC.iNbr) ; l++)
      {
        k = givrListCRC.trEltRangList[l];
        givrListCRC.trEltList[k].iNbCRCCRC = iNbCRCCRC;
        givrListCRC.trEltList[k].iRgCRCCRC = iRgCRCCRC;
        iRgCRCCRC++;
      }
    }
  }

  for(i=0; i<givrListCRC.iNbr; i++)
  {
    p= givrListCRC.trEltRangList[i];
    GWTTrace (GWT_NIV_FONCT,("crc  : %d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n",givrListCRC.iNbr,p,
                               givrListCRC.trEltList[p].iRgEtab,
                               givrListCRC.trEltList[p].iRgCRC,
                               givrListCRC.trEltList[p].iNbEtabCRC,
                               givrListCRC.trEltList[p].iRgEtabCRC,
                               givrListCRC.trEltList[p].iNbCRCCRC,
                               givrListCRC.trEltList[p].iRgCRCCRC
                               ));
  }

  if (0 != strcmp ("OUI",givtcGeneAffCRC))
  {
    /* pas d'affichage de CRC */
    return(iCodRet);
  }


  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;

  /* référence courante */
  (void)strcpy (rPrioCRC.acEtab,"00000000");
  (void)strcpy (rPrioCRC.acCRC,"");
  for(i=0; i< givrListCRC.iNbr;)
  {
    p = givrListCRC.trEltRangList[i];
    /* changement d'etab */
    if ((-1 == givrListCRC.trEltList[p].iRgEtab) || (-1 == givrListCRC.trEltList[p].iRgCRC))
    {
      /* bl sur epj complet */
      i += givrListCRC.trEltList[p].iNbEtabCRC;
      continue;
    }
    for(j=i; (j< i + givrListCRC.trEltList[p].iNbEtabCRC);)
    {
      q = givrListCRC.trEltRangList[j];
      /* changement de CRC */
      strcat(buf_pos, "<CRC crcan8=\"");
      if (0 != strcmp (givcR000000, givrListCRC.trEltList[q].acCodan8))
      {
        strcat(buf_pos, givrListCRC.trEltList[q].acCodan8);
      }
      strcat(buf_pos, "\">");
      lg_ecr = strlen(buf_pos);
      *(buf_pos+lg_ecr) = SEPARE_LIGNE;
      *(buf_pos + (lg_ecr+1) )= LINE_FEED;
      *(buf_pos + (lg_ecr+2) )= '\0';
      buf_pos = (buf_pos + lg_ecr +2);
      rr = -1;
      for(k=j; (k< j + givrListCRC.trEltList[q].iNbCRCCRC); k++)
      {
        /* même CRC */
        r = givrListCRC.trEltRangList[k];
        if ((-1 == givrListCRC.trEltList[r].iRgEtab) || (-1 == givrListCRC.trEltList[r].iRgCRC))
        {
          /* double */
          continue;
        }
      	/* crc et type */
              if ((-1 != rr) && ((0 != strcmp(givrListCRC.trEltList[r].acType,givrListCRC.trEltList[rr].acType))
      		|| (0 != strcmp(givrListCRC.trEltList[r].acCRC,givrListCRC.trEltList[rr].acCRC))))
      	{
          strcat(buf_pos, "</origine>");
          lg_ecr = strlen(buf_pos);
          *(buf_pos+lg_ecr) = SEPARE_LIGNE;
          *(buf_pos + (lg_ecr+1) )= LINE_FEED;
          *(buf_pos + (lg_ecr+2) )= '\0';
          buf_pos = (buf_pos + lg_ecr +2);
          strcat(buf_pos, "</CRC>");
          lg_ecr = strlen(buf_pos);
          *(buf_pos+lg_ecr) = SEPARE_LIGNE;
          *(buf_pos + (lg_ecr+1) )= LINE_FEED;
          *(buf_pos + (lg_ecr+2) )= '\0';
          buf_pos = (buf_pos + lg_ecr +2);
        }
      	if ((-1 == rr) || (0 != strcmp(givrListCRC.trEltList[r].acType,givrListCRC.trEltList[rr].acType))
      		|| (0 != strcmp(givrListCRC.trEltList[r].acCRC,givrListCRC.trEltList[rr].acCRC)))
      	{
          strcat(buf_pos, "<CRC crctype=\"");
          strcat(buf_pos, givrListCRC.trEltList[r].acType);
          strcat(buf_pos, "\">");
          strcat(buf_pos, givrListCRC.trEltList[r].acCRC);
          lg_ecr = strlen(buf_pos);
          *(buf_pos+lg_ecr) = SEPARE_LIGNE;
          *(buf_pos + (lg_ecr+1) )= LINE_FEED;
          *(buf_pos + (lg_ecr+2) )= '\0';
          buf_pos = (buf_pos + lg_ecr +2);
          strcat(buf_pos, "<origine>");
          lg_ecr = strlen(buf_pos);
          *(buf_pos+lg_ecr) = SEPARE_LIGNE;
          *(buf_pos + (lg_ecr+1) )= LINE_FEED;
          *(buf_pos + (lg_ecr+2) )= '\0';
          buf_pos = (buf_pos + lg_ecr +2);
        }
        strcat(buf_pos, "<origine>");
        if (' ' == givrListCRC.trEltList[r].acTpdsob[0])
        {
          strcat(buf_pos, &givrListCRC.trEltList[r].acTpdsob[1]);
        }
        else
        {
          strcat(buf_pos, givrListCRC.trEltList[r].acTpdsob);
        }
        strcat(buf_pos, "</origine>");
        lg_ecr = strlen(buf_pos);
        *(buf_pos+lg_ecr) = SEPARE_LIGNE;
        *(buf_pos + (lg_ecr+1) )= LINE_FEED;
        *(buf_pos + (lg_ecr+2) )= '\0';
        buf_pos = (buf_pos + lg_ecr +2);
        rr = r;
      }
      strcat(buf_pos, "</origine>");
      lg_ecr = strlen(buf_pos);
      *(buf_pos+lg_ecr) = SEPARE_LIGNE;
      *(buf_pos + (lg_ecr+1) )= LINE_FEED;
      *(buf_pos + (lg_ecr+2) )= '\0';
      buf_pos = (buf_pos + lg_ecr +2);
      strcat(buf_pos, "</CRC>");
      lg_ecr = strlen(buf_pos);
      *(buf_pos+lg_ecr) = SEPARE_LIGNE;
      *(buf_pos + (lg_ecr+1) )= LINE_FEED;
      *(buf_pos + (lg_ecr+2) )= '\0';
      buf_pos = (buf_pos + lg_ecr +2);
      /* CRC suivant */
      j = k;
      /* fin des crc */
      lg_write = giv_ecrit_fin_noeud(&buf_pos,"CRC");
      buf_pos = buf_pos + lg_write;

    }
    /* fin d'établissement */
    /* établissement suivant */
    i = j;
  }

  /* fin des crc */
  *buf_pos_in=buf_pos;

  return(iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givMutualiserDonPartenaires                                    */
/*                                                                            */
/* But       : mutualisation des contenus SGIPRO des partenaires               */
/*             de l'ensemble du bloc                                          */
/*                                                                            */
/* Entree(s) : un buffer, documents                                           */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Création	(Jan/09/2012 - mb)                                            */
/*----------------------------------------------------------------------------*/

static int4 givMutualiserDonPartenaires (char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice)

{
  int4 lg_ecr_micro = 0;
  int4 lg_ecr = 0;
  int4 i,j,q = 0;
  int4 lg_write;
  int4 iDebut;
  char *buf_pos;
  char *pt_fin_liste;
  char *pt_debut_element;
  char *pt_fin_element;
  char *pt_mil_element;
  char *pt_fin_lst;
  char *pt_debut;
  char *pt_fin;
  char *pt_mil;
  int4 iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  char tcBalise[50+1];
  char tcBalises[50+2];
  char tcElmt1[29+1];                         /* partenaire*/
  char tcElmt0[9+1];                         /* établissement*/
  char tcEtab[9+1];                         /* établissement lié à doc */
  char tcType[3];
  int4 lg_a_ecrire;
  int4 pipe;                          /* Flag pour ajout pipe */
  int4 iRet;

  pt_fin_liste = givtcObjCont + strlen(givtcObjCont);
  strcpy(tcType,"pr");
  pt_debut_element = strstr(givtcObjCont, "pr/");
  if (0 == pt_debut_element)
  {
    strcpy(tcType,"PR");
    pt_debut_element = strstr(givtcObjCont, "PR/");
    if (0 == pt_debut_element)
    {
      return(iCodRet);
    }
  }

  /* pas de gestion de conflit */
  giviConflitCRC = GWCCodeKO;
  /* ref de partenaire des doubles */
  memset(buf_concat, 0, strlen(buf_concat));
  pipe = 0;
  for(i=0; i< indice; i++)
  {
    for(q=0; (q< doc[i].value.a_classer.iNbPart && 0 != strlen(doc[i].value.a_classer.etab)); q++)
    {
      if (pipe == 0)
      {
        strcpy(buf_concat, doc[i].value.a_classer.trpart[q].rpart);
        strcat(buf_concat, ".");
        strcat(buf_concat, doc[i].value.a_classer.etab);
        pipe = 1;
      }
      else
      {
        strcat(buf_concat, "|");
        strcat(buf_concat, doc[i].value.a_classer.trpart[q].rpart);
        strcat(buf_concat, ".");
        strcat(buf_concat, doc[i].value.a_classer.etab);
      }
    }
    /* suppression des doubles références */
    iRet = supprimer_doublon(buf_concat, '|');
  }
  GWTTrace (GWT_NIV_FONCT,
            ("Ref partenaire pour DonPart %s,'%s'\n",doc[0].value.a_classer.etab,buf_concat ));
  if (0 == strlen(buf_concat))
  {
    return(iCodRet);
  }

  /* Pointeur sur debut du buffer */
  buf_pos = *buf_pos_in;

  /* Ecriture dans le fichier de sortie */
  if ('\0' != GIVBuffXML[0])
  {
    iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  }
  *buf_pos_in=buf_pos;

  pt_fin_element=strchr(pt_debut_element, ',');
  if (pt_fin_element == 0)
  {
    pt_fin_element = pt_fin_liste;
  }
  pt_mil_element=pt_debut_element+2;
    /* analyse type et balise associés */
    memcpy(tcBalise, (pt_mil_element+1), (pt_fin_element - pt_mil_element - 1));
    tcBalise[(pt_fin_element - pt_mil_element - 1)] = '\0';
    strcpy(tcBalises,tcBalise);
    /* strcat(tcBalises,"s"); */
      /* enrichissement des partenaires */
      /* écriture SGIPRO */
      iCodRet = (int4)GIXCodeKO;
      iDebut = 1;
        pt_fin_lst = buf_concat + strlen(buf_concat);
        for (pt_debut = buf_concat; pt_debut < pt_fin_lst; )
        {
          pt_fin=strchr(pt_debut, '|');
          if (pt_fin == 0)
          {
            pt_fin = pt_fin_lst;
          }
          pt_mil=strchr(pt_debut, '.');
          if (pt_mil == 0)
          {
            return(iCodRet);
          }
          /* analyse référence */
          memcpy(tcElmt1, pt_debut, (pt_mil - pt_debut));
          tcElmt1[(pt_mil - pt_debut)] = '\0';
          pt_mil++;
          memcpy(tcElmt0, pt_mil, (pt_fin - pt_mil));
          tcElmt0[(pt_fin - pt_mil)] = '\0';
           /* rétablir cohérence entre etab et doc */
          strcpy(tcEtab, doc[0].value.a_classer.etab);
          strcpy(doc[0].value.a_classer.etab, tcElmt0);
          if (0 == strcmp(tcType,"pr"))
          {
            iCodRet = givEcritSgiProPartEtab(&buf_pos, doc, indice, tcElmt0, tcElmt1, "PR", tcBalise, &iDebut);
          }
          else
          {
            iCodRet = givEcritSgiProPart(&buf_pos, doc, tcElmt0, tcElmt1, "PR", tcBalise, &iDebut);
          }
          strcpy(doc[0].value.a_classer.etab, tcEtab);
          pt_debut=pt_fin+1;
        }

  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
  }

  for(i=doc[0].value.a_classer.iNbPart; i< doc[0].value.a_classer.iNbPart + giviNbIapartPJDC; i++)
  {
  	/* référence de partenaire PJDC non intégrée */
  	j = doc[0].value.a_classer.trpart[i].iRgParent;
    strcat(buf_pos, cComm_xml0);
    strcat(buf_pos, givtrPart[j].acRefPart);
    strcat(buf_pos, " - ");
    if (0 != strlen(givtrPart[j].acPrenom))
    {
      strcat(buf_pos, givtrPart[j].acPrenom);
      strcat(buf_pos, " ");
    }
    strcat(buf_pos, givtrPart[j].acDenom);
    strcat(buf_pos, cComm_xml1);
    lg_ecr = strlen(buf_pos);
    *(buf_pos + lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + lg_ecr + 1) = LINE_FEED;
    *(buf_pos + lg_ecr + 2) = '\0';
    buf_pos = buf_pos + strlen(buf_pos);
  }

  if (0 != strlen(buf_concat))
  {
    pt_fin_lst = buf_concat + strlen(buf_concat);
    for (pt_debut = buf_concat; pt_debut < pt_fin_lst; )
    {
      pt_fin=strchr(pt_debut, '|');
      if (pt_fin == 0)
      {
        pt_fin = pt_fin_lst;
      }
      pt_mil=strchr(pt_debut, '.');
      if (pt_mil == 0)
      {
        return(iCodRet);
      }
      /* référence de partenaire */
      lg_write = giv_ecrit_noeud_simple(buf_pos, "infos_part");
      buf_pos = buf_pos + lg_write;
      memcpy(tcElmt1, pt_debut, (pt_mil - pt_debut));
      tcElmt1[(pt_mil - pt_debut)] = '\0';
      iRet = giv_ecrit_noeud_partenaire(&buf_pos, tcElmt1, doc->value.numero_bloc_parution, doc->value.a_classer.etab);
      lg_write = giv_ecrit_fin_noeud(&buf_pos,"infos_part");
      buf_pos = buf_pos + lg_write;
      pt_debut=pt_fin+1;
    }
  }



  *buf_pos_in=buf_pos;
  memset(buf_concat, 0, strlen(buf_concat));

  GWTTrace (GWT_NIV_FONCT,
            ("Sortie Ecriture DonPartenaires\n"));

  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritDonAdd()                                               */
/*                                                                            */
/* But       : ecrit les données additionnelles liées à l'établissement       */
/*             lecture xmltype via clob                                       */
/*                                                                            */
/* Entree(s) : un buffer, valeur_id_parution                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	() :                                                          */
/*----------------------------------------------------------------------------*/

static int4 givEcritDonAdd (char *apcType, char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice)

{
  int4 lg_ecr_micro = 0;
  int4 lg_ecr = 0;
  int4 i = 0;
  int4 k,x = 0;
  int4 iDebut = 1;
  int4 lg_write;
  char *buf_pos;
  char *pt_debut_element;
  char *pt_fin_element,*pt_mil_element,*pt_fin_liste;
  char tcObj[GYBIamicLgNumobj2];
  char tcSource[5+1];
  char tcConf[3+1];
  char tcBalise[50+1];
  int4 iCodRet,iRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_a_ecrire;
  char tcRef[3];
  char tcType[3];

  /* Pointeur sur debut du buffer */
  buf_pos = *buf_pos_in;
  /* balises configurées */
  strcpy(tcRef,"DA");
  strcpy(tcType,apcType);
  if (0 != strcmp(tcRef,apcType))
  {
    strcpy(tcConf,apcType);
    strcat(tcConf,"/");
    pt_debut_element = strstr(givtcObjCont,tcConf);
    if (0 == pt_debut_element)
    {
      tcType[0] = tolower(apcType[0]);
      tcType[1] = tolower(apcType[1]);
      strcpy(tcConf,tcType);
      strcat(tcConf,"/");
      pt_debut_element = strstr(givtcObjCont,tcConf);
      if (0 == pt_debut_element)
      {
    		      GWTTrace (GWT_NIV_FONCT,
              ("Contenu non configuré : %s\n", tcConf));
          return(iCodRet);
      }
    }
    pt_debut_element +=  strlen(tcConf);
    pt_fin_liste=strchr(pt_debut_element, ',');
    if (pt_fin_liste == 0)
    {
      pt_fin_liste = givtcObjCont + strlen(givtcObjCont);
    }
    memcpy(tcBalise, pt_debut_element, pt_fin_liste - pt_debut_element);
    tcBalise[pt_fin_liste - pt_debut_element] = '\0';
  }

  pt_debut_element = strstr(givtcObjCont, "DA/");
  if (0 == pt_debut_element)
  {
    pt_debut_element = strstr(givtcObjCont, "da/");
    if (0 == pt_debut_element)
    {
      return(iCodRet);
    }
  }

  /* Ecriture dans le fichier de sortie */
  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  }

  *buf_pos_in=buf_pos;

  pt_fin_liste=strchr(pt_debut_element, ',');
  if (pt_fin_liste == 0)
  {
    pt_fin_liste = givtcObjCont + strlen(givtcObjCont);
  }

  /* un seul epj entre les doc */
  i=0;
     pt_mil_element=pt_debut_element+3;
     while ( pt_fin_liste >  pt_mil_element)
     {
          /* analyse type et balise associés */
          pt_fin_element = strchr(pt_mil_element, '/');
          if ((pt_fin_element == 0) || ( pt_fin_element > pt_fin_liste))
          {
            pt_fin_element = pt_fin_liste;
          }
          memcpy(tcSource, pt_mil_element, pt_fin_element - pt_mil_element);
          tcSource[pt_fin_element - pt_mil_element] = '\0';
          GWTTrace (GWT_NIV_FONCT,("source DA %s, %s, %c, %s\n", apcType, tcSource,(doc+i)->value.a_classer.parinsee,(doc+i)->value.a_classer.etab));
        if (('0' == (doc+i)->value.a_classer.parinsee) &&
        	  (0 == strcmp(tcSource,giv_B2B)))
        {
        	/* pas parution des données insee pour B2B */
          pt_mil_element = pt_fin_element + 1;
        	continue;
        }
        /* lecture données additionnelles */
        if (0 == strcmp(tcRef,apcType))
        {
        	/* données additionnelles en base */
          iRet = givLectureEtabDonSupp((doc+i)->value.a_classer.etab,"",tcSource,giv_ADD);
          GWTTrace (GWT_NIV_FONCT,("source DA %s\n", (doc+i)->value.a_classer.etab));
        }
        else if (0 == strcmp(tcType,apcType))
        {
        	/* données additionnelles annotées en fichier */
          iCodRet = givEcritSgiProED(apcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, "", "", tcSource, &iDebut);
          GWTTrace (GWT_NIV_FONCT,("source AD %s\n", (doc+i)->value.a_classer.etab));
        }
        else
        {
        	/* données additionnelles annotées en base */
          iCodRet = givEcritDonEtab(apcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, "", "", tcSource, &iDebut);
          GWTTrace (GWT_NIV_FONCT,("source ad %s\n", (doc+i)->value.a_classer.etab));
        }
        if ((0 != strlen(GIVBuffInter)) && (0 == strcmp(tcRef,apcType)))
        {
          if (1 == iDebut)
          {
            lg_write = giv_ecrit_noeud_simple(buf_pos, "DonneesAddit");
            buf_pos = buf_pos + lg_write;
            iDebut = 0;
          }
          strcpy(buf_pos, "<Addit_");
        }
        else if ((0 != strlen(GIVBuffInter)) && (0 != strcmp(tcType,apcType)))
        {
          if (1 == iDebut)
          {
            lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);
            buf_pos = buf_pos + lg_write;
            iDebut = 0;
          }
          strcpy(buf_pos, "<Search_");
        }
        if ((0 != strlen(GIVBuffInter)) && ((0 != strcmp(tcType,apcType)) || (0 == strcmp(tcRef,apcType))))
        {
        strcat(buf_pos, tcSource);
        strcat(buf_pos, " etablissement=\"\" id=\"");
        strcat(buf_pos, (doc+i)->value.a_classer.etab);
        strcat(buf_pos, "\">");
        lg_ecr = strlen(buf_pos);
        *(buf_pos+lg_ecr) = SEPARE_LIGNE;
        *(buf_pos + (lg_ecr+1) )= LINE_FEED;
        *(buf_pos + (lg_ecr+2) )= '\0';
        buf_pos = (buf_pos + lg_ecr +2);
        strcpy(buf_pos, GIVBuffInter);
        lg_ecr = strlen(buf_pos);
        buf_pos = (buf_pos + lg_ecr);
        if (0 == strcmp(tcRef,apcType))
        {
          strcpy(buf_pos, "</Addit_");
        }
        else
        {
          strcpy(buf_pos, "</Search_");
        }
        strcat(buf_pos, tcSource);
        strcat(buf_pos, ">");
        lg_ecr = strlen(buf_pos);
        *(buf_pos+lg_ecr) = SEPARE_LIGNE;
        *(buf_pos + (lg_ecr+1) )= LINE_FEED;
        *(buf_pos + (lg_ecr+2) )= '\0';
        buf_pos = buf_pos + strlen(buf_pos);
        }
        if ('\0' != GIVBuffXML[0])
        {
          /* Ecriture dans le fichier de sortie */
          iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
        }
        /* source suivante */
          pt_mil_element = pt_fin_element + 1;
     }

  if ((0 == iDebut) && (0 == strcmp(tcRef,apcType)))
  {
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"DonneesAddit");
    buf_pos = buf_pos + lg_write;
  }
  else if (0 == iDebut)
  {
    lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBalise);
    buf_pos = buf_pos + lg_write;
  }

  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
  }

  *buf_pos_in=buf_pos;


  GWTTrace (GWT_NIV_FONCT,
            ("Sortie Ecriture Données enrichies par établissement\n"));

  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritDonHoraires()                                          */
/*                                                                            */
/* But       : ecrit les données info horaires                                */
/*             payantes liées à l'annonceur                                   */
/*             gratuites liées à l'établissement                              */
/*             lecture xmltype via clob                                       */
/*                                                                            */
/* Entree(s) : un buffer, valeur_id_parution                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	() :                                                          */
/*----------------------------------------------------------------------------*/

static int4 givEcritDonHoraires (char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice)

{
  int4 lg_ecr_micro = 0;
  int4 lg_ecr = 0;
  int4 i,j = 0;
  int4 k,x,kk = 0;
  int4 iDebut = 1;
  int4 iNbRub = 0;
  int4 iInitRub = -1;
  int4 iNbDV = 0;
  int4 iRefDE = -1;
  int4 lg_write;
  char *buf_pos;
  char *pt_debut_element,*pt_mil_element,*pt_debut_liste,*pt_debut_ref;
  char *pt_fin_element,*pt_fin_obj,*pt_fin_liste,*pt_fin_ref;
  char tcObj[GYBIamicLgNumobj2];
  char tcBalise[50+1];
  int4 iCodRet,iRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 iLg, lg_a_ecrire;
  int4 iRang,iObj;

  pt_fin_liste = givtcObjCont + strlen(givtcObjCont);
  pt_debut_element = strstr(givtcObjCont, "om/");
  if (0 == pt_debut_element)
  {
    pt_debut_element = strstr(givtcObjCont, "OM/");
    if (0 == pt_debut_element)
    {
      return(iCodRet);
    }
  }

  /* Pointeur sur debut du buffer */
  buf_pos = *buf_pos_in;

  /* Ecriture dans le fichier de sortie */
  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  }

  pt_fin_element=strchr(pt_debut_element, ',');
  if (pt_fin_element == 0)
  {
    pt_fin_element = pt_fin_liste;
  }
  pt_mil_element=pt_debut_element+2;
  /* analyse type et balise associés */
  memcpy(tcBalise, (pt_mil_element+1), (pt_fin_element - pt_mil_element - 1));
  tcBalise[(pt_fin_element - pt_mil_element - 1)] = '\0';

  *buf_pos_in=buf_pos;

  /* lecture des données horaires normalisées */
  iRang = -1;
  for(i=0; i<givrListObj.iNbr; i++)
  {
    k = givrListObj.trEltRangListObj[i];
    kk = givrListObj.trEltListObj[k].iRgLigne;
    iObj = givrListObj.trEltListObj[k].iRgObj;
    if (iRang != givrListObj.trEltListObj[k].iRangTri)
    {
    	iRang = givrListObj.trEltListObj[k].iRangTri;
      if (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].type, "X"))
      {
        /* lecture des infos horaires payantes */
        GWTTrace (GWT_NIV_FONCT,(" horaire normalisé obj %d,%s\n", iObj,(doc+kk)->value.objets_pub.micro[iObj].id));
        if (0 == strcmp((doc+kk)->value.objets_pub.micro[iObj].stype, "HO"))
        {
          iRet = givLectureEtabDonSupp("",(doc+kk)->value.objets_pub.micro[iObj].id,(doc+kk)->value.objets_pub.micro[iObj].stype,giv_HPN);
        }
        else if (2 == (doc+kk)->value.objets_pub.micro[iObj].iCVI)
        {
          iRet = givLectureEtabDonSupp("",(doc+kk)->value.objets_pub.micro[iObj].id,(doc+kk)->value.objets_pub.micro[iObj].stypcvi,giv_HPN);
        }
        else
        {
      	  /* contenu valide uniquement pour HO et CVI nouveau avec contenus associés */
          continue;
        }
        if (0 != strlen(GIVBuffInter))
        {
          if (1 == iDebut)
          {
            lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);
            buf_pos = buf_pos + lg_write;
            lg_write = giv_ecrit_noeud_simple(buf_pos, "ompars");
            buf_pos = buf_pos + lg_write;
            iDebut = 0;
          }
          strcpy(buf_pos, GIVBuffInter);
          lg_ecr = strlen(GIVBuffInter);
          buf_pos = (buf_pos + lg_ecr);
          GWTTrace (GWT_NIV_FONCT,(" horaire normalisé obj %d,%d,%s\n", kk, iObj, (doc+kk)->value.objets_pub.micro[iObj].id));
          /* Ecriture dans le fichier de sortie */
          iRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
        }
      }
    }
  }
  /* lecture des infos horaires gratuites */
  GWTTrace (GWT_NIV_FONCT,(" horaire normalisé epj %s\n", doc->value.a_classer.etab));
       iInitRub = -1;
       iNbRub = 0;
       iNbDV = 0;
       iRefDE = -1;
       for(j=0; j<giviNbProfEtab; j++)
       {
      	 if ('N' == givrListProfEtab[j].cIndic)
      	 {
      	 	 iNbRub++;
      	 	 if (0 == strcmp("DV",givrListProfEtab[j].tcType))
      	   {
      	   	 /* DV */
      	 	   iNbDV++;
      	 	 }
      	 	 else
      	   {
      	   	 /* DE */
      	 	   iRefDE = j;
      	 	 }
      	 }
       }
       for(j=0; j<giviNbProfEtab; j++)
       {
      	 if ('N' == givrListProfEtab[j].cIndic)
      	 {
      	 	 if ((-1 == iInitRub) && (1 == iNbRub))
      	 	 {
      	 	 	 /* seule donnée DHN pour un epj */
      	 	 	 iInitRub = j;
      	 	 }
      	 	 else if ((-1 == iInitRub) && (2 == iNbRub) && (-1 != iRefDE))
      	 	 {
      	 	 	 /* première donnée DHN plus récente entre DV et DE pour un epj */
      	 	 	 iInitRub = j;
      	 	 }
      	 	 else if ((-1 != iInitRub) && (2 == iNbRub) && (-1 != iRefDE))
      	 	 {
      	 	 	 /* seconde donnée DHN moins récente entre DV et DE pour un epj */
      	 	 	 continue;
      	 	 }
      	 	 else if (-1 == iRefDE)
      	 	 {
      	 	 	 /* plusieurs DHN DV sans DE pour un epj : pas de DHS */
      	 	 }
      	 	 else if (iRefDE == j)
      	 	 {
      	 	 	 /* plusieurs DHN DV avec DE pour un epj */
      	 	 }
      	 	 else
      	 	 {
      	 	 	 /* plusieurs DHN pour un epj */
      	 	 	 continue;
      	 	 }

           GWTTrace (GWT_NIV_FONCT,(" horaire normalisé epj %s,%s\n", givrListProfEtab[j].tcType,givrListProfEtab[j].tcAn8));
           iRet = givLectureEtabDonSupp(doc->value.a_classer.etab,givrListProfEtab[j].tcAn8,givrListProfEtab[j].tcType,giv_HGN);
           if (0 != strlen(GIVBuffInter))
           {
   	         if (1 == iDebut)
             {
               lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);
               buf_pos = buf_pos + lg_write;
               lg_write = giv_ecrit_noeud_simple(buf_pos, "ompars");
               buf_pos = buf_pos + lg_write;
               iDebut = 0;
             }
             strcpy(buf_pos, GIVBuffInter);
             lg_ecr = strlen(GIVBuffInter);
             buf_pos = (buf_pos + lg_ecr);
             /* Ecriture dans le fichier de sortie */
             iRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
           }
         }
       }

  if (0 == iDebut)
  {
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"ompars");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBalise);
    buf_pos = buf_pos + lg_write;
    /* Ecriture dans le fichier de sortie */
    iRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
  }

  *buf_pos_in=buf_pos;


  GWTTrace (GWT_NIV_FONCT,
            ("Sortie Ecriture Infos Horaires\n"));

  return(iCodRet);

}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritDonEnr()                                               */
/*             lecture xmltype via clob                                       */
/*                                                                            */
/* But       : ecrit les données enrichies liées à l'établissement            */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, valeur_id_parution                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	() :                                                          */
/*----------------------------------------------------------------------------*/

static int4 givEcritDonEnr (char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice)

{
  int4 lg_ecr_micro = 0;
  int4 lg_ecr = 0;
  int4 i,j = 0;
  int4 k,x = 0;
  int4 iDebut = 1;
  int4 lg_write;
  char *buf_pos;
  char *pt_debut_element,*pt_debut_obj,*pt_debut_liste,*pt_debut_ref;
  char *pt_fin_element,*pt_fin_obj,*pt_fin_liste,*pt_fin_ref;
  char tcObj[GYBIamicLgNumobj2];
  int4 iCodRet,iRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_a_ecrire;

  /* Pointeur sur debut du buffer */
  buf_pos = *buf_pos_in;

  /* Ecriture dans le fichier de sortie */
  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  }

  *buf_pos_in=buf_pos;

  i=0;
        /* lecture données enrichies */
        iRet = givLectureEtabDonSupp((doc+i)->value.a_classer.etab,"","EN",giv_ENR);
        if (0 != strlen(GIVBuffInter))
        {
        if (1 == iDebut)
        {
           lg_write = giv_ecrit_noeud_simple(buf_pos, "affscppar");
           buf_pos = buf_pos + lg_write;
           iDebut = 0;
        }
        strcpy(buf_pos, "<annonceur etablissement=\"\" id=\"");
        strcat(buf_pos, (doc+i)->value.a_classer.etab);
        strcat(buf_pos, "\">");
        lg_ecr = strlen(buf_pos);
        *(buf_pos+lg_ecr) = SEPARE_LIGNE;
        *(buf_pos + (lg_ecr+1) )= LINE_FEED;
        *(buf_pos + (lg_ecr+2) )= '\0';
        buf_pos = (buf_pos + lg_ecr +2);
        /* analyse <prestationsMenuPayant> */
        pt_debut_liste = NULL;
        pt_fin_liste = GIVBuffInter;
        pt_debut_element = NULL;
        pt_fin_element = NULL;
        pt_debut_ref = NULL;
        pt_fin_ref = NULL;
        while (NULL != pt_fin_liste)
        {
          pt_debut_element = strstr(pt_fin_liste,"<prestationsMenuPayant ");
          pt_fin_element = strstr(pt_fin_liste,"</prestationsMenuPayant>");
          if (NULL == pt_fin_element || NULL == pt_debut_element)
          {
            /* pas d'élément */
            break;
          }
          if (NULL == pt_debut_liste)
          {
            pt_debut_liste = pt_debut_element;
          }
          pt_fin_element += strlen("</prestationsMenuPayant>");
          pt_fin_element++;
          pt_fin_liste = pt_fin_element;
          pt_debut_obj = strstr(pt_debut_element,"numobj=\"");
          if ((NULL != pt_debut_obj) && (pt_debut_obj < pt_fin_element) && (NULL == pt_debut_ref))
          {
            pt_debut_obj += strlen("numobj=\"");
            pt_fin_obj = strchr(pt_debut_obj,'\"');
            if (NULL == pt_fin_obj)
            {
              /* pas d'objet */
              continue;
            }
            if (GYBIamicLgNumobj != (pt_fin_obj - pt_debut_obj))
            {
              /* pas d'objet */
              GWTTrace(GWT_NIV_FONCT,("pas d'objet lg %d\n",(pt_fin_obj - pt_debut_obj)));
              continue;
            }
            memcpy(tcObj, pt_debut_obj, (pt_fin_obj - pt_debut_obj));
            tcObj[(pt_fin_obj - pt_debut_obj)] = '\0';
            GWTTrace(GWT_NIV_FONCT,("Obj BOC <%s>\n", tcObj));
           for(j = 0; j < indice; j++)
           {
             for (x = 0; x < (doc+j)->value.objets_pub.nb_micro; x++)
             {
              if ( (0 == strcmp((doc+j)->value.objets_pub.micro[x].stype, "SC")) &&
                 (0 == strcmp((doc+j)->value.objets_pub.micro[x].sstype, "PV") ||
                  0 == strcmp((doc+j)->value.objets_pub.micro[x].sstype, "PB")) &&
                 (0 == strcmp((doc+j)->value.objets_pub.micro[x].id, tcObj)) )
              {
                GWTTrace(GWT_NIV_FONCT,("objet menu trouvé\n"));
                pt_debut_ref = pt_debut_element;
                pt_fin_ref = pt_fin_element;
                break;
              }
             }
             if ((doc+j)->value.objets_pub.nb_micro != x)
             {
             	 break;
             }
           }
          }
        }
        if ((NULL == pt_debut_ref) && (NULL == pt_debut_liste))
        {
          if (NULL != strstr(GIVBuffInter,"<prestationsMenuGratuit>"))
          {
            strcpy(buf_pos, "<prmenu>1</prmenu>");
          }
          else
          {
            strcpy(buf_pos, "<prmenu>0</prmenu>");
          }
          lg_ecr = strlen(buf_pos);
          *(buf_pos+lg_ecr) = SEPARE_LIGNE;
          *(buf_pos + (lg_ecr+1) )= LINE_FEED;
          *(buf_pos + (lg_ecr+2) )= '\0';
          buf_pos = (buf_pos + lg_ecr +2);
          strcpy(buf_pos, GIVBuffInter);
          lg_ecr = strlen(buf_pos);
        }
        else
        {
          if (NULL != pt_debut_ref)
          {
            strcpy(buf_pos, "<prmenu>1</prmenu>");
          }
          else if (NULL != strstr(GIVBuffInter,"<prestationsMenuGratuit>"))
          {
            strcpy(buf_pos, "<prmenu>1</prmenu>");
          }
          else
          {
            strcpy(buf_pos, "<prmenu>0</prmenu>");
          }
          lg_ecr = strlen(buf_pos);
          *(buf_pos+lg_ecr) = SEPARE_LIGNE;
          *(buf_pos + (lg_ecr+1) )= LINE_FEED;
          *(buf_pos + (lg_ecr+2) )= '\0';
          buf_pos = (buf_pos + lg_ecr +2);
          memcpy(buf_pos, GIVBuffInter,(pt_debut_liste-GIVBuffInter));
          lg_ecr = (pt_debut_liste-GIVBuffInter);
          buf_pos = (buf_pos + lg_ecr);
          if (NULL != pt_debut_ref)
          {
            memcpy(buf_pos, pt_debut_ref,(pt_fin_ref-pt_debut_ref));
            lg_ecr = (pt_fin_ref-pt_debut_ref);
            buf_pos = (buf_pos + lg_ecr);
          }
          strcpy(buf_pos, pt_fin_liste);
          lg_ecr = strlen(pt_fin_liste);
        }
        buf_pos = (buf_pos + lg_ecr);
        strcpy(buf_pos, "</annonceur>");
        lg_ecr = strlen(buf_pos);
        *(buf_pos+lg_ecr) = SEPARE_LIGNE;
        *(buf_pos + (lg_ecr+1) )= LINE_FEED;
        *(buf_pos + (lg_ecr+2) )= '\0';
        buf_pos = buf_pos + strlen(buf_pos);
        }
        if ('\0' != GIVBuffXML[0])
        {
          /* Ecriture dans le fichier de sortie */
          iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
        }

  if (0 == iDebut)
  {
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"affscppar");
    buf_pos = buf_pos + lg_write;
  }

  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
  }

  *buf_pos_in=buf_pos;


  GWTTrace (GWT_NIV_FONCT,
            ("Sortie Ecriture Données enrichies par établissement\n"));

  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritDonAnnonceur()                                         */
/*                                                                            */
/* But       : ecrit les contenus liées à l'annonceur                         */
/*             lecture xmltype via clob                                       */
/*                                                                            */
/* Entree(s) : un buffer, valeur_id_parution                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	() :                                                          */
/*----------------------------------------------------------------------------*/

static int4 givEcritDonAnnonceur (char **buf_pos_in, GYBrDOCUMENT *doc, int4 iDoc, int4 iRef, int4 indice, char* pcBalise, int4 iBalise)

{
  char *buf_pos;
  int4 iCodRet,iRet = GWCCodeOK;            /* Code retour de la fonction */
  char * pt_debut_liste,* pt_fin_liste,* pcFin;
  int4 lg_ecr;
  int4 i,k,iNbCRC;
  if (0 == strlen((doc+iDoc)->value.objets_pub.micro[iRef].id))
  {
    iCodRet = (int4)GIXCodeKO;
    return(iCodRet);
  }

  /* Pointeur sur debut du buffer */
  buf_pos = *buf_pos_in;
  iCodRet = GWCCodeKO;

  /* Ecriture dans le fichier de sortie */
  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  }

  *buf_pos_in=buf_pos;
  /* lecture des contenus */
  if (0 == (doc+iDoc)->value.objets_pub.micro[iRef].iCVI)
  {
    iRet = givLectureEtabDonSupp("",(doc+iDoc)->value.objets_pub.micro[iRef].id,(doc+iDoc)->value.objets_pub.micro[iRef].stype,giv_ANN);
  }
  else
  {
    iRet = givLectureEtabDonSupp("",(doc+iDoc)->value.objets_pub.micro[iRef].id,doc->value.objets_pub.micro[iRef].stypcvi,giv_ANN);
  }
  iNbCRC = giviNbCRC;
  if (0 != strlen(GIVBuffInter))
  {
    if (buf_pos == *buf_pos_in)
    {
      if (((int4)GIXCodeKO == iBalise) || ((int4)GIXCodeRIEN ==  iBalise))
      {
        lg_ecr = giv_ecrit_noeud_simple(buf_pos, pcBalise);
        buf_pos = buf_pos + lg_ecr;
      }
      iRet = giv_ecrit_objet_pub (&buf_pos, (doc+iDoc), 0, iRef, "objetcontenu");
    }

    pt_fin_liste = GIVBuffInter;
    pt_debut_liste = strstr(pt_fin_liste,"<sgipro>");
    pt_debut_liste += strlen("<sgipro>");
    pt_debut_liste ++;
    pt_fin_liste = strstr(pt_debut_liste,"</sgipro>");
    *pt_fin_liste = '\0';
    iRet = givAnalyseObjetXML((doc+iDoc)->value.objets_pub.micro[iRef].stype, (doc+iDoc), pt_debut_liste, &buf_pos);

    if ('\0' != GIVBuffXML[0])
    {
  GWTTrace (GWT_NIV_FONCT,
              ("EtabDonSupp : %s, %s, %d, %s\n", (doc+iDoc)->value.objets_pub.micro[iRef].id,(doc+iDoc)->value.objets_pub.micro[iRef].stype,strlen(GIVBuffInter),GIVBuffInter));
      if ((0 == strcmp("SC",(doc+iDoc)->value.objets_pub.micro[iRef].stype))
      	&& (0 != strcmp("SR",(doc+iDoc)->value.objets_pub.micro[iRef].sstype)))
      {
	      (void)strcpy (GIVBuffClob, GIVBuffXML);
        pcFin = strstr(GIVBuffClob, "</pvi>");
        if (0 != pcFin)
        {
          /* pour PVI inclusion du contenu "IP" */
          iRet = givLectureEtabDonSupp("",(doc+iDoc)->value.objets_pub.micro[iRef].id,"IP",giv_ANN);
          if (0 != strlen(GIVBuffInter))
          {
      	    /* copie de la fin de contenu SC */
      	    strcat(GIVBuffInter, pcFin);
            strcpy(pcFin, GIVBuffInter);
            strcpy(GIVBuffXML, GIVBuffClob);
      	    buf_pos = GIVBuffXML;
            lg_ecr = strlen(GIVBuffXML);
            buf_pos = (buf_pos + lg_ecr);
          }
          else
          {
            /* pour PVI inclusion du fichier "IP" */
            pcFin = strstr(GIVBuffXML, "</pvi>");
      	    strcpy(GIVBuffInter, pcFin);
      	    buf_pos = pcFin;
            iRet = givEcritImages(&buf_pos, (doc+iDoc), iRef);
            strcpy(buf_pos, GIVBuffInter);
            lg_ecr = strlen(GIVBuffInter);
            buf_pos = (buf_pos + lg_ecr);
          }
        }
      }

      if (buf_pos != *buf_pos_in)
      {
        iCodRet = GWCCodeOK;
      }
      /* Ecriture dans le fichier de sortie */
      iRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
    }
  }


  *buf_pos_in=buf_pos;


  GWTTrace (GWT_NIV_FONCT,
            ("Sortie Ecriture Contenus par annonceur %s, %s, %d, %d\n", (doc+iDoc)->value.objets_pub.micro[iRef].id,(doc+iDoc)->value.objets_pub.micro[iRef].stype,iNbCRC,giviNbCRC));

  return(iCodRet);


}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritDonEtab()                                              */
/*                                                                            */
/* But       : ecrit les contenus liées à l'établissement                     */
/*             lecture xmltype via clob                                       */
/*                                                                            */
/* Entree(s) : un buffer, valeur_id_parution                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	() :                                                          */
/*----------------------------------------------------------------------------*/

static int4 givEcritDonEtab (char *obj, char* pcBalise, char **buf_pos_in, char *buf_pos_ref, GYBrDOCUMENT *doc, char * tcRub, char * tcDep, char *tcSource, int4 *piDeb)

{
  char *buf_pos;
  int4 iCodRet,iRet = GWCCodeOK;            /* Code retour de la fonction */
  char * pt_debut_liste,* pt_fin_liste,* pcFin;
  char * pt_debut_element,* pt_fin_element;
  char * pcDebSite,* pcFinSite;
  int4 lg_ecr, iLg;
  int4 i,j,k,iNbCRC,iDeb;
  char tcAn9[GYBPaprofLgCodan9 + 1];
  char cStrRef[100 + 1] = "";
  char cStrFinRef[100 + 1] = "";

  /* Pointeur sur debut du buffer */
  buf_pos = *buf_pos_in;

  /* Ecriture dans le fichier de sortie */
  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  }

  for(i=0; i<giviNbContEtab; i++)
  {
	  if (0 == strcmp(doc->value.a_classer.etab, givrListContEtab[i].tcEtab))
	  {
	    if ((0 == strcmp(obj, givrListContEtab[i].tcType)) && (0 == strlen(tcRub)))
	    {
	    	 break;
	    }
	    else if ((0 == strcmp(obj, givrListContEtab[i].tcType)) && (0 == strcmp(tcRub, givrListContEtab[i].tcThm)))
	    {
	    	 break;
	    }
	  }
  }

  if (giviNbContEtab == i)
  {
  	/* contenu absent pour l'epj */
    GWTTrace (GWT_NIV_FONCT,
              ("Contenu absent pour l'epj : %s, %s\n", obj,doc->value.a_classer.etab));
    GIVBuffInter[0] = '\0';
  	return(iCodRet);
	}

  *buf_pos_in=buf_pos;
  /* lecture des contenus */
  if (0 != strcmp("AD",obj))
  {
    iRet = givLectureEtabDonSupp(doc->value.a_classer.etab,tcRub,obj,giv_EPJ);
  }
  else
  {
    iRet = givLectureEtabDonSupp(doc->value.a_classer.etab,tcSource,obj,giv_ANO);
  }
  iDeb = *piDeb;
  iNbCRC = giviNbCRC;
  iCodRet = (int4)GIXCodeKO;
  if (0 == strcmp("RA",obj))
  {
    strcpy(cStrRef,"<avis>");
    strcpy(cStrFinRef,"</avis>");
  }
  else
  {
    strcpy(cStrRef,"<sgipro>");
    strcpy(cStrFinRef,"</sgipro>");
  }
  if (0 != strlen(GIVBuffInter))
  {
        pcDebSite = strstr (GIVBuffInter, "<urlSite>");
        if ((0 == strcmp("EG",obj)) && (0 != pcDebSite))
        {
          pcDebSite += strlen("<urlSite>");
          pcFinSite = strstr (pcDebSite, "</urlSite>");
          if ((GYBIeinscLgLibUrl2 * 4) > (pcFinSite-pcDebSite))
          {
            memcpy(doc->value.objets_pub.libUrlSite, pcDebSite, pcFinSite-pcDebSite);
            doc->value.objets_pub.libUrlSite[pcFinSite-pcDebSite] = '\0';
          }
          else
          {
            GWTTrace (GWT_NIV_GRAVE,("Taille réservée pour liburlSite insuffisante %d, %s\n",(pcFinSite-pcDebSite),doc->value.a_classer.etab));
          }
        }
        if ((0 == strcmp("EG",obj)) && (1 == doc->value.a_classer.iBLEPJProf))
        {
          pt_debut_liste = NULL;
          pt_debut_element = NULL;
          pt_fin_element = NULL;
          pt_fin_liste = GIVBuffInter;

          while (NULL != pt_fin_liste)
          {
            pt_debut_element = strstr(pt_fin_liste,"<lstMarques>");
            if (NULL == pt_debut_element)
            {
              /* fin */
              pt_fin_liste = pt_debut_element;
            }
            else
            {
            	pt_debut_liste = pt_debut_element;
              pt_fin_element = strstr(pt_debut_element,"</lstMarques>");
              if (NULL == pt_fin_element)
              {
                /* fin */
                pt_fin_liste = pt_fin_element;
              }
              else
              {
                pt_fin_liste = pt_fin_element + strlen("</lstMarques>");
                iLg = strlen(pt_fin_liste)+1;
                memmove(pt_debut_liste,pt_fin_liste,iLg);
                pt_fin_liste = pt_debut_liste;
              }
            }
          }
        }
        else if (0 == strcmp("RA",obj))
        {
          pt_debut_liste = NULL;
          pt_debut_element = NULL;
          pt_fin_element = NULL;
          pt_fin_liste = GIVBuffInter;

          while (NULL != pt_fin_liste)
          {
            pt_debut_element = strstr(pt_fin_liste,"<fragment");
            if (NULL == pt_debut_element)
            {
              /* fin */
              pt_fin_liste = pt_debut_element;
            }
            else
            {
            	pt_debut_liste = pt_debut_element;
              pt_fin_element = strstr(pt_debut_element,"</fragment");
              if (NULL == pt_fin_element)
              {
                /* fin */
                pt_fin_liste = pt_fin_element;
              }
              else
              {
              	pt_fin_element++;
                pt_fin_liste = strchr(pt_fin_element, '<');
                pt_debut_element = strstr(pt_debut_liste,"rubrique");
                if (NULL != pt_debut_element)
                {
                  pt_debut_element = strchr(pt_debut_element,'>');
                  pt_fin_element = strchr(pt_debut_element,'<');
                  if ( NULL != pt_fin_element && NULL != pt_debut_element )
                  {
                    pt_debut_element++;
                    if ( GYBPaprofLgCodan9 == (pt_fin_element - pt_debut_element) )
                    {
                      memcpy(tcAn9, pt_debut_element, (pt_fin_element - pt_debut_element));
                      tcAn9[(pt_fin_element - pt_debut_element)] = '\0';
                      GWTTrace(GWT_NIV_FONCT,("Rub BOC <%s>\n", tcAn9));
                      for(i=0; i<(givrListParu.iNbrTot); i++)
                      {
                        j= givrListParu.trEltRangList[i];
                        if (0 == strcmp(givrListParu.trEltList[j].rub, tcRub))
                        {
                          break;
                        }
                      }
                      if (i != givrListParu.iNbrTot)
                      {
                        /* rubrique commune */
                        continue;
                      }
                    }
                  }
                }
                /* pas de rubrique commune : black liste */
                iLg = strlen(pt_fin_liste)+1;
                memmove(pt_debut_liste,pt_fin_liste,iLg);
                pt_fin_liste = pt_debut_liste;
              }
            }
          }
        }
  GWTTrace (GWT_NIV_FONCT,
              ("EtabDonSupp : %s, %s, %d, %s\n", obj,doc->value.a_classer.etab,strlen(GIVBuffInter),GIVBuffInter));

    if ( (1 == *piDeb) && ((0 == strcmp("GS",obj))
    	|| (0 == strcmp("RA",obj))
    	|| (0 == strcmp("AD",obj))
    	|| (0 == strcmp("DC",obj))) )
    {
      lg_ecr = giv_ecrit_noeud_simple(buf_pos, pcBalise);
      buf_pos = buf_pos + lg_ecr;
      *piDeb = 0;
    }
    else if (1 == *piDeb)
    {
      lg_ecr = giv_ecrit_noeud_simple(buf_pos, pcBalise);
      buf_pos = buf_pos + lg_ecr;

      strcpy(buf_pos, "<sgipro>");
      lg_ecr = strlen(buf_pos);
      *(buf_pos+lg_ecr) = SEPARE_LIGNE;
      *(buf_pos + (lg_ecr+1) )= LINE_FEED;
      *(buf_pos + (lg_ecr+2) )= '\0';
      buf_pos = (buf_pos + lg_ecr +2);
      *piDeb = 0;
    }
    pt_fin_liste = GIVBuffInter;
    pt_debut_liste = strstr(pt_fin_liste,cStrRef);
    if (NULL != pt_debut_liste)
    {
      pt_debut_liste += strlen(cStrRef);
      pt_debut_liste ++;
      pt_fin_liste = strstr(pt_debut_liste,cStrFinRef);
      *pt_fin_liste = '\0';
    }
    else
    {
      pt_debut_liste = GIVBuffInter;
    }
    iRet = givAnalyseObjetXML(obj, doc, pt_debut_liste, &buf_pos);

    if ((int4)GIXCodeKO == iRet)
    {
      /* fichier global non inclus : retour à état à l'appel */
      buf_pos = *buf_pos_in;
      *piDeb = iDeb;
      *buf_pos = '\0';
      giviNbCRC = iNbCRC;
      givrListCRC.iNbr = giviNbCRC;
    }
      if ((0 == strcmp("RA",obj)) || (0 == strcmp("DC",obj)))
      {
        lg_ecr = giv_ecrit_fin_noeud(&buf_pos,pcBalise);
      }
      /* Ecriture dans le fichier de sortie */
      iRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
      iCodRet = (int4)GIXCodeOK;
  }

  *buf_pos_in=buf_pos;


  GWTTrace (GWT_NIV_FONCT,
            ("Sortie Ecriture Contenus par établissement %s, %s, %s, %d, %d\n", doc->value.a_classer.etab,tcRub,obj,iNbCRC,giviNbCRC));

  return(iCodRet);


}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritDonRelais()                                            */
/*                                                                            */
/* But       : ecrit les données relais liées à l'établissement               */
/*             lecture xmltype via clob                                       */
/*                                                                            */
/* Entree(s) : un buffer, valeur_id_parution                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	() :                                                          */
/*----------------------------------------------------------------------------*/

static int4 givEcritDonRelais (char **buf_pos_in, GYBrDOCUMENT *doc, int4 aindice, int4 aindmax)

{
  int4 lg_ecr_micro = 0;
  int4 lg_ecr = 0;
  int4 i = 0;
  int4 lg_write;
  char *buf_pos;
  char *pt_debut_element,*pt_debut_obj,*pt_debut_liste,*pt_debut_ref;
  char *pt_fin_element,*pt_fin_obj,*pt_fin_liste,*pt_fin_ref;
  char tcObj[GYBIamicLgNumobj2];
  int4 iCodRet,iRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_a_ecrire;

  if (0 == strlen(doc->value.a_classer.etab))
  {
  	return(iCodRet);
  }


  /* Pointeur sur debut du buffer */
  buf_pos = *buf_pos_in;

  /* Ecriture dans le fichier de sortie */
  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  }

  *buf_pos_in=buf_pos;
  /* lecture données relais */
  iRet = givLectureEtabDonSupp(doc->value.a_classer.etab,"","RL",giv_REL);
  if ((0 != strlen(GIVBuffInter)) && (NULL == strstr(GIVBuffInter,"<lstde/>")))
  {
    strcpy(buf_pos, GIVBuffInter);
    lg_ecr = strlen(buf_pos);
    buf_pos = (buf_pos + lg_ecr);
  }

  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
  }

  *buf_pos_in=buf_pos;


  GWTTrace (GWT_NIV_FONCT,
            ("Sortie Ecriture Données Relais par établissement\n"));

  return(iCodRet);


}


/*----------------------------------Fonction----------------------------------*
 * Fonction : givProfURLGratuite
 *
 * But : numcli
 *
 * Description : Lecture de rubrique de suppression de CRC
 *               dans le fichier GS lié à l'URL Gratuite
 *               dans la table GYTTabURLGrProf.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLectureProfURLGratuite(char *apcCodAn8)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrIaprofT  rIaprof;
  EXEC SQL end declare section;
  int4 i;
  iCodRet = (int4)GIXCodeKO;
  iIntRet = (int4)GIXCodeOK;

  if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
  {
    return( iCodRet);
  }
  (void)strcpy (rIaprof.acCodan8,apcCodAn8);

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLectureProfURLGr");
  EXEC SQL OPEN crsLectureProfURLGr
      USING :rIaprof.acCodan8;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLectureProfURLGr %s: [COD=%d TXT=%s]\n", rIaprof.acCodan8, iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLectureProfURLGr");
    GWTTrace (GWT_NIV_FONCT,(" ProfURLGr... %s\n",rIaprof.acCodan8));
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLectureProfURLGr INTO
        :rIaprof.acCodan8;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeKO;
      }
      else
      {
        /* sortie sur opposition trouvée */
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeOK;
      }
    }

  }

  EXEC SQL close crsLectureProfURLGr;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLectureProfURLGr: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  return( iCodRet);
}

/*----------------------------------Fonction----------------------------------*
 * Fonction : givPrioProfCRC
 *
 * But : numcli
 *
 * Description : Lecture de priorité de CRC
 *               du le fichier contenu
 *               dans la table GYTTabCRCPrioProf.
 *
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 givLecturePrioProfCRC(char *apcCodAn8, char *apcCRC)
{
  int4                   iCodRet = 0;    /* Code retour de la fonction */
  int4                   iIntRet = 0;    /* Code retour des appels internes */
  int1           indFinFetch;/* Indicateur de fin de balayage du curseur */
  GYBrParam_erreurT     vErreurSQL;     /* Traitement des erreurs SQL */

  EXEC SQL begin declare section;
  GYBrPrioCRCT rPrioCRC;
  EXEC SQL end declare section;
  int4 i;
  iCodRet = (int4)GIXCodeKO;
  iIntRet = (int4)GIXCodeOK;

  if (0 == strcmp(GXWDepartMultiNat,GIXcDepartement))
  {
    return( iCodRet);
  }
  (void)strcpy (rPrioCRC.acCodan8,apcCodAn8);
  (void)strcpy (rPrioCRC.acCRC,apcCRC);

  /* Traitement des erreurs SQL */
  (void)strcpy (vErreurSQL.acOrdre_sql,
                  "open crsLecturePrioProfCRC");
  EXEC SQL OPEN crsLecturePrioProfCRC
      USING :rPrioCRC.acCodan8,
            :rPrioCRC.acCRC;

  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
                ("Erreur open crsLecturePrioProfCRC %s,%s: [COD=%d TXT=%s]\n", rPrioCRC.acCodan8, rPrioCRC.acCRC, iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  if ( (int4)GYBok == iIntRet )
  {
    indFinFetch = (int1)GIXCodeOK;
    (void)strcpy (vErreurSQL.acOrdre_sql,
                      "fetch crsLecturePrioProfCRC");
    GWTTrace (GWT_NIV_FONCT,(" PrioProfCRC... %s,%s\n",rPrioCRC.acCodan8,rPrioCRC.acCRC));
    while ((int1)GIXCodeOK == indFinFetch)
    {
      EXEC SQL FETCH crsLecturePrioProfCRC INTO
        :rPrioCRC.acCodan8;
      iIntRet = GIVBlocErreur (&vErreurSQL);
      if ( (int4)GYBok != iIntRet )
      {
        indFinFetch = (int1)GIXCodeKO;
        iCodRet = (int4)GIXCodeKO;
      }
      else
      {
        /* sortie sur opposition trouvée */
        indFinFetch = (int4)GIXCodeKO;
        iCodRet = (int4)GIXCodeOK;
      }
    }

  }

  EXEC SQL close crsLecturePrioProfCRC;
  iIntRet = GIVBlocErreur (&vErreurSQL);
  if ( (int4)GYBok != iIntRet )
  {
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur close crsLecturePrioProfCRC: [COD=%d TXT=%s]\n", iIntRet, vErreurSQL.acDonnees_retour));
    iCodRet = (int4)GIXCodeKO;
  }

  return( iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givAnalyseContenu()                                            */
/*                                                                            */
/* But       : conflits dans les contenus SGIPRO                              */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, valeur_id_parution                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	(Jui/20/2006 - mb) : création de plusieurs fichiers de sortie */
/*----------------------------------------------------------------------------*/

static int4 givAnalyseContenu (char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice)

{
  int4 iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 iRet,i,iCVI;
  char *pt_fin_liste;
  char *pt_debut_element;
  char *pt_fin_element;
  char *pt_mil_element;
  char *pt_suite_element;
  char *pt_fin_lst;
  char *pt_debut;
  char *pt_fin;
  char *pt_debut_CVI;
  char tcType[3+1];
  char tcTYPE[3+1];
  int4 lg_write;
  int4 iNbCVI;

  /* Analyse des contenus prioritaires */
  pt_fin_liste = givtcPrioCont + strlen(givtcPrioCont);
  /* table des contenus prioritaires vide */
  giviConflitCRC = GWCCodeOK;
  /* pas d'analyse des cvi */
  iCVI = GIXCodeKO;
  iNbCVI = givNbCVI;
  for (pt_debut_element = givtcPrioCont; pt_debut_element < pt_fin_liste; )
  {
    pt_fin_element=strchr(pt_debut_element, ',');
    if (pt_fin_element == 0)
    {
      pt_fin_element = pt_fin_liste;
    }
    pt_mil_element=strchr(pt_debut_element, '/');
    if (pt_mil_element == 0)
    {
      pt_mil_element = pt_fin_element;
    }
    /* analyse type et balise associés */
    memcpy(tcType, pt_debut_element, (pt_mil_element - pt_debut_element));
    tcType[(pt_mil_element - pt_debut_element)] = '\0';
    strcpy(tcTYPE,tcType);
    tcTYPE[0] = toupper(tcTYPE[0]);
    tcTYPE[1] = toupper(tcTYPE[1]);
    GWTTrace (GWT_NIV_FONCT,("Contenu prioritaire : %s\n",tcType ));
    if ((0 == strcmp(tcTYPE, "DC")) || (0 == strcmp(tcTYPE, "RA"))
    	|| (0 == strcmp(tcTYPE, "PR")) || (0 == strcmp(tcTYPE, "OM")) || (0 == strcmp(tcTYPE, "DA")))
    {
      pt_debut_element=pt_fin_element+1;
    	continue;
    }
    if ((0 == strcmp("EG",tcTYPE)) || (0 == strcmp("EM",tcTYPE)) || (0 == strcmp("GS",tcTYPE)) ||
        (0 == strcmp("ED",tcTYPE)) || (0 == strcmp("EE",tcTYPE)) || (0 == strcmp("BB",tcTYPE)) ||
        (0 == strcmp("AD",tcTYPE)) || (0 == strcmp("DV",tcTYPE)) || (0 == strcmp("MV",tcTYPE)))
    {
      iCodRet = givEcritContenuEDEtab(tcType, buf_pos_in, doc, indice);
    }
    else
    {
    	for ( i = 0; (i < iNbCVI && 0 != strcmp(givTabCVI[i],tcTYPE)); i++);
    	if ((iNbCVI != i) && (GIXCodeKO == iCVI))
    	{
    		/* premier CVI prioritaire : nouveau CVI */
    		pt_debut_CVI = pt_debut_element;
    	  iCVI = GIXCodeOK;
      GWTTrace (GWT_NIV_FONCT,("CVI Prio 1 : %d,%s\n", iCVI, tcType));
        iCodRet = givEcritContenu(tcType, buf_pos_in, doc, indice, &iCVI);
      }
    	else if ((iNbCVI == i) && (GIXCodeKO != iCVI))
    	{
    		/* premier CVI prioritaire : vintage/ancien CVI */
      GWTTrace (GWT_NIV_FONCT,("CVI Prio 2 : %d,%s\n", iCVI, tcType));
        if (GIXCodeOK != iCVI)
        {
    		  /* dernier CVI prioritaire : nouveau CVI */
          lg_write = giv_ecrit_fin_noeud(buf_pos_in,"affcviv");
          *buf_pos_in = *buf_pos_in + lg_write;
	      }
    		pt_debut_element = pt_debut_CVI;
    		iNbCVI = 0;
    	  iCVI = GIXCodeKO;
        continue;
      }
    	else
    	{
      GWTTrace (GWT_NIV_FONCT,("CVI Prio 3 : %d,%s\n", iCVI, tcType));
        iCodRet = givEcritContenu(tcType, buf_pos_in, doc, indice, &iCVI);
      }
    }
    pt_debut_element=pt_fin_element+1;
  }

  /* Analyse des autres contenus non prioritaires */
  pt_fin_liste = givtcObjCont + strlen(givtcObjCont);
  /* table des contenus prioritaires inutilisée */
  giviConflitCRC = GWCCodeKO;
  for (pt_debut_element = givtcObjCont; pt_debut_element < pt_fin_liste; )
  {
    pt_fin_element=strchr(pt_debut_element, ',');
    if (pt_fin_element == 0)
    {
      pt_fin_element = pt_fin_liste;
    }
    pt_mil_element=strchr(pt_debut_element, '/');
    if (pt_mil_element == 0)
    {
      break;
    }
    /* analyse premier type et balise associés */
    pt_suite_element=strchr(pt_debut_element, '|');
    if ((pt_suite_element != 0) && (pt_suite_element < pt_mil_element))
    {
      memcpy(tcType, pt_debut_element, (pt_suite_element - pt_debut_element));
      tcType[(pt_suite_element - pt_debut_element)] = '\0';
    }
    else
    {
      memcpy(tcType, pt_debut_element, (pt_mil_element - pt_debut_element));
      tcType[(pt_mil_element - pt_debut_element)] = '\0';
    }

    strcpy(tcTYPE,tcType);
    tcTYPE[0] = toupper(tcTYPE[0]);
    tcTYPE[1] = toupper(tcTYPE[1]);
    if (0 != strstr(givtcPrioCont, tcType))
    {
      /* contenu prioritaire déjà traité */
      pt_debut_element=pt_fin_element+1;
      continue;
    }
    GWTTrace (GWT_NIV_FONCT,("Contenu non prioritaire : %s\n",tcType ));
    if ((0 == strcmp(tcTYPE, "DC")) || (0 == strcmp(tcTYPE, "RA"))
    	|| (0 == strcmp(tcTYPE, "PR")) || (0 == strcmp(tcTYPE, "OM")) || (0 == strcmp(tcTYPE, "DA")))
    {
      pt_debut_element=pt_fin_element+1;
    	continue;
    }
    if ((0 == strcmp("EG",tcTYPE)) || (0 == strcmp("EM",tcTYPE)) || (0 == strcmp("GS",tcTYPE)) ||
        (0 == strcmp("ED",tcTYPE)) || (0 == strcmp("EE",tcTYPE)) || (0 == strcmp("BB",tcTYPE)) ||
        (0 == strcmp("AD",tcTYPE)) || (0 == strcmp("DV",tcTYPE)) || (0 == strcmp("MV",tcTYPE)))
    {
      iCodRet = givEcritContenuEDEtab(tcType, buf_pos_in, doc, indice);
    }
    else
    {
      iCVI = GIXCodeKO;
      iCodRet = givEcritContenu(tcType, buf_pos_in, doc, indice, &iCVI);
    }
    pt_debut_element=pt_fin_element+1;
  }

  return(iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givAnalyseObjetXML()                                           */
/*                                                                            */
/* But       : analyse des objets dans un fichier SGIPRO                      */
/*             modification au format mongoDB                                 */
/* Entree(s) : chaîne                                                         */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	:                                                             */
/*----------------------------------------------------------------------------*/

static int4 givAnalyseObjetXML (char *apcType, GYBrDOCUMENT *doc, char *apcChaine, char **buf_pos_in)
{
  char cStr1[4098 + 1] = "";
  char tcBalise[50+1];
  char tcBaliseFin[50+1];
  char *pt_debut_element,*pt_debut_liste;
  char *pt_fin_element,*pt_fin_liste;
  char *pt_debut_prtann,*pt_fin_prtann;
  char *buf_pos;
  int4 lg_ecr = 0;
  int4 iRet, iCodRet = (int4)GIXCodeOK;

  pt_debut_liste = NULL;
  pt_debut_element = NULL;
  pt_fin_element = NULL;
  pt_fin_liste = apcChaine;
  buf_pos = *buf_pos_in;

  pt_debut_prtann = strstr (pt_fin_liste,"<donneesprt_annotees");
  pt_fin_prtann = strstr (pt_fin_liste,"</donneesprt_annotees>");

    while (NULL != pt_fin_liste)
    {
      pt_debut_element = strchr(pt_fin_liste,'<');
      if (NULL == pt_debut_element)
      {
        strcpy(buf_pos, pt_fin_liste);
        lg_ecr = strlen(buf_pos);
        /* fin */
        pt_fin_liste = pt_debut_element;
        buf_pos = (buf_pos + lg_ecr);
      }
      else if (0 == memcmp(pt_debut_element,"<normale",strlen("<normale")))
      {
        pt_debut_liste = strchr(pt_debut_element,'>');
        pt_debut_liste++;
        memcpy(buf_pos, pt_fin_liste,(pt_debut_element-pt_fin_liste));
        lg_ecr = (pt_debut_element-pt_fin_liste);
        buf_pos = (buf_pos + lg_ecr);
        *buf_pos = '\0';
        pt_fin_element = strstr(pt_debut_liste,"</normale>");
        pt_fin_element += strlen("</normale>");
        pt_fin_liste = pt_fin_element;
        memcpy(cStr1, pt_debut_element,(pt_fin_element-pt_debut_element));
        cStr1[pt_fin_element-pt_debut_element] = '\0';
        /* analyse CRC */
        iRet = givAnalyseCRC(apcType, -1, doc, cStr1, tcBalise, tcBaliseFin);
        if ((int4)GIXCodeOK == iRet)
        {
        	/* ne pas inclure le contenu */
        	iCodRet = (int4)GIXCodeKO;
        }
        strcpy(buf_pos, cStr1);
        buf_pos = buf_pos + strlen(cStr1);
      }
      else if ((0 == memcmp(pt_debut_element,"<text>",strlen("<text>")))
      	 && (0 == strcmp("OUI",givtcContText))
      	 && (0 != strcmp(apcType,"PR") || (0 == strcmp(apcType,"PR") && NULL != pt_debut_prtann
      	 && pt_debut_prtann < pt_debut_element && pt_fin_prtann > pt_debut_element)))
      {
        pt_debut_liste = strchr(pt_debut_element,'>');
        pt_debut_liste++;
        memcpy(buf_pos, pt_fin_liste,(pt_debut_liste-pt_fin_liste));
        lg_ecr = (pt_debut_liste-pt_fin_liste);
        pt_fin_element = strstr(pt_debut_liste,"</text>");
        buf_pos = (buf_pos + lg_ecr);
        *buf_pos = SEPARE_LIGNE;
        *(buf_pos + 1) = LINE_FEED;
        *(buf_pos + 2) = '\0';
        buf_pos = (buf_pos + 2);
        strcpy(buf_pos, "<contenu>");
        buf_pos = buf_pos + strlen("<contenu>");
        memcpy(buf_pos, pt_debut_liste,(pt_fin_element-pt_debut_liste));
        lg_ecr = (pt_fin_element-pt_debut_liste);
        buf_pos = (buf_pos + lg_ecr);
        strcpy(buf_pos, "</contenu>");
        lg_ecr = strlen("</contenu>");
        buf_pos = (buf_pos + lg_ecr);
        *buf_pos = SEPARE_LIGNE;
        *(buf_pos + 1) = LINE_FEED;
        *(buf_pos + 2) = '\0';
        buf_pos = (buf_pos + 2);
        *buf_pos = '\0';
        pt_fin_liste = pt_fin_element;
      }
      else if ((0 == memcmp(pt_debut_element,"<surface>",strlen("<surface>")))
      	 && (0 != strcmp ("MO",apcType)))
      {
        pt_debut_liste = strchr(pt_debut_element,'>');
        pt_debut_liste++;
        memcpy(buf_pos, pt_fin_liste,(pt_debut_element-pt_fin_liste));
        lg_ecr = (pt_debut_element-pt_fin_liste);
        buf_pos = (buf_pos + lg_ecr);
        *buf_pos = '\0';
        /* remplacement par text */
        strcpy(buf_pos, "<text>");
        buf_pos = buf_pos + strlen("<text>");
        pt_fin_element = strstr(pt_debut_liste,"</surface>");
        if (0 == strcmp("NON",givtcContText))
        {
          memcpy(buf_pos, pt_debut_liste,(pt_fin_element-pt_debut_liste));
          lg_ecr = (pt_fin_element-pt_debut_liste);
        }
        else
        {
          buf_pos = (buf_pos + lg_ecr);
          *buf_pos = SEPARE_LIGNE;
          *(buf_pos + 1) = LINE_FEED;
          *(buf_pos + 2) = '\0';
          buf_pos = (buf_pos + 2);
        	strcpy(buf_pos, "<contenu>");
          buf_pos = buf_pos + strlen("<contenu>");
          memcpy(buf_pos, pt_debut_liste,(pt_fin_element-pt_debut_liste));
          lg_ecr = (pt_fin_element-pt_debut_liste);
          buf_pos = (buf_pos + lg_ecr);
          strcpy(buf_pos, "</contenu>");
          lg_ecr = strlen("</contenu>");
        }
        buf_pos = (buf_pos + lg_ecr);
        *buf_pos = '\0';
        pt_fin_element += strlen("</surface>");
        pt_fin_liste = pt_fin_element;
      }
      else if ((0 == memcmp(pt_debut_element,"<terme>",strlen("<terme>")))
      	 && (0 != strcmp ("MO",apcType)))
      {
        pt_debut_liste = strchr(pt_debut_element+1,'<');
        memcpy(buf_pos, pt_fin_liste,(pt_debut_element-pt_fin_liste));
        lg_ecr = (pt_debut_element-pt_fin_liste);
        buf_pos = (buf_pos + lg_ecr);
        *buf_pos = '\0';
        /* suppression */
        pt_fin_element = pt_debut_liste;
        pt_fin_liste = pt_fin_element;
      }
      else if ((0 == memcmp(pt_debut_element,"</terme>",strlen("</terme>")))
      	 && (0 != strcmp ("MO",apcType)))
      {
        pt_debut_liste = strchr(pt_debut_element,'>');
        pt_debut_liste++;
        memcpy(buf_pos, pt_fin_liste,(pt_debut_element-pt_fin_liste));
        lg_ecr = (pt_debut_element-pt_fin_liste);
        buf_pos = (buf_pos + lg_ecr);
        *buf_pos = '\0';
        /* remplacement par /text */
        strcpy(buf_pos, "</text>");
        buf_pos = buf_pos + strlen("</text>");
        pt_fin_element = pt_debut_liste;
        pt_fin_liste = pt_fin_element;
      }
      else
      {
        pt_debut_liste = strchr(pt_debut_element,'>');
        pt_debut_liste++;
        memcpy(buf_pos, pt_fin_liste,(pt_debut_liste-pt_fin_liste));
        lg_ecr = (pt_debut_liste-pt_fin_liste);
        buf_pos = (buf_pos + lg_ecr);
        *buf_pos = '\0';
        /* suite */
        pt_fin_element = pt_debut_liste;
        pt_fin_liste = pt_fin_element;
      }

    }
  *buf_pos_in = buf_pos;


  return(iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givAnalyseTerme()                                              */
/*                                                                            */
/* But       : analyse des objets terme dans un fichier SGIPRO                */
/*             modification au format mongoDB                                  */
/* Entree(s) : chaîne                                                         */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	:                                                             */
/*----------------------------------------------------------------------------*/

static int4 givAnalyseTerme (char *apcChaine)
{
  int4 iCodRet = (int4)GIXCodeKO;            /* Code retour de la fonction */
  char *pcDeb,*pcFin,*pcDebStr,*pcFinStr;
  GWTTrace (GWT_NIV_FONCT,("0 Test Texte/Contenu ... %s\n",apcChaine));

  pcDeb = strstr (apcChaine, "<terme>");
  if ((0 != pcDeb) && (0 == strcmp("NON",givtcContText)))
  {
    /* balise supprimée */
    *apcChaine = '\0';
    iCodRet = (int4)GIXCodeOK;
    return(iCodRet);
  }
  else if (0 != pcDeb)
  {
    /* balise remplacée */
    pcDeb += strlen("<terme>");
    pcFin = apcChaine+strlen(apcChaine);
    (void)strcpy(apcChaine, "<text>");
    memmove(apcChaine+strlen("<text>"),pcDeb,pcFin-pcDeb);
    *(apcChaine+strlen("<text>")+(pcFin-pcDeb)) = '\0';
    iCodRet = (int4)GIXCodeOK;
    return(iCodRet);
  }
  pcDeb = strstr (apcChaine, "<surface>");
  if ((0 != pcDeb) && (0 == strcmp("NON",givtcContText)))
  {
    /* balise remplacée */
    pcDeb += strlen("<surface>");
    pcFin = strstr (apcChaine, "</surface>");
    pcFinStr = apcChaine+strlen(apcChaine);
    if (0 == pcFin)
    {
      pcFin = pcFinStr;
      pcDebStr = pcFin;
    }
    else
    {
      /* balise supprimée */
      pcDebStr = pcFin + strlen("</surface>");
    }
    (void)strcpy(apcChaine, "<text>");
    memmove(apcChaine+strlen("<text>"),pcDeb,pcFin-pcDeb);
    memmove(apcChaine+strlen("<text>")+(pcFin-pcDeb),pcDebStr,pcFinStr-pcDebStr);
    *(apcChaine+strlen("<text>")+(pcFin-pcDeb)+(pcFinStr-pcDebStr)) = '\0';
    iCodRet = (int4)GIXCodeOK;
    return(iCodRet);
  }
  else if (0 != pcDeb)
  {
    /* balise remplacée */
    pcDeb += strlen("<surface>");
    pcFin = strstr (apcChaine, "</surface>");
    pcFinStr = apcChaine+strlen(apcChaine);
    if (0 == pcFin)
    {
      pcFin = pcFinStr;
      pcDebStr = pcFin;
    }
    else
    {
      /* balise supprimée */
      pcDebStr = pcFin + strlen("</surface>");
    }
    memmove(apcChaine+strlen("<contenu>"),pcDeb,pcFin-pcDeb);
    if (pcFin == pcFinStr)
    {
      memmove(apcChaine+strlen("<contenu>")+(pcFin-pcDeb),pcDebStr,pcFinStr-pcDebStr);
      (void)memcpy(apcChaine, "<contenu>",strlen("<contenu>"));
      *(apcChaine+strlen("<contenu>")+(pcFin-pcDeb)+(pcFinStr-pcDebStr)) = '\0';
    }
    else
    {
      memmove(apcChaine+strlen("<contenu>")+strlen("</contenu>")+(pcFin-pcDeb),pcDebStr,pcFinStr-pcDebStr);
      (void)memcpy(apcChaine, "<contenu>",strlen("<contenu>"));
      (void)memcpy(apcChaine+strlen("<contenu>")+(pcFin-pcDeb), "</contenu>",strlen("</contenu>"));
      *(apcChaine+strlen("<contenu>")+strlen("</contenu>")+(pcFin-pcDeb)+(pcFinStr-pcDebStr)) = '\0';
    }
    iCodRet = (int4)GIXCodeOK;
    return(iCodRet);
  }
  pcDeb = strstr (apcChaine, "<text>");
  if ((0 != pcDeb) && (0 == strcmp("OUI",givtcContText)))
  {
    /* balise remplacée */
    pcDeb += strlen("<text>");
    pcFin = strstr (apcChaine, "</text>");
    pcFinStr = apcChaine+strlen(apcChaine);
    if (0 == pcFin)
    {
      pcFin = pcFinStr;
      pcDebStr = pcFin;
    }
    else
    {
      /* balise supprimée */
      pcDebStr = pcFin + strlen("</text>");
    }
    memmove(apcChaine+strlen("<contenu>"),pcDeb,pcFin-pcDeb);
  GWTTrace (GWT_NIV_FONCT,("1 Test Texte/Contenu ... %s\n",apcChaine));
    if (pcFin == pcFinStr)
    {
      memmove(apcChaine+strlen("<contenu>")+(pcFin-pcDeb),pcDebStr,pcFinStr-pcDebStr);
      (void)memcpy(apcChaine, "<contenu>",strlen("<contenu>"));
      *(apcChaine+strlen("<contenu>")+(pcFin-pcDeb)+(pcFinStr-pcDebStr)) = '\0';
    }
    else if (0 == strchr (pcDebStr, '<'))
    {
      memmove(apcChaine+strlen("<contenu>")+strlen("</contenu>")+(pcFin-pcDeb),pcDebStr,pcFinStr-pcDebStr);
      (void)memcpy(apcChaine, "<contenu>",strlen("<contenu>"));
      (void)memcpy(apcChaine+strlen("<contenu>")+(pcFin-pcDeb), "</contenu>",strlen("</contenu>"));
      *(apcChaine+strlen("<contenu>")+strlen("</contenu>")+(pcFin-pcDeb)+(pcFinStr-pcDebStr)) = '\0';
    }
    else
    {
      memmove(apcChaine+strlen("<contenu>")+strlen("</contenu>")+strlen("</text>")+(pcFin-pcDeb),pcDebStr,pcFinStr-pcDebStr);
      (void)memcpy(apcChaine, "<contenu>",strlen("<contenu>"));
      (void)memcpy(apcChaine+strlen("<contenu>")+(pcFin-pcDeb), "</contenu></text>",strlen("</contenu></text>"));
      *(apcChaine+strlen("<contenu>")+strlen("</contenu>")+strlen("</text>")+(pcFin-pcDeb)+(pcFinStr-pcDebStr)) = '\0';
    }
  GWTTrace (GWT_NIV_FONCT,("2 Test Texte/Contenu ... %s\n",apcChaine));
    iCodRet = (int4)GIXCodeOK;
    return(iCodRet);
  }
  pcDeb = strstr (apcChaine, "</surface>");
  if ((0 != pcDeb) && (0 == strcmp("NON",givtcContText)))
  {
    /* balise supprimée */
    pcDebStr = pcDeb+strlen("</surface>");
    pcFinStr = apcChaine+strlen(apcChaine);
    memmove(pcDeb,pcDebStr,pcFinStr-pcDebStr);
    *(pcDeb+(pcFinStr-pcDebStr)) = '\0';
    iCodRet = (int4)GIXCodeOK;
    return(iCodRet);
  }
  else if (0 != pcDeb)
  {
    /* balise remplacée */
    pcDeb += strlen("</surface>");
    pcFin = apcChaine+strlen(apcChaine);
    memmove(apcChaine+strlen("</contenu>"),pcDeb,pcFin-pcDeb);
    (void)memcpy(apcChaine, "</contenu>",strlen("</contenu>"));
    *(apcChaine+strlen("</contenu>")+(pcFin-pcDeb)) = '\0';
    iCodRet = (int4)GIXCodeOK;
    return(iCodRet);
  }
  pcDeb = strstr (apcChaine, "</terme>");
  if (0 != pcDeb)
  {
    /* balise remplacée */
    pcDeb += strlen("</terme>");
    pcFin = apcChaine+strlen(apcChaine);
    (void)strcpy(apcChaine, "</text>");
    memmove(apcChaine+strlen("</text>"),pcDeb,pcFin-pcDeb);
    *(apcChaine+strlen("</text>")+(pcFin-pcDeb)) = '\0';
    iCodRet = (int4)GIXCodeOK;
    return(iCodRet);
  }
  pcDeb = strstr (apcChaine, "</text>");
  if ((0 != pcDeb) && (0 == strcmp("OUI",givtcContText)))
  {
    /* balise remplacée */
    pcDebStr = pcDeb;
    pcDeb += strlen("</text>");
    pcFin = apcChaine+strlen(apcChaine);
    /* modif */
    pcFinStr = strchr (pcDeb, '<');
    if (0 == pcFinStr)
    {
      memmove(pcDebStr+strlen("</contenu>"),pcDeb,pcFin-pcDeb);
      (void)memcpy(pcDebStr, "</contenu>",strlen("</contenu>"));
      *(pcDebStr+strlen("</contenu>")+(pcFin-pcDeb)) = '\0';
    }
    else
    {
      memmove(pcDebStr+strlen("</contenu>")+strlen("</text>"),pcDeb,pcFin-pcDeb);
      (void)memcpy(pcDebStr, "</contenu>",strlen("</contenu>"));
      (void)memcpy(pcDebStr+strlen("</contenu>"), "</text>",strlen("</text>"));
      *(pcDebStr+strlen("</contenu>")+strlen("</text>")+(pcFin-pcDeb)) = '\0';
    }
    iCodRet = (int4)GIXCodeOK;
    return(iCodRet);
  }
  else if ((0 != pcDeb) && (0 == strcmp("OUI",givtcContText)) && (pcDeb != apcChaine))
  {
    /* balise remplacée */
    pcDeb += strlen("</text>");
    pcFin = apcChaine+strlen(apcChaine);
    memmove(pcDeb+strlen("</contenu>")-strlen("</text>"),pcDeb,pcFin-pcDeb);
    (void)memcpy(pcDeb-strlen("</text>"), "</contenu>",strlen("</contenu>"));
    *(pcDeb+strlen("</contenu>")-strlen("</text>")+(pcFin-pcDeb)) = '\0';
    iCodRet = (int4)GIXCodeOK;
    return(iCodRet);
  }

  return(iCodRet);
}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givAnalyseCRC()                                                */
/*                                                                            */
/* But       : analyse CRC dans un fichier SGIPRO                             */
/*             modification de balise normale en SCG_                         */
/*             . selon rubrique du bloc                                       */
/*             . selon analyse de fichier GS                                  */
/*             . selon priorité                                               */
/* Entree(s) : etab,an9,CRC                                                   */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	:                                                             */
/*----------------------------------------------------------------------------*/

static int4 givAnalyseCRC (char *apcType, int4 aiRef, GYBrDOCUMENT *doc, char *apcCRC, char *apcBalise, char *apcBaliseFin)

{
  int4 iIntRet, iCodRet = (int4)GIXCodeKO;            /* Code retour de la fonction */
  int4 iRet;
  int4 i,j;
  char *pcStr,*pcDeb,*pcFin,*pcDebStr,*pcFinStr;
  int4 iLg;
  GYBrPrioCRCT rPrioCRC;
  char tcAn9Courant[GYBPaprofLgCodan9 + 1];

  (void)strcpy (rPrioCRC.acTpdsob,apcType);
  rPrioCRC.acType[0] = '\0';
  (void)strcpy (rPrioCRC.acEtab,doc->value.a_classer.etab);
  (void)strcpy (rPrioCRC.acCodan8, givcR000000);
  pcDeb = strstr (apcCRC, "<normale");
  strcpy (apcBalise, "");
  strcpy (apcBaliseFin, "");
  if (0 == pcDeb)
  {
    /* pas de balise normale correcte : sans changement */
    for ( i = 0; (i < givNbCVI &&
                  ((0 != strcmp(givTabCVI[i],doc->value.objets_pub.micro[aiRef].stype)) ||
                  (2 != doc->value.objets_pub.micro[aiRef].iCVI)))
                  ; i++);
    if ((givNbCVI != i) || (0 == strcmp("DV",apcType)) || (0 == strcmp ("MO",apcType)))
    {
      /* pas de traitement de "terme" pour CVIV nouvelle ou fichier DV ou Mot Clé */
  	  return(iCodRet);
  	}

    pcDeb = strstr (apcCRC, "<text>");
    pcStr = strstr (apcCRC, "<surface>");
    if (0 == pcStr)
    {
      pcStr = strstr (apcCRC, "</surface>");
    }
    if ((0 != pcDeb) && (0 == strcmp("OUI",givtcContText)))
    {
    	/* analyse des blocs "texte" */
    	strcpy (apcBalise, "text");
    }
    /* analyse des blocs "terme" */
    iIntRet = givAnalyseTerme(apcCRC);
    /* analyse des blocs "texte" */
    pcDeb = strstr (apcCRC, "</contenu>");
    if ((0 != pcDeb) && (0 == pcStr) && (0 == strcmp("OUI",givtcContText)))
    {
      pcDeb = strstr (apcCRC, "</text>");
      if (0 == pcDeb)
      {
    	  strcpy (apcBaliseFin, "text");
    	}
    }
  GWTTrace(GWT_NIV_FONCT,
           ("Balise Text <%s> <%s> <%s>\n", apcCRC, apcBalise, apcBaliseFin));
    return(iCodRet);
  }
  else
  {
    pcFin = strstr (pcDeb, ">");
    if (0 == pcFin)
    {
      /* pas de balise normale correcte : sans changement */
      return(iCodRet);
    }
    pcStr = pcDeb;
    pcDebStr = strstr (pcDeb, " type=\"");
    if ((0 != pcDebStr) && (pcDebStr < pcFin))
    {
      pcStr = pcDebStr + strlen(" type=\"");
      if ('"' != *pcStr)
      {
        pcFinStr = strstr (pcStr, "\"");
        if (0 != pcFinStr)
        {
          if (GYBLgPrioType2 <= (pcFinStr-pcStr))
          {
            memcpy(rPrioCRC.acType,pcStr,GYBLgPrioType2-1);
            rPrioCRC.acType[GYBLgPrioType2-1] = '\0';
          }
          else
          {
            memcpy(rPrioCRC.acType,pcStr,pcFinStr-pcStr);
            rPrioCRC.acType[pcFinStr - pcStr] = '\0';
          }
        }
      }
    }
    pcDebStr = strstr (pcDeb, " an8=\"");
    if ((0 != pcDebStr) && (pcDebStr < pcFin))
    {
      pcStr = pcDebStr + strlen(" an8=\"");
      if ('"' != *pcStr)
      {
        pcFinStr = strstr (pcStr, "\"");
        if (0 != pcFinStr)
        {
          if (GYBIaprofLgCodan8 <= (pcFinStr-pcStr))
          {
            memcpy(rPrioCRC.acCodan8,pcFinStr-GYBIaprofLgCodan8,GYBIaprofLgCodan8);
          }
          else
          {
            memcpy(&rPrioCRC.acCodan8[GYBIaprofLgCodan8-(pcFinStr-pcStr)],pcStr,pcFinStr-pcStr);
          }
          /* rubrique cadrée sur 6 caractères */
          iLg = GYBPaprofLgCodan8 + strlen(pcFinStr);
          memmove(pcStr+GYBIaprofLgCodan8,pcFinStr,strlen(pcFinStr));
          memcpy(pcStr,rPrioCRC.acCodan8,GYBIaprofLgCodan8);
          *(pcStr+iLg) = '\0';
        }
      }
    }
    pcStr = strstr (pcStr, ">");
  }
  pcStr = pcStr + strlen(">");

  GWTTrace (GWT_NIV_FONCT,(" Analyse SCG_... %s\n",rPrioCRC.acCodan8));
  /* recherche de la rubrique de CRC hors exception parmi les rubriques du bloc */
  i = 0;
  if ((NULL == strstr(givtcExceptCont,rPrioCRC.acCodan8)) && (0 != strcmp ("EE",apcType)) && (0 != strcmp ("EM",apcType))
  	 && (0 != strcmp ("MO",apcType)))
  {
    if (-1 != aiRef)
    {
      /* inclusion par objet */
      iRet = givInclusionRubrique(rPrioCRC.acCodan8, doc, aiRef);
      if ((int4)GWCCodeKO == iRet)
      {
      	/* pas d'inclusion dans les rubriques de l'objet */
      	i = givrListParu.iNbr;
      }
    }
    else
    {
      /* inclusion par bloc */
      strcpy(tcAn9Courant, givcR00000000);
      for(i=0; i<(givrListParu.iNbr); i++)
      {
        j= givrListParu.trEltRangList[i];
        if (0 != strcmp(tcAn9Courant, givrListParu.trEltList[j].rub))
        {
          strcpy(tcAn9Courant, givrListParu.trEltList[j].rub);
          if (0 == strcmp(rPrioCRC.acCodan8, givrListParu.trEltList[j].rubinit))
          {
      	    break;
          }
        }
      }
    }
  }
  if ((givrListParu.iNbr == i) && (0 != strcmp (givcR000000, rPrioCRC.acCodan8)))
  {
    /* rubrique de CRC absente des rubriques du bloc */
    /* balise CRC marquée supprimée */
    GWTTrace (GWT_NIV_FONCT,(" SCG_IAPROF... %s\n",apcCRC ));
    iLg = strlen(apcCRC);
    memmove(pcStr+strlen("SCG_"),pcStr,strlen(pcStr));
    memcpy(pcStr,"SCG_",strlen("SCG_"));
    *(apcCRC+iLg+strlen("SCG_")) = '\0';
    GWTTrace (GWT_NIV_FONCT,(" SCG_IAPROF... %s\n",apcCRC ));
    return(iCodRet);
  }
  if ((0 == strcmp("GS",apcType)) && (0 != strcmp (givcR000000, rPrioCRC.acCodan8)))
  {
    /* liste d'opposition CRC de fichier GS */
    iCodRet = givOppositionURLGratuite(doc->value.a_classer.etab, rPrioCRC.acCodan8);
    if ((int4)GIXCodeOK == iCodRet)
    {
      /* fichier non inclus */
      return(iCodRet);
    }
  }

  iCodRet = (int4)GIXCodeKO;
  /* priorité du CRC du fichier contenu */
  pcFinStr = strstr (pcStr, "</normale>");
  if (0 == pcFinStr)
  {
    /* balise absente : sans changement */
    return(iCodRet);
  }
  else if ((pcFinStr - pcStr) < 0)
  {
    /* balise absente : sans changement */
    return(iCodRet);
  }
  /* CRC */
  if (GYBLgPrioCRC2 <= (pcFinStr-pcStr))
  {
    memcpy(rPrioCRC.acCRC,pcStr,GYBLgPrioCRC2-1);
    rPrioCRC.acCRC[GYBLgPrioCRC2-1] = '\0';
  }
  else
  {
    memcpy(rPrioCRC.acCRC,pcStr,pcFinStr-pcStr);
    rPrioCRC.acCRC[pcFinStr - pcStr] = '\0';
  }

  if (0 != strcmp ("MO",apcType))
  {
    /* analyse du black-listage en liste réponse */
    iCodRet = givLectureBListCRCLR(&rPrioCRC);
    if ((int4)GIXCodeOK == iCodRet)
    {
      /* balise CRC marquée supprimée */
      iCodRet = (int4)GIXCodeKO;
      GWTTrace (GWT_NIV_FONCT,(" SCG_BL_LR... %s\n",apcCRC ));
      iLg = strlen(apcCRC);
      memmove(pcStr+strlen("SCG_"),pcStr,strlen(pcStr));
      memcpy(pcStr,"SCG_",strlen("SCG_"));
      *(apcCRC+iLg+strlen("SCG_")) = '\0';
      GWTTrace (GWT_NIV_FONCT,(" SCG_BL_LR... %s\n",apcCRC ));
      return(iCodRet);
    }

    /* analyse du black-listage en fiche détaillée */
    iCodRet = givLectureBListCRCFD(&rPrioCRC);
    if ((int4)GIXCodeOK == iCodRet)
    {
      /* balise CRC marquée supprimée */
      iCodRet = (int4)GIXCodeKO;
      GWTTrace (GWT_NIV_FONCT,(" SCG_BL_FD... %s\n",apcCRC ));
      iLg = strlen(apcCRC);
      memmove(pcStr+strlen("SCG_"),pcStr,strlen(pcStr));
      memcpy(pcStr,"SCG_",strlen("SCG_"));
      *(apcCRC+iLg+strlen("SCG_")) = '\0';
      GWTTrace (GWT_NIV_FONCT,(" SCG_BL_FD... %s\n",apcCRC ));
      /* balise conservée à l'affichage en fiche détaillée */
      rPrioCRC.iPrioCRC = GIXCodeKO;
      iIntRet = givAjoutListCRC(rPrioCRC);
      return(iCodRet);
    }
  }

  if ((0 == strcmp("GS",apcType)) && (0 != strcmp (givcR000000, rPrioCRC.acCodan8)))
  {
    /* suppression de CRC de fichier GS */
    iCodRet = givLectureProfURLGratuite(rPrioCRC.acCodan8);
    for ( i = 0; i < nb_micro && !(0 == strcmp(doc->value.objets_pub.micro[i].type, "X") && 0 == strcmp(doc->value.objets_pub.micro[i].stype, " U")); i++);
    GWTTrace (GWT_NIV_FONCT,("GS et U... %d, %d\n",i,nb_micro));

    if ((int4)GIXCodeKO == iCodRet)
    {
      /* balise CRC marquée supprimée */
      GWTTrace (GWT_NIV_FONCT,(" SCG_GS... %s\n",apcCRC ));
      iLg = strlen(apcCRC);
      memmove(pcStr+strlen("SCG_"),pcStr,strlen(pcStr));
      memcpy(pcStr,"SCG_",strlen("SCG_"));
      *(apcCRC+iLg+strlen("SCG_")) = '\0';
      GWTTrace (GWT_NIV_FONCT,(" SCG_GS... %s\n",apcCRC ));
    }
    if (nb_micro != i)
    {
    	/* coexistence avec type U */
      /* balise non conservée à l'affichage en fiche détaillée */
      iCodRet = (int4)GIXCodeKO;
      return(iCodRet);
    }
  }

  if (GWCCodeOK != giviConflitCRC)
  {
    /* pas de conflit hors priorité */
    rPrioCRC.iPrioCRC = GIXCodeKO;
  }
  else
  {
    /* conflit si priorité */
    rPrioCRC.iPrioCRC = GIXCodeOK;
  }

 GWTTrace (GWT_NIV_FONCT,(" Analyse SCG_... %s\n",rPrioCRC.acCRC));
  for(i=0; (i< giviNbCRC && GIXCodeOK == rPrioCRC.iPrioCRC); i++)
  {
    /* contenu prioritaire pour la rubrique */
    if ((0 == strcmp(givrListCRC.trEltList[i].acCodan8,rPrioCRC.acCodan8)) &&
       (0 == strcmp(givrListCRC.trEltList[i].acCRC,rPrioCRC.acCRC)) &&
       (GIXCodeOK == givrListCRC.trEltList[i].iPrioCRC))
    {
      /* balise sans changement */
      break;
    }
  }
  if (GIXCodeOK != rPrioCRC.iPrioCRC)
  {
    rPrioCRC.iPrioCRC = GIXCodeKO;
    iIntRet = givAjoutListCRC(rPrioCRC);
  }
  else if (giviNbCRC == i)
  {
    iCodRet = givLecturePrioProfCRC(rPrioCRC.acCodan8, rPrioCRC.acCRC);
    if ((int4)GIXCodeOK == iCodRet)
    {
      /* contenu soumis à priorité pour la rubrique */
      for(j=0; j< giviNbCRC; j++)
      {
        /* contenu non prioritaire pour la rubrique */
        if ((0 == strcmp(givrListCRC.trEltList[j].acCodan8,rPrioCRC.acCodan8))
        	&& (0 != strcmp(givrListCRC.trEltList[j].acTpdsob,rPrioCRC.acTpdsob))
        	&& (GIXCodeOK == givrListCRC.trEltList[j].iPrioCRC))
        {
          break;
        }
      }
      if (giviNbCRC == j)
      {
      	/* contenu prioritaire pour la rubrique */
        /* balise sans changement */
        iIntRet = givAjoutListCRC(rPrioCRC);
      }
      else
      {
        /* contenu non prioritaire pour la rubrique */
        /* balise CRC marquée supprimée */
        GWTTrace (GWT_NIV_FONCT,(" SCG_PRIO... %s\n",apcCRC ));
        iLg = strlen(apcCRC);
        memmove(pcStr+strlen("SCG_"),pcStr,strlen(pcStr));
        memcpy(pcStr,"SCG_",strlen("SCG_"));
        *(apcCRC+iLg+strlen("SCG_")) = '\0';
        GWTTrace (GWT_NIV_FONCT,(" SCG_PRIO... %s\n",apcCRC ));
        iCodRet = (int4)GIXCodeKO;
        return(iCodRet);
      }
    }
    else
    {
      rPrioCRC.iPrioCRC = GIXCodeKO;
      iIntRet = givAjoutListCRC(rPrioCRC);
    }
    iCodRet = (int4)GIXCodeKO;
  }
  else if (0 != strcmp(givrListCRC.trEltList[i].acEtab,rPrioCRC.acEtab))
  {
    rPrioCRC.iPrioCRC = GIXCodeKO;
    iIntRet = givAjoutListCRC(rPrioCRC);
  }
  givrListCRC.iNbr = giviNbCRC;

  return(iCodRet);
}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritContenuED()                                              */
/*                                                                            */
/* But       : ecrit les contenus SGIPRO                                      */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, valeur_id_parution                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	(Jui/20/2006 - mb) : création de plusieurs fichiers de sortie */
/*----------------------------------------------------------------------------*/

static int4 givEcritContenuED (char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice)

{
  int4 lg_ecr_micro = 0;
  int4 lg_ecr = 0;
  int4 i = 0;
  int4 j = 0;
  int4 k = 0;
  int4 l = 0;
  int4 iDebut;
  int4 lg_write;
  char *buf_pos;
  int4 iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_a_ecrire;

  /* Pointeur sur debut du buffer */
  buf_pos = *buf_pos_in;

  /* Ecriture dans le fichier de sortie */
  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = giv_sortie_ISO (&buf_pos, GIVfDescFicBloc);
  }

  *buf_pos_in=buf_pos;
  iDebut = 1;

  for(j=0; j<(givrListParu.iNbr); j++)
  {
    /* inscription locale */
    l= givrListParu.trEltRangList[j];
    if ( giv_LOC == givrListParu.trEltList[l].iGeoLoc )
    {
      /* écriture SGIPRO */
      iCodRet = givEcritSgiProED("ED", "affedito", &buf_pos, *buf_pos_in, doc, givrListParu.trEltList[l].rub, givrListParu.trEltList[l].dep, givrListParu.trEltList[l].loc, &iDebut);
    }
  }

  if (buf_pos != *buf_pos_in)
  {
    strcpy(buf_pos, "</sgipro>");
    lg_ecr = strlen(buf_pos);
    *(buf_pos+lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + (lg_ecr+1) )= LINE_FEED;
    *(buf_pos + (lg_ecr+2) )= '\0';
    buf_pos = (buf_pos + lg_ecr +2);

    lg_write = giv_ecrit_fin_noeud(&buf_pos,"affedito");
    buf_pos = buf_pos + lg_write;
  }


  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
  }

  *buf_pos_in=buf_pos;


  GWTTrace (GWT_NIV_FONCT,
            ("Sortie Ecriture Contenu ED\n"));

  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritContenuEDEtab()                                              */
/*                                                                            */
/* But       : ecrit les contenus SGIPRO                                      */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, valeur_id_parution                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/* Modification	(Jui/20/2006 - mb) : création de plusieurs fichiers de sortie */
/*----------------------------------------------------------------------------*/

static int4 givEcritContenuEDEtab (char *obj, char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice)

{
  int4 lg_ecr = 0;
  int4 i = 0;
  int4 j = 0;
  int4 k = 0;
  int4 l = 0;
  int4 iDebut;
  int4 lg_write;
  char *buf_pos, *buf_pos_ref;
  int4 iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 iRet = GWCCodeOK;            /* Code retour de la fonction */
  char tcAn9Courant[GYBPaprofLgCodan9 + 1];
  char *pt_debut_element;
  char *pt_fin_element;
  char *pt_fin_liste;
  char tcType[3+1];
  char tcBalise[50+1];
  char tcBaliseFin[50+1];

  /* Pointeur sur debut du buffer */
  buf_pos = *buf_pos_in;

  /* Ecriture dans le fichier de sortie */
  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = (int4)giv_sortie_ISO ( &buf_pos, GIVfDescFicBloc );
  }
  strcpy(tcType,obj);
  strcat(tcType,"/");
  tcBalise[0] = '\0';
  pt_debut_element = strstr(givtcObjCont, tcType);
  pt_fin_liste = givtcObjCont + strlen(givtcObjCont);
  if (0 != pt_debut_element)
  {
    /* pas de balise associée */
    pt_debut_element += strlen(tcType);
    pt_fin_element = strchr(pt_debut_element,',');
    if (0 != pt_fin_element)
    {
      memcpy(tcBalise, (pt_debut_element), (pt_fin_element - pt_debut_element));
      tcBalise[(pt_fin_element - pt_debut_element)] = '\0';
    }
    else
    {
      memcpy(tcBalise, (pt_debut_element), (pt_fin_liste - pt_debut_element));
      tcBalise[(pt_fin_liste - pt_debut_element)] = '\0';
    }
  }
  if (0 == strlen(tcBalise))
  {
    GWTTrace (GWT_NIV_GRAVE,("Balise de contenu non configurée %s\n", obj));
    return(iCodRet);
  }
 GWTTrace (GWT_NIV_FONCT,("Ecriture Contenu %s,%s\n", obj, tcBalise));

 strcpy(tcType,obj);
 tcType[0] = toupper(tcType[0]);
 tcType[1] = toupper(tcType[1]);

 if ((0 == strcmp("ED",tcType))|| (0 == strcmp("EE",tcType)))
 {
  *buf_pos_in = buf_pos;
  strcpy(tcAn9Courant, givcR00000000);
  iDebut = 1;
  for(j=0; j<(givrListParu.iNbr); j++)
  {
    /* inscription à thème */
    l= givrListParu.trEltRangList[j];
    if (0 != strcmp(tcAn9Courant, givrListParu.trEltList[l].rub))
    {
      strcpy(tcAn9Courant, givrListParu.trEltList[l].rub);
      /* Appel a la fonction de lecture du theme de rubrique */
      iCodRet =  givLectureThemeED(givrListParu.trEltList[l].rub);
      if (0 != strlen(buf_concat))
      {
        for(i=0; i<j; i++)
        {
          k = givrListParu.trEltRangList[i];
          if (0 == strcmp(buf_concat,givrListParu.trEltList[k].thm))
          {
            break;
          }
        }
        if (i == j)
        {
          i=0;
              /* écriture SGIPRO */
              if (0 == strcmp(tcType, obj))
              {
        	      /* accès à un fichier */
                iCodRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, buf_concat, "", "", &iDebut);
              }
              else
              {
        	      /* accès à la base */
                iCodRet = givEcritDonEtab(tcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, buf_concat, "", "", &iDebut);
              }
        }
      }
      strcpy(givrListParu.trEltList[l].thm,buf_concat);
    }
    else
    {
      strcpy(givrListParu.trEltList[l].thm,"");
    }
  }

  if (0 == iDebut)
  {
    strcpy(buf_pos, "</sgipro>");
    lg_ecr = strlen(buf_pos);
    *(buf_pos+lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + (lg_ecr+1) )= LINE_FEED;
    *(buf_pos + (lg_ecr+2) )= '\0';
    buf_pos = (buf_pos + lg_ecr +2);
    lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBalise);
    buf_pos = buf_pos + lg_write;
  }
 }

 else if (0 == strcmp("BB",tcType))
 {
  *buf_pos_in=buf_pos;
  iDebut = 1;

  i=0;
      /* écriture SGIPRO */
      if (0 == strcmp(tcType, obj))
      {
        /* accès à un fichier */
        iCodRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, "", "", "", &iDebut);
      }
      else
      {
        /* accès à la base hors service */
        /* iCodRet = givEcritDonEtab(tcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, "", "", "", &iDebut); */
      }

  GWTTrace (GWT_NIV_FONCT,
              ("Eciture BB fichier SGIPRO ED : %d\n", iDebut));
  if (0 == iDebut)
  {
    strcpy(buf_pos, "</sgipro>");
    lg_ecr = strlen(buf_pos);
    *(buf_pos+lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + (lg_ecr+1) )= LINE_FEED;
    *(buf_pos + (lg_ecr+2) )= '\0';
    buf_pos = (buf_pos + lg_ecr +2);
    lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBalise);
    buf_pos = buf_pos + lg_write;
    if ('\0' != GIVBuffXML[0])
    {
      /* Ecriture dans le fichier de sortie sans changement de format */
      iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
    }
  }
 }

 else if (0 == strcmp("EG",tcType))
 {
  *buf_pos_in=buf_pos;
  iDebut = 1;

  i=0;
      if (-1 == (doc+i)->value.a_classer.iBLEPJProf)
      {
        strcpy(tcAn9Courant, givcR00000000);
        (doc+i)->value.a_classer.iBLEPJProf = 0;
        for(k=0; k<(givrListParu.iNbr); k++)
        {
          l= givrListParu.trEltRangList[k];
          if ((0 != strcmp(tcAn9Courant, givrListParu.trEltList[l].rub)) && (0 != strcmp(givrListParu.trEltList[l].rub, givcR00000000)))
          {
            strcpy(tcAn9Courant, givrListParu.trEltList[l].rub);
            /* liste d'opposition CRC de fichier GS */
            iCodRet = givLectureBListEPJProf((doc+i)->value.a_classer.etab, givrListParu.trEltList[l].rubinit);
            if ((int4)GIXCodeKO == iCodRet)
            {
              /* balises à inclure */
              (doc+i)->value.a_classer.iBLEPJProf = 0;
              break;
            }
            (doc+i)->value.a_classer.iBLEPJProf = 1;
          }
        }
      }
      /* écriture SGIPRO */
      if (0 == strcmp(tcType, obj))
      {
        /* accès à un fichier */
        iCodRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, "", "", "", &iDebut);
      }
      else
      {
        /* accès à la base */
        iCodRet = givEcritDonEtab(tcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, "", "", "", &iDebut);
      }

  if ((1 == iDebut) && (0 != strlen(doc->value.objets_pub.libUrlSite)))
  {
    i=0;
      iDebut = 0;
      lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_noeud_simple(buf_pos, "sgipro");
      buf_pos = buf_pos + lg_write;
      strcat(buf_pos, "<annonceur etablissement=\"\" id=\"");
      if ((0 == strlen((doc+i)->value.a_classer.etab)) && (i+1 == indice))
      {
        strcat(buf_pos, (doc+i)->value.numero_client);
      }
      else
      {
        strcat(buf_pos, (doc+i)->value.a_classer.etab);
      }
      strcat(buf_pos, "\">");
    lg_ecr = strlen(buf_pos);
    *(buf_pos+lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + (lg_ecr+1) )= LINE_FEED;
    *(buf_pos + (lg_ecr+2) )= '\0';
    buf_pos = (buf_pos + lg_ecr +2);
    lg_write = giv_ecrit_balise(buf_pos, "1", "prcplt");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_balise(buf_pos, "0", "prdura");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_noeud_simple(buf_pos, "infosCpltDonneesEnrichies");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_balise(buf_pos, (doc+i)->value.objets_pub.libUrlSite, "urlSite");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"infosCpltDonneesEnrichies");
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_fin_noeud(&buf_pos,"annonceur");
    buf_pos = buf_pos + lg_write;
  }

  if (0 == iDebut)
  {
    strcpy(buf_pos, "</sgipro>");
    lg_ecr = strlen(buf_pos);
    *(buf_pos+lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + (lg_ecr+1) )= LINE_FEED;
    *(buf_pos + (lg_ecr+2) )= '\0';
    buf_pos = (buf_pos + lg_ecr +2);
    lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBalise);
    buf_pos = buf_pos + lg_write;
    if ('\0' != GIVBuffXML[0])
    {
      /* Ecriture dans le fichier de sortie sans changement de format */
      iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
    }
  }
 }

 else if (0 == strcmp("EM",tcType))
 {

  *buf_pos_in=buf_pos;
  iDebut = 1;

  i=0;
      if (-1 == (doc+i)->value.a_classer.iBLEPJProf)
      {
        strcpy(tcAn9Courant, givcR00000000);
        (doc+i)->value.a_classer.iBLEPJProf = 0;
        for(k=0; k<givrListParu.iNbr; k++)
        {
          l= givrListParu.trEltRangList[k];
          if ((0 != strcmp(tcAn9Courant, givrListParu.trEltList[l].rub)) && (0 != strcmp(givrListParu.trEltList[l].rub, givcR00000000)))
          {
            strcpy(tcAn9Courant, givrListParu.trEltList[l].rub);
            /* liste d'opposition CRC de fichier GS */
            iCodRet = givLectureBListEPJProf((doc+i)->value.a_classer.etab, givrListParu.trEltList[l].rubinit);
            if ((int4)GIXCodeKO == iCodRet)
            {
              /* fichier à inclure */
              (doc+i)->value.a_classer.iBLEPJProf = 0;
              break;
            }
            (doc+i)->value.a_classer.iBLEPJProf = 1;
          }
        }
      }
      if (0 == (doc+i)->value.a_classer.iBLEPJProf)
      {
        /* écriture SGIPRO */
        if (0 == strcmp(tcType, obj))
        {
          /* accès à un fichier */
          iCodRet = (int4)GIXCodeKO;
          for(j=0; j<giviNbProfEtab; j++)
          {
      	    if ((0 == strcmp(givrListProfEtab[j].tcEtab,(doc+i)->value.a_classer.etab))
      		     && ('V' == givrListProfEtab[j].cIndic))
      	    {
  	          /* accès à un fichier DV avec an8 */
              iRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, givrListProfEtab[j].tcAn8, "", "", &iDebut);
              if ('\0' != GIVBuffXML[0])
              {
                /* Ecriture dans le fichier de sortie sans changement de format */
                iRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
                iCodRet = (int4)GIXCodeOK;
              }
            }
          }
          if ((int4)GIXCodeKO == iCodRet)
          {
          	/* accès à un fichier DE sans an8 */
            iRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, "", "", "", &iDebut);
          }
        }
        else
        {
          /* accès à la base */
          iCodRet = givEcritDonEtab(tcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, "", "", "", &iDebut);
        }
      }

  if (0 == iDebut)
  {
    strcpy(buf_pos, "</sgipro>");
    lg_ecr = strlen(buf_pos);
    *(buf_pos+lg_ecr) = SEPARE_LIGNE;
    *(buf_pos + (lg_ecr+1) )= LINE_FEED;
    *(buf_pos + (lg_ecr+2) )= '\0';
    buf_pos = (buf_pos + lg_ecr +2);
    lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBalise);
    buf_pos = buf_pos + lg_write;
    if ('\0' != GIVBuffXML[0])
    {
      /* Ecriture dans le fichier de sortie sans changement de format */
      iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
    }
  }
 }

 else if (0 == strcmp("DV",tcType))
 {
   /* DV ou Marques par an8 pour CVIV */
  *buf_pos_in=buf_pos;
  iDebut = 1;

      for(j=0; j<giviNbProfEtab; j++)
      {
      	if ('V' == givrListProfEtab[j].cIndic)
      	{
  	      /* accès à un fichier */
          iCodRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc, givrListProfEtab[j].tcAn8, "", "", &iDebut);
          if ('\0' != GIVBuffXML[0])
          {
            /* Ecriture dans le fichier de sortie sans changement de format */
            iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
         }
        }
      }
  if (0 == iDebut)
  {
    lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBalise);
    buf_pos = buf_pos + lg_write;
    if ('\0' != GIVBuffXML[0])
    {
      /* Ecriture dans le fichier de sortie sans changement de format */
      iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
    }
  }
 }

 else if (0 == strcmp("GS",tcType))
 {

  *buf_pos_in=buf_pos;
  iDebut = 1;

  i=0;
      /* liste d'opposition fichier GS complet */
      iCodRet = givOppositionURLGratuite((doc+i)->value.a_classer.etab, givcR000000);
      /* écriture SGIPRO */
      if ((int4)GIXCodeKO == iCodRet)
      {
        if (0 == strcmp(tcType, obj))
        {
          /* accès à un fichier */
          iCodRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, "", "", "", &iDebut);
        }
        else
        {
          /* accès à la base */
          iCodRet = givEcritDonEtab(tcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, "", "", "", &iDebut);
        }
      }

  if (0 == iDebut)
  {
    lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBalise);
    buf_pos = buf_pos + lg_write;
  }
 }
 else if (0 == strcmp("AD",tcType))
 {
    /* données additionnelles annotées */
    iCodRet = givEcritDonAdd(tcType, &buf_pos, doc, indice);
 }

  if ('\0' != GIVBuffXML[0])
  {
    /* Ecriture dans le fichier de sortie */
    iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
  }

  *buf_pos_in=buf_pos;



  GWTTrace (GWT_NIV_FONCT,
            ("Sortie Ecriture Contenu ED par établissement\n"));

  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritImages ()                                              */
/*                                                                            */
/* But       : ecrit le corps PHOTOS des PVI                                  */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 givEcritImages (char **buf_pos_in, GYBrDOCUMENT *doc, int4 iRef)
{
  int4 lg_write;
  char *buf_pos;
  int4         iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4         iIntRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_tmp;
  char    cNomFichier[128] = "";           /* Pathname des fichiers utilises */
  char cStr[4096 + 1] = "";
  char *pcDebut, *pcFin;
  int4 i;
  struct timeval  sTemps1;
  struct timeval  sTemps2;
  long double  iDureeAppelMilliSec;

  /* Initialisation des variables locales */
  (void)memset ((void *)cNomFichier, 0x00, (size_t)sizeof(cNomFichier));

  /* ouverture du fichier des mouvements CD2G */
  /* constitution du nom du fichier */
  if (0 == strlen(doc->value.numero_client))
  {
    (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s_%s.xml", givtcRepSgiPro, "IP", doc->value.objets_pub.micro[iRef].id[4],doc->value.objets_pub.micro[iRef].id[5],doc->value.objets_pub.micro[iRef].id[6],doc->value.objets_pub.micro[iRef].id[7],doc->value.objets_pub.micro[iRef].id[8], doc->value.objets_pub.micro[iRef].stype, doc->value.objets_pub.micro[iRef].id);
  }
  else
  {
    (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s_%s.xml", givtcRepSgiPro, "IP", doc->value.numero_client[0],doc->value.numero_client[1],doc->value.numero_client[2],doc->value.numero_client[3],doc->value.numero_client[4], "IP", doc->value.objets_pub.micro[iRef].id);
  }

  GWTTrace(GWT_NIV_FONCT,
           ("Nom fichier PHOTOS <%s>\n", cNomFichier));
  /* temps d'accès SGIPro */
  /* gettimeofday(&sTemps1, NULL); */

  /* Ouverture fichier SGIPRO */
  GIVfDescFicPhotos = fopen (cNomFichier,
                             "r");

  if (NULL == GIVfDescFicPhotos)
  {
    /* Echec ouverture fichier mouvements => erreur */
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur FOPEN fichier Photos : [ERR=%02Xh, PTH=%s]\n", errno, cNomFichier));
    iCodRet = (int4)GIXCodeKO;
    return(iCodRet);
  }

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;
  pcDebut = 0;
  pcFin = 0;

  do
  {
    /* lecture de la ligne suivante */
    (void)fgets (cStr, sizeof(cStr), GIVfDescFicPhotos);
    /* suppression des espaces en début de ligne */
    for (i=0; ((isblank((unsigned char)cStr[i])) && (i<strlen(cStr))); i++);
    /* ligne de liste associée à SGIPRO */
    if ((0 != pcDebut) && (0 == pcFin))
    {
      pcFin = strstr (&cStr[i], "</photos>");
      if (0 == pcFin)
      {
        if (sizeof(GIVBuffXML) < (strlen(GIVBuffXML) + strlen(cStr)) )
        {
          /* Ecriture dans le fichier de sortie */
          iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
        }
      }
      /* écriture de ligne courante entre début et fin */
      strcpy(buf_pos, &cStr[i]);
      buf_pos = buf_pos + strlen(buf_pos);
    }
    if (0 == pcDebut)
    {
      pcDebut = strstr (&cStr[i], "<photos>");
      if (0 != pcDebut)
      {
        strcpy(buf_pos, &cStr[i]);
        buf_pos = buf_pos + strlen(buf_pos);
        pcFin = 0;
      }
    }
    if ((0 != pcDebut) && (0 == pcFin))
    {
      pcFin = strstr (&cStr[i], "</photos>");
      if (0 != pcFin)
      {
        strcpy(buf_pos, &cStr[i]);
        buf_pos = buf_pos + strlen(buf_pos);
        pcDebut = 0;
      }
    }
  } while (0 == feof (GIVfDescFicPhotos));

  /* Fermeture fichier SGIPRO */
  iIntRet = fclose (GIVfDescFicPhotos);
#if 0
  /* temps d'accès SGIPro */
  gettimeofday(&sTemps2, NULL);
  iDureeAppelMilliSec = (double)((double)((sTemps2.tv_sec  - sTemps1.tv_sec) *1000000) +
		       (double)(sTemps2.tv_usec - sTemps1.tv_usec));
  GIViCumulDureeIncl += iDureeAppelMilliSec;
  GIViCumulNbreIncl ++;
  GWTTrace(GWT_NIV_FONCT,
           ("Durée inclusion %s : %0.Lf microsecondes, Cumul : %0.Lf, %0.Lf microsecondes\n",givtcRepSgiPro,
				iDureeAppelMilliSec, GIViCumulNbreIncl, GIViCumulDureeIncl));
  GWTTrace (GWT_NIV_FONCT, ("Debut %d, %d\n", sTemps1.tv_sec, sTemps1.tv_usec));
  GWTTrace (GWT_NIV_FONCT, ("Fin %d, %d\n", sTemps2.tv_sec, sTemps2.tv_usec));
#endif
  iCodRet = GWCCodeOK;
  *buf_pos_in=buf_pos;

  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritSgiPro ()                                              */
/*                                                                            */
/* But       : ecrit le corps SGIPRO des contenus                             */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 givEcritSgiPro (char **buf_pos_in, GYBrDOCUMENT *doc, int4 iDoc, int4 iRef, int4 indice, char* pcBalise, int4 iBalise)
{
  int4 lg_write;
  char *buf_pos;
  int4         iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4         iIntRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_tmp;
  char    cNomFichier[128] = "";           /* Pathname des fichiers utilises */
  char cStr[4096 + 1] = "";
  char tcBalise[50+1];
  char tcBaliseFin[50+1];
  char *pcDebut, *pcFin;
  int4 i,k,iNbCRC;

  /* Initialisation des variables locales */
  (void)memset ((void *)cNomFichier, 0x00, (size_t)sizeof(cNomFichier));

  /* constitution du nom du fichier */
  if (0 != (doc+iDoc)->value.objets_pub.micro[iRef].iCVI)
  {
  	/* CVI vintage ou nouvel objet */
  	if (0 == strlen((doc+iDoc)->value.numero_client))
  	{
      (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s_%s.xml", givtcRepSgiPro, (doc+iDoc)->value.objets_pub.micro[iRef].stypcvi, (doc+iDoc)->value.objets_pub.micro[iRef].id[4],(doc+iDoc)->value.objets_pub.micro[iRef].id[5],(doc+iDoc)->value.objets_pub.micro[iRef].id[6],(doc+iDoc)->value.objets_pub.micro[iRef].id[7],(doc+iDoc)->value.objets_pub.micro[iRef].id[8], (doc+iDoc)->value.objets_pub.micro[iRef].stypcvi, (doc+iDoc)->value.objets_pub.micro[iRef].id);
  	}
  	else
  	{
      (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s_%s.xml", givtcRepSgiPro, (doc+iDoc)->value.objets_pub.micro[iRef].stypcvi, (doc+iDoc)->value.numero_client[0],(doc+iDoc)->value.numero_client[1],(doc+iDoc)->value.numero_client[2],(doc+iDoc)->value.numero_client[3],(doc+iDoc)->value.numero_client[4], (doc+iDoc)->value.objets_pub.micro[iRef].stypcvi, (doc+iDoc)->value.objets_pub.micro[iRef].id);
  	}
  }
  else if (0 == strlen((doc+iDoc)->value.numero_client))
  {
    if (' ' == (doc+iDoc)->value.objets_pub.micro[iRef].stype[0])
    {
      (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s_%s.xml", givtcRepSgiPro, &(doc+iDoc)->value.objets_pub.micro[iRef].stype[1], (doc+iDoc)->value.objets_pub.micro[iRef].id[4],(doc+iDoc)->value.objets_pub.micro[iRef].id[5],(doc+iDoc)->value.objets_pub.micro[iRef].id[6],(doc+iDoc)->value.objets_pub.micro[iRef].id[7],(doc+iDoc)->value.objets_pub.micro[iRef].id[8], &(doc+iDoc)->value.objets_pub.micro[iRef].stype[1], (doc+iDoc)->value.objets_pub.micro[iRef].id);
    }
    else
    {
      (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s_%s.xml", givtcRepSgiPro, (doc+iDoc)->value.objets_pub.micro[iRef].stype, (doc+iDoc)->value.objets_pub.micro[iRef].id[4],(doc+iDoc)->value.objets_pub.micro[iRef].id[5],(doc+iDoc)->value.objets_pub.micro[iRef].id[6],(doc+iDoc)->value.objets_pub.micro[iRef].id[7],(doc+iDoc)->value.objets_pub.micro[iRef].id[8], (doc+iDoc)->value.objets_pub.micro[iRef].stype, (doc+iDoc)->value.objets_pub.micro[iRef].id);
    }
  }
  else
  {
    if (' ' == (doc+iDoc)->value.objets_pub.micro[iRef].stype[0])
    {
      (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s_%s.xml", givtcRepSgiPro, &(doc+iDoc)->value.objets_pub.micro[iRef].stype[1], (doc+iDoc)->value.numero_client[0],(doc+iDoc)->value.numero_client[1],(doc+iDoc)->value.numero_client[2],(doc+iDoc)->value.numero_client[3],(doc+iDoc)->value.numero_client[4], &(doc+iDoc)->value.objets_pub.micro[iRef].stype[1], (doc+iDoc)->value.objets_pub.micro[iRef].id);
    }
    else
    {
      (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s_%s.xml", givtcRepSgiPro, (doc+iDoc)->value.objets_pub.micro[iRef].stype, (doc+iDoc)->value.numero_client[0],(doc+iDoc)->value.numero_client[1],(doc+iDoc)->value.numero_client[2],(doc+iDoc)->value.numero_client[3],(doc+iDoc)->value.numero_client[4], (doc+iDoc)->value.objets_pub.micro[iRef].stype, (doc+iDoc)->value.objets_pub.micro[iRef].id);
    }
  }


  GWTTrace(GWT_NIV_FONCT,
           ("Nom fichier SGIPRO <%s>\n", cNomFichier));

  /* Ouverture fichier SGIPRO */
  GIVfDescFicSGIPRO = fopen (cNomFichier,
                             "r");

  if (NULL == GIVfDescFicSGIPRO)
  {
    /* Echec ouverture fichier mouvements => erreur */
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur FOPEN fichier SGIPRO : [ERR=%02Xh, PTH=%s]\n", errno, cNomFichier));
    iCodRet = (int4)GIXCodeKO;
    return(iCodRet);
  }

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;
  pcDebut = 0;
  pcFin = 0;

  do
  {
    /* lecture de la ligne suivante */
    (void)fgets (cStr, sizeof(cStr), GIVfDescFicSGIPRO);
    /* ligne de liste associée à SGIPRO */
    if ((0 != pcDebut) && (0 == pcFin))
    {
      pcFin = strstr (cStr, "</sgipro>");
      if (0 == pcFin)
      {
        if (sizeof(GIVBuffXML) < (strlen(GIVBuffXML) + strlen(cStr)) )
        {
          /* Ecriture dans le fichier de sortie */
          iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
        }
        /* écriture de ligne courante entre début et fin */
        iNbCRC = giviNbCRC;
        iCodRet = givAnalyseCRC((doc+iDoc)->value.objets_pub.micro[iRef].stype, iRef, (doc+iDoc), cStr, tcBalise, tcBaliseFin);
        if ((0 == strcmp("SC",(doc+iDoc)->value.objets_pub.micro[iRef].stype))
          && (0 != strcmp("SR",(doc+iDoc)->value.objets_pub.micro[iRef].sstype))
        	 && (0 != strstr (cStr, "</pvi>")))
        {
          /* pour PVI inclusion du fichier "IP" */
          iIntRet = givEcritImages(&buf_pos, (doc+iDoc), iRef);
        }
        lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);
        buf_pos = buf_pos + lg_write;
        strcpy(buf_pos, cStr);
        buf_pos = buf_pos + strlen(buf_pos);
        lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBaliseFin);
      }
      buf_pos = buf_pos + strlen(buf_pos);
    }
    if (0 == pcDebut)
    {
      pcDebut = strstr (cStr, "<sgipro>");
      if (0 != pcDebut)
      {
        buf_pos = buf_pos + strlen(buf_pos);
        pcFin = 0;

        if (buf_pos == *buf_pos_in)
        {
          if (((int4)GIXCodeKO == iBalise) || ((int4)GIXCodeRIEN ==  iBalise))
          {
            lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);
            buf_pos = buf_pos + lg_write;
          }
          iIntRet = giv_ecrit_objet_pub (&buf_pos, (doc+iDoc), 0, iRef, "objetcontenu");
        }
      }
    }
    if ((0 != pcDebut) && (0 == pcFin))
    {
      pcFin = strstr (cStr, "</sgipro>");
      if (0 != pcFin)
      {
        pcDebut = 0;
      }
    }
  } while (0 == feof (GIVfDescFicSGIPRO));

  /* Fermeture fichier SGIPRO */
  iIntRet = fclose (GIVfDescFicSGIPRO);

  iCodRet = GWCCodeKO;
  if (buf_pos != *buf_pos_in)
  {
    iCodRet = GWCCodeOK;
  }

  *buf_pos_in=buf_pos;

  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritSgiProPart ()                                              */
/*                                                                            */
/* But       : ecrit le corps SGIPRO des contenus des partenaires             */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 givEcritSgiProPart (char **buf_pos_in, GYBrDOCUMENT *doc, char* pcEtab, char* pcRef, char* pcType, char* pcBalise, int4 *piDeb)
{
  int4 lg_write;
  char *buf_pos;
  int4         iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4         iIntRet = GWCCodeOK;            /* Code retour de la fonction */
  char    cNomFichier[128] = "";           /* Pathname des fichiers utilises */
  char cStr[4096 + 1] = "";
  char cStr1[4098 + 1] = "";
  char cNomBalise[100];
  char cNomBalises[100];
  char tcBalise[50+1];
  char tcBaliseFin[50+1];
  int4 iDebut;
  int4 j,jRef;
  char tcType[3];

  /* Initialisation des variables locales */
  (void)memset ((void *)cNomFichier, 0x00, (size_t)sizeof(cNomFichier));
  /* mutalisation */
  strcpy(tcType,pcType);
  strcpy(cNomBalises,pcBalise);
  sprintf(cNomBalise, "elempart_%s", &pcRef[strlen(pcRef)-4]);
  /* ouverture du fichier des mouvements CD2G */
  /* constitution du nom du fichier */
  (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s.xml", givtcRepSgiPro, tcType, pcRef[0], pcRef[1], pcRef[2], pcRef[3], pcRef[4], pcRef);

  GWTTrace(GWT_NIV_FONCT,
           ("Nom fichier SGIPRO <%s>\n", cNomFichier));

  /* Ouverture fichier SGIPRO */
  GIVfDescFicSGIPRO = fopen (cNomFichier,
                             "r");

  if (NULL == GIVfDescFicSGIPRO)
  {
    /* Echec ouverture fichier mouvements => erreur */
    GWTTrace (GWT_NIV_FONCT,
              ("Fichier SGIPRO Partenaire absent: [ERR=%02Xh, PTH=%s]\n", errno, cNomFichier));
    iCodRet = (int4)GIXCodeKO;
    return(iCodRet);
  }

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;
  iDebut = (int4)-1;

  do
  {
    /* lecture de la ligne suivante */
    (void)fgets (cStr, sizeof(cStr), GIVfDescFicSGIPRO);
    GWTTrace(GWT_NIV_FONCT,
             ("Fichier Part <%s>\n", cStr));
    /* ligne de liste associée à SGIPRO */
    if ((1 == iDebut) && (0 != strcmp(cStr1, cStr)))
    {
       if (sizeof(GIVBuffXML) < (strlen(GIVBuffXML) + strlen(cStr)) )
      {
        /* Ecriture dans le fichier de sortie */
        iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
      }
      iCodRet = givAnalyseCRC(tcType, -1, doc, cStr, tcBalise, tcBaliseFin);
      lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);
      buf_pos = buf_pos + lg_write;
      strcpy(buf_pos, cStr);
      buf_pos = buf_pos + strlen(buf_pos);
      lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBaliseFin);
      buf_pos = buf_pos + lg_write;
    }

    else if ((0 == iDebut) && (cStr[0] == '<'))
    {
      iDebut = 1;
      (void)strcpy(&cStr1[2],&cStr[1]);
      cStr1[0] = '<';
      cStr1[1] = '/';
      lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);
      buf_pos = buf_pos + lg_write;
      for(j=0; j< doc->value.a_classer.iNbPart ; j++)
      {
    	  if (0 == strcmp(pcRef, doc->value.a_classer.trpart[j].rpart))
    	  {
    	    jRef = j;
    	  }
      }
      lg_write = giv_ecrit_element_partenaire (cNomBalise, buf_pos, pcRef, pcEtab, doc->value.a_classer.trpart[jRef].parent);
      buf_pos = buf_pos + lg_write;
    }
    else if (((int4)-1 == iDebut) && (0 == memcmp("]>", cStr,2 )))
    {
      iDebut = 0;
    }
  } while (0 == feof (GIVfDescFicSGIPRO));

  /* Fermeture fichier SGIPRO */
  iIntRet = fclose (GIVfDescFicSGIPRO);

  if (buf_pos != *buf_pos_in)
  {
    lg_write = giv_ecrit_fin_noeud(&buf_pos,cNomBalise);
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_fin_noeud(&buf_pos,pcBalise);
    buf_pos = buf_pos + lg_write;
  }


  *buf_pos_in=buf_pos;
  iCodRet = GWCCodeOK;
  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritSgiProPartEtab ()                                      */
/*                                                                            */
/* But       : ecrit le corps SGIPRO des contenus des partenaires             */
/*             par établissement                                              */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 givEcritSgiProPartEtab (char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice, char* pcEtab, char* pcRef, char* pcType, char* pcBalise, int4 *piDeb)
{
  int4 lg_write,lg_ecr = 0;
  char *buf_pos;
  int4  iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4  iCrcRet = GWCCodeOK;            /* Code retour de la fonction */
  int4  iRet = GWCCodeOK;            /* Code retour de la fonction */
  char cNomBalise[100];
  char cNomBalises[100];
  char tcType[3];
  char *pt_debut_element,*pt_debut_liste;
  char *pt_fin_element,*pt_fin_liste;
  GYBrIapartT   rIapart;
  int4 i,j,iRef,jRef;
  int4 iRgParent, iNbParent;

  /* Initialisation des variables locales */
  strcpy(tcType,pcType);
  strcpy(cNomBalises,pcBalise);
  strcat(cNomBalises,"s");
  sprintf(cNomBalise, "elempart_%s", &pcRef[strlen(pcRef)-4]);
  /* référence de partenaire */
  (void)strcpy (rIapart.acOriPart,&pcRef[strlen(pcRef)-4]);
  memcpy (rIapart.acRefPart, pcRef, strlen(pcRef)-4);
  rIapart.acRefPart[strlen(pcRef)-4] = '\0';
  rIapart.acParentRefPart[0] = '\0';
  rIapart.acTypeRefPart[0] = '\0';
  iRef = 0;
  jRef = 0;
  for(i=0; i< indice; i++)
  {
    for(j=0; j< (doc+i)->value.a_classer.iNbPart ; j++)
    {
      if (0 == strcmp(pcRef, (doc+i)->value.a_classer.trpart[j].rpart))
      {
        strcpy (rIapart.acParentRefPart,(doc+i)->value.a_classer.trpart[j].parent);
        strcpy (rIapart.acTypeRefPart,(doc+i)->value.a_classer.trpart[j].typepart);
        iRgParent = (doc+i)->value.a_classer.trpart[j].iRgParent;
        iNbParent = (doc+i)->value.a_classer.trpart[j].iNbParent;
        iRef = i;
        jRef = j;
      }
    }
  }

  buf_pos = *buf_pos_in;
  /* lecture donnée "complément" */
  iRet = givLecturePartEtab(&rIapart,GIXCodeOK);
  if ((0 != strlen(GIVBuffInter)) && (NULL == strstr(GIVBuffInter,"<complement/>")))
  {
    if (1 == *piDeb)
    {
      *piDeb = 0;
    }
    lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);
    buf_pos = buf_pos + lg_write;
    lg_write = giv_ecrit_element_partenaire (cNomBalise, buf_pos, pcRef, pcEtab, rIapart.acParentRefPart);
    buf_pos = buf_pos + lg_write;
    /* analyse CRC <normale> */
    pt_fin_liste = GIVBuffInter;
    pt_debut_liste = strstr(pt_fin_liste,"<complement>");
    pt_debut_liste += strlen("<complement>");
    pt_debut_liste ++;
    pt_fin_liste = strstr(pt_debut_liste,"</complement>");
    *pt_fin_liste = '\0';
    iCodRet = givAnalyseObjetXML(pcType, doc, pt_debut_liste, &buf_pos);
    lg_ecr = strlen(GIVBuffXML);
    /* Ecriture dans le fichier de sortie */
    iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
    if (0 == strcmp(giv_PJDC,rIapart.acOriPart))
    {
    	/* analyse parent pour c et pr */
      if (giv_cPJDC == rIapart.acTypeRefPart[0])
      {
  GWTTrace(GWT_NIV_FONCT,
             ("Cle annexe <%s> \n", (doc+iRef)->value.a_classer.trpart[jRef].clenav));
        lg_write = giv_ecrit_noeud_attr(buf_pos,"equipe",(doc+iRef)->value.a_classer.trpart[jRef].clenav);
        buf_pos = buf_pos + lg_write;
      }
      if ((giv_prPJDC == rIapart.acTypeRefPart[0]) || (giv_cPJDC == rIapart.acTypeRefPart[0]))
      {
        for(i=iRgParent; i< (iRgParent + iNbParent); i++)
        {
          if ((giv_cPJDC == givtrPart[i].acTypeRefPart[0]) || (giv_prPJDC == givtrPart[i].acTypeRefPart[0]))
          {
            lg_write = GIV_ecrit_element_parent (&buf_pos, &givtrPart[i]);
            buf_pos = buf_pos + lg_write;
          }
        }
      }
      if (giv_cPJDC == rIapart.acTypeRefPart[0])
      {
        lg_write = giv_ecrit_fin_noeud(&buf_pos,"equipe");
        buf_pos = buf_pos + lg_write;
      }
    	/* analyse parent pour o, sv, c et pr */
    	iCodRet = (int4)giv_ecrit_navigation (&buf_pos, iRgParent, iNbParent,
    	                             doc->value.a_classer.trpart[giviRefPJDC].typepart[0], &rIapart,
    	                             (doc+iRef)->value.a_classer.trpart[jRef].clenav);
    }
    /* Ecriture dans le fichier de sortie */
    iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
  }
  /* lecture donnée "photos" */
  if ((int4)GWCCodeOK == iRet)
  {
    iRet = givLecturePartEtab(&rIapart,GIXCodeKO);
    if ((0 != strlen(GIVBuffInter)) && (NULL == strstr(GIVBuffInter,"<photos/>")))
    {
      if (1 == *piDeb)
      {
        *piDeb = 0;
      }
      if (0 == lg_ecr)
      {
        lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);
        buf_pos = buf_pos + lg_write;
        lg_write = giv_ecrit_element_partenaire (cNomBalise, buf_pos, pcRef, pcEtab, rIapart.acParentRefPart);
        buf_pos = buf_pos + lg_write;
      }
      lg_ecr = strlen(GIVBuffInter);
      strcpy(buf_pos, GIVBuffInter);
      buf_pos = (buf_pos + lg_ecr);
    }

    if (0 != lg_ecr)
    {
      lg_write = giv_ecrit_fin_noeud(&buf_pos,cNomBalise);
      buf_pos = buf_pos + lg_write;
      lg_write = giv_ecrit_fin_noeud(&buf_pos,pcBalise);
      buf_pos = buf_pos + lg_write;
      /* Ecriture dans le fichier de sortie */
      iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
    }
  }

  *buf_pos_in=buf_pos;
  iCodRet = GWCCodeOK;

  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritSgiProBOC ()                                              */
/*                                                                            */
/* But       : ecrit le corps SGIPRO des contenus BOC Contributifs            */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 givEcritSgiProBOC (char **buf_pos_in, GYBrDOCUMENT *doc, int4 indice, char* pcRef, char* pcType, char* pcBalise)
{
  int4 lg_write;
  char *buf_pos;
  char *deb_pos;
  int4         iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4         iIntRet = GWCCodeOK;            /* Code retour de la fonction */
  char    cNomFichier[128] = "";           /* Pathname des fichiers utilises */
  char cStr[4096 + 1] = "";
  char cStr1[4098 + 1] = "";
  char tcBalise[50+1];
  char tcBaliseFin[50+1];
  int4 iDebut, i, j;
  char *pt_debut_element;
  char *pt_fin_element;
  char   tcRub[GYBPaprofLgCodan9 + 1];
  /* Initialisation des variables locales */
  (void)memset ((void *)cNomFichier, 0x00, (size_t)sizeof(cNomFichier));


  /* ouverture du fichier des mouvements CD2G */
  /* constitution du nom du fichier */
  (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s.xml", givtcRepSgiPro, pcType, pcRef[0], pcRef[1], pcRef[2], pcRef[3], pcRef[4], pcRef);

  GWTTrace(GWT_NIV_FONCT,
           ("Nom fichier SGIPRO BOC <%s>\n", cNomFichier));

  /* Ouverture fichier SGIPRO */
  GIVfDescFicSGIPRO = fopen (cNomFichier,
                             "r");

  if (NULL == GIVfDescFicSGIPRO)
  {
    /* Echec ouverture fichier mouvements => erreur */
    GWTTrace (GWT_NIV_FONCT,
              ("Fichier SGIPRO BOC absent: [ERR=%02Xh, PTH=%s]\n", errno, cNomFichier));
    iCodRet = (int4)GIXCodeKO;
  	/* contenu absent pour l'epj */
    return(iCodRet);
  }

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;
  deb_pos = buf_pos;
  iDebut = (int4)-2;

  /* lecture de la ligne */
  (void)fgets (cStr, sizeof(cStr), GIVfDescFicSGIPRO);

  while (0 == feof (GIVfDescFicSGIPRO))
  {
    GWTTrace(GWT_NIV_FONCT,
             ("Fichier BOC %d,<%s>\n", iDebut,cStr));
    /* ligne de liste associée à SGIPRO */
    if ((2 == iDebut) && (NULL == strstr(cStr, cStr1)))
    {
      if (NULL != strstr(cStr,"rubrique"))
      {
         pt_debut_element = strchr(&cStr[1],'>');
         pt_fin_element = strchr(&cStr[1],'<');
         if ( NULL == pt_fin_element || NULL == pt_debut_element )
         {
            /* pas de rubrique commune */
            iDebut = 1;
            buf_pos = deb_pos;
            (void)strcpy(&cStr1[1],"fragment");
            cStr1[0] = '<';
            continue;
         }
         pt_debut_element++;
         if ( GYBPaprofLgCodan9 != (pt_fin_element - pt_debut_element) )
         {
            iDebut = 1;
            buf_pos = deb_pos;
            (void)strcpy(&cStr1[1],"fragment");
            cStr1[0] = '<';
            continue;
         }
         memcpy(tcRub, pt_debut_element, (pt_fin_element - pt_debut_element));
         tcRub[(pt_fin_element - pt_debut_element)] = '\0';
           GWTTrace(GWT_NIV_FONCT,
           ("Rub BOC <%s>\n", tcRub));
         for(i=0; i<(givrListParu.iNbrTot); i++)
         {
            j= givrListParu.trEltRangList[i];
            if (0 == strcmp(givrListParu.trEltList[j].rub, tcRub))
            {
               break;
            }
         }
         if (i == givrListParu.iNbrTot)
         {
            /* pas de rubrique commune */
            iDebut = 1;
            buf_pos = deb_pos;
            (void)strcpy(&cStr1[1],"fragment");
            cStr1[0] = '<';
            continue;
         }
      }
      iCodRet = givAnalyseCRC(pcType, -1, doc, cStr, tcBalise, tcBaliseFin);
      lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);
      buf_pos = buf_pos + lg_write;
      strcpy(buf_pos, cStr);
      buf_pos = buf_pos + strlen(buf_pos);
      lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBaliseFin);
      buf_pos = buf_pos + lg_write;
    }
    else if ((2 == iDebut) && (NULL != strstr(cStr, cStr1)))
    {
      iDebut = 1;
      (void)strcpy(&cStr1[1],"fragment");
      cStr1[0] = '<';
      strcpy(buf_pos, cStr);
      buf_pos = buf_pos + strlen(cStr);

      /* Ecriture dans le fichier de sortie */
      iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
      deb_pos = buf_pos;
    }
    else if ((1 == iDebut) && (NULL != strstr(cStr, cStr1)))
    {
      iDebut = 2;
      (void)strcpy(&cStr1[2],"fragment");
      cStr1[0] = '<';
      cStr1[1] = '/';
      strcpy(buf_pos, cStr);
      buf_pos = buf_pos + strlen(cStr);
    }
    else if (0 == iDebut)
    {
      iCodRet = givAnalyseCRC(pcType, -1, doc, cStr, tcBalise, tcBaliseFin);
      lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);
      buf_pos = buf_pos + lg_write;
      strcpy(buf_pos, cStr);
      buf_pos = buf_pos + strlen(buf_pos);
      lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBaliseFin);
      buf_pos = buf_pos + lg_write;
      if ((NULL == strstr(cStr, cStr1)) && (NULL == strstr(cStr,"annonceur")))
      {
         deb_pos = buf_pos - strlen(cStr);
      }
      else if (NULL != strstr(cStr,"annonceur"))
      {
         deb_pos = buf_pos;
      }
      else
      {
         iDebut = 2;
         (void)strcpy(&cStr1[2],"fragment");
         cStr1[0] = '<';
         cStr1[1] = '/';
      }
    }
    else if ((-1 == iDebut) && (cStr[0] == '<'))
    {
      iDebut = 0;
      (void)strcpy(&cStr1[1],"fragment");
      cStr1[0] = '<';
      lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);
      buf_pos = buf_pos + lg_write;
      deb_pos = buf_pos;
    }
    else if (((int4)-2 == iDebut) && (0 == memcmp("]>", cStr,2 )))
    {
      iDebut = -1;
    }
    /* lecture de la ligne suivante */
    (void)fgets (cStr, sizeof(cStr), GIVfDescFicSGIPRO);
  }

  /* Fermeture fichier SGIPRO */
  iIntRet = fclose (GIVfDescFicSGIPRO);

  if ((-1 != iDebut) && (-2 != iDebut))
  {
    if (0 == iDebut)
    {
      buf_pos = deb_pos;
  	  /* contenu absent pour l'epj */
    }
    lg_write = giv_ecrit_fin_noeud(&buf_pos,pcBalise);
    buf_pos = buf_pos + lg_write;
  }


  *buf_pos_in=buf_pos;
  iCodRet = GWCCodeOK;
  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : givEcritSgiProED ()                                              */
/*                                                                            */
/* But       : ecrit le corps SGIPRO des contenus                             */
/*                                                                            */
/*                                                                            */
/* Entree(s) : un buffer, Structure Document                                  */
/*                                                                            */
/* Sortie(s) : OK ou KO                                                       */
/*                                                                            */
/* Portable  : Transparent                                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/
static int4 givEcritSgiProED (char *acobj, char* pcBalise, char **buf_pos_in, char *buf_pos_ref, GYBrDOCUMENT *doc, char * tcRub, char * tcDep, char *tcSource, int4 *piDeb)
{
  int4 lg_write,lg_ecr = 0;
  char *buf_pos;
  int4         iCodRet = GWCCodeOK;            /* Code retour de la fonction */
  int4         iIntRet = GWCCodeOK;            /* Code retour de la fonction */
  int4 lg_tmp;
  int4 iBLEPJProf = 0;
  char    cNomFichier[128] = "";
  char obj[3+1] = "";
  char tcBalise[50+1];
  char tcBaliseFin[50+1];
           /* Pathname des fichiers utilises */
  char cStr[4096 + 1] = "";
  char cStrRef[100 + 1] = "";
  char cStrFinRef[100 + 1] = "";
  char cStrSupp[100 + 1] = "";
  char cStrFinSupp[100 + 1] = "";
  char *pcDebut, *pcFin;

  /* Initialisation des variables locales */
  (void)memset ((void *)cNomFichier, 0x00, (size_t)sizeof(cNomFichier));
  /* type d'objet */
  strcpy(obj,acobj);

  /* ouverture du fichier des mouvements CD2G */
  /* constitution du nom du fichier */
  if ((0 == strcmp(givtcRapED, "ETAB")) && (0 != strcmp("EG",obj)) && (0 != strcmp("EM",obj)) && (0 != strcmp("DV",obj)) && (0 != strcmp("MV",obj)) && (0 != strcmp("GS",obj)) && (0 != strcmp("BB",obj)) && (0 != strcmp("AD",obj)))
  {
    if (0 == strlen(doc->value.a_classer.etab))
    {
      GWTTrace(GWT_NIV_FONCT,
               ("Pas Nom fichier SGIPRO %s\n", obj));
      return(iCodRet);
    }
    (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s_%s_%s.xml", givtcRepSgiPro, obj, doc->value.a_classer.etab[0], doc->value.a_classer.etab[1], doc->value.a_classer.etab[2], doc->value.a_classer.etab[3], doc->value.a_classer.etab[4],obj, doc->value.a_classer.etab, tcRub);
  }
  else if ((0 == strcmp(givtcRapED, "ETAB")) && (0 == strcmp("EG",obj) || 0 == strcmp("EM",obj) || 0 == strcmp("DV",obj) || 0 == strcmp("MV",obj) || 0 == strcmp("GS",obj) || 0 == strcmp("BB",obj)))
  {
    if (0 == strlen(doc->value.a_classer.etab))
    {
      GWTTrace(GWT_NIV_FONCT,
               ("Pas Nom fichier SGIPRO %s\n", obj));
      return(iCodRet);
    }
    if ((0 != strlen(tcRub)) && (((0 == strcmp("DV",obj))) || (0 == strcmp("EM",obj))))
    {
     (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s_%s_%s.xml", givtcRepSgiPro, obj, doc->value.a_classer.etab[0], doc->value.a_classer.etab[1], doc->value.a_classer.etab[2], doc->value.a_classer.etab[3], doc->value.a_classer.etab[4],obj, doc->value.a_classer.etab, tcRub);
    }
    else
    {
     (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s_%s.xml", givtcRepSgiPro, obj, doc->value.a_classer.etab[0], doc->value.a_classer.etab[1], doc->value.a_classer.etab[2], doc->value.a_classer.etab[3], doc->value.a_classer.etab[4],obj, doc->value.a_classer.etab);
    }
  }
  else if ((0 == strcmp(givtcRapED, "ETAB")) && (0 == strcmp("AD",obj)))
  {
    if (0 == strlen(doc->value.a_classer.etab))
    {
      GWTTrace(GWT_NIV_FONCT,
               ("Pas Nom fichier SGIPRO %s\n", obj));
      iCodRet = (int4)GIXCodeKO;
      return(iCodRet);
    }
    (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c%c%c/%s_%s_%s.xml", givtcRepSgiPro, obj, doc->value.a_classer.etab[0], doc->value.a_classer.etab[1], doc->value.a_classer.etab[2], doc->value.a_classer.etab[3], doc->value.a_classer.etab[4],obj, doc->value.a_classer.etab, tcSource);
  }
  else if (0 == strcmp(givtcRapED, "OUI"))
  {
    (void) sprintf(&cNomFichier[0], "%s/%s/%c%c/%c/%s_%s_%s_%s_%s.xml", givtcRepSgiPro, obj, tcDep[0], tcDep[1], tcDep[2], obj, tcDep, tcSource, doc->value.inscription[0].val_num,tcRub);
  }
  /* balise de référence à rechercher */
    strcpy(cStrRef,"<sgipro>");
    strcpy(cStrFinRef,"</sgipro>");
    strcpy(cStrSupp,"<lstMarques>");
    strcpy(cStrFinSupp,"</lstMarques>");

  GWTTrace(GWT_NIV_FONCT,
           ("Nom fichier SGIPRO %s <%s>\n", obj, cNomFichier));

  /* Ouverture fichier SGIPRO */
  GIVfDescFicSGIPRO = fopen (cNomFichier,
                             "r");

  if (NULL == GIVfDescFicSGIPRO)
  {
    /* Echec ouverture fichier mouvements => erreur */
    GWTTrace (GWT_NIV_FONCT,
              ("Erreur FOPEN fichier SGIPRO ED : [ERR=%02Xh, PTH=%s]\n", errno, cNomFichier));
    iCodRet = (int4)GIXCodeKO;
    return(iCodRet);
  }

  /* Initialisation pointeur */
  buf_pos = *buf_pos_in;
  pcDebut = 0;
  pcFin = 0;

  do
  {
    /* lecture de la ligne suivante */
    (void)fgets (cStr, sizeof(cStr), GIVfDescFicSGIPRO);
    /* ligne de liste associée à SGIPRO */
    if ((0 != pcDebut) && (0 == pcFin))
    {
      pcFin = strstr (cStr, cStrFinRef);
      if (0 == pcFin)
      {
        if (sizeof(GIVBuffXML) < (strlen(GIVBuffXML) + strlen(cStr)) )
        {
          /* Ecriture dans le fichier de sortie */
          iCodRet = (int4)giv_sortie ( &buf_pos, GIVfDescFicBloc );
        }
        if ((0 == strcmp("EG",obj)) && (0 != strstr (cStr, "<urlSite>"))
        	 && (0 != strlen(doc->value.objets_pub.libUrlSite)))
        {
          strcpy(&cStr[0],"<urlSite>");
          strcat(cStr,doc->value.objets_pub.libUrlSite);
          strcat(cStr,"</urlSite>");
          lg_ecr = strlen(cStr);
          *(cStr+lg_ecr) = SEPARE_LIGNE;
          *(cStr + (lg_ecr+1) )= LINE_FEED;
          *(cStr + (lg_ecr+2) )= '\0';
          (void)strcpy(doc->value.objets_pub.libUrlSite,"");
        }
        /* écriture de ligne courante entre début et fin */
        iCodRet = givAnalyseCRC(obj, -1, doc, cStr, tcBalise, tcBaliseFin);
        if ((int4)GIXCodeOK == iCodRet)
        {
          /* fichier global non inclus */
          buf_pos = *buf_pos_in;
          *buf_pos = '\0';
          break;
        }
        if (0 == strcmp("EG",obj))
        {
          if ((0 != strstr (cStr, cStrSupp)) && (1 == doc->value.a_classer.iBLEPJProf))
          {
            /* Black-listage de balise */
            iBLEPJProf = 1;
          }
          if (0 == iBLEPJProf)
          {
            lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);
            buf_pos = buf_pos + lg_write;
            strcpy(buf_pos, cStr);
            buf_pos = buf_pos + strlen(buf_pos);
            lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBaliseFin);
          }
          if ((0 != strstr (cStr, cStrFinSupp)) && (1 == doc->value.a_classer.iBLEPJProf))
          {
            /* Fin du Black-listage de balise */
            iBLEPJProf = 0;
          }
        }
        else
        {
          lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);
          buf_pos = buf_pos + lg_write;
          strcpy(buf_pos, cStr);
          buf_pos = buf_pos + strlen(buf_pos);
          lg_write = giv_ecrit_fin_noeud(&buf_pos,tcBaliseFin);
        }
      }
      else if ((0 == strcmp("AD",obj)) && (0 != pcFin))
      {
        strcpy(buf_pos, "</Search_");
        strcat(buf_pos, tcSource);
        strcat(buf_pos, ">");
        lg_ecr = strlen(buf_pos);
        *(buf_pos+lg_ecr) = SEPARE_LIGNE;
        *(buf_pos + (lg_ecr+1) )= LINE_FEED;
        *(buf_pos + (lg_ecr+2) )= '\0';
      }
      buf_pos = buf_pos + strlen(buf_pos);
    }
    if (0 == pcDebut)
    {
      pcDebut = strstr (cStr, cStrRef);
      if (0 != pcDebut)
      {
        buf_pos = buf_pos + strlen(buf_pos);
        pcFin = 0;

        if ((buf_pos == buf_pos_ref) && (1 == *piDeb) && ((0 == strcmp("GS",obj)) || (0 == strcmp("AD",obj)) || (0 == strcmp("DV",obj))))
        {
          lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);
          buf_pos = buf_pos + lg_write;
          *piDeb = 0;
        }
        else if ((buf_pos == buf_pos_ref) && (1 == *piDeb))
        {
          lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);
          buf_pos = buf_pos + lg_write;

          strcpy(buf_pos, cStrRef);
          lg_ecr = strlen(buf_pos);
          *(buf_pos+lg_ecr) = SEPARE_LIGNE;
          *(buf_pos + (lg_ecr+1) )= LINE_FEED;
          *(buf_pos + (lg_ecr+2) )= '\0';
          buf_pos = (buf_pos + lg_ecr +2);
          *piDeb = 0;
        }
        if (0 == strcmp("AD",obj))
        {
          strcpy(buf_pos, "<Search_");
          strcat(buf_pos, tcSource);
          strcat(buf_pos, " etablissement=\"\" id=\"");
          strcat(buf_pos, doc->value.a_classer.etab);
          strcat(buf_pos, "\">");
          lg_ecr = strlen(buf_pos);
          *(buf_pos+lg_ecr) = SEPARE_LIGNE;
          *(buf_pos + (lg_ecr+1) )= LINE_FEED;
          *(buf_pos + (lg_ecr+2) )= '\0';
          buf_pos = (buf_pos + lg_ecr +2);
        }
      }
    }
    if ((0 != pcDebut) && (0 == pcFin))
    {
      pcFin = strstr (cStr, cStrFinRef);
      if (0 != pcFin)
      {
        pcDebut = 0;
      }
    }

  } while (0 == feof (GIVfDescFicSGIPRO));
  *buf_pos_in=buf_pos;
  /* Fermeture fichier SGIPRO */
  iIntRet = fclose (GIVfDescFicSGIPRO);
  iCodRet = GWCCodeOK;

  return(iCodRet);

}

/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : GIVMiseEnFormeMvtSuppEpj ()                                         */
/*                                                                            */
/* But       : Remplissage du buffer d'ecriture avec uniquement les champs    */
/*             renseignes (variables indicatrices nulles)  pour suppression   */
/*             de blocs                                                       */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) :                                                                */
/*                                                                            */
/* Portable  : Surement portable                                              */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*---------------------------------Historique----------------------------------
 *
 * Création :	 Oct/03/2006  (mb)
 *
 * Modification	(MM/JJ/AAAA - xx) :
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 GIVMiseEnFormeMvtSuppEpj (char *blocid,
                               char *pcCodope,
                               int4 dernier_ligne,
                               int4 aiMaxBloc,
                               int4 aiMaxBlocEcrit)

{
  int4		iCodRet = GWCCodeOK;		/* Code retour de la fonction */
  int4		iIntRet = GWCCodeOK;
  EXEC SQL begin declare section;
  char cBlocid[26+1];
  char tcRequete[1024];
  char cDepart[GYBIeinscLgDeppar+1];
  EXEC SQL end declare section ;
  GYBrParam_erreurT     vErreurSQL;             /* Traitement des erreurs SQL */
  char *buf_pos;
  int4 lg_write;
  int4 lg_a_ecrire;
  char nom_bloc_sup[50+1];
  char chaine_id[7+1];			/* Numero qui s'incremente    */
  char nom_test[50+1];                        /* Nom du test                */
  char    cChemin[128] = "";               /* Pathname des fichiers utilises */
  char    cNomFichier[128] = "";           /* Pathname des fichiers utilises */
  char    cNomFichier1[256] = "";           /* Pathname des fichiers utilises */
  int4 lg_ecrit_entete = 0;
  char    cEntete_xml[100] = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>";
  char          conf[50];
  char  *pcVersion = NULL;

  if ((0 == strcmp(givRecreerCD,GIXcNomIntf)) && (0 != strcmp(GIXcValUrg, GWZUrgent)) && (0 == dernier_ligne))
  {
    /* pas de suppression en sortie en création */
    return(iCodRet);
  }


  GWTTrace (GWT_NIV_FONCT,("dernier = %d\n",dernier_ligne));
  /* pas de commit */
  GIViCommit = (int4)GIXCodeKO;

  if (obtention_iden == 0)
  {
  	givInitConfGXX();
  }

  strcpy(nom_bloc_ref,blocid);
  if (0== dernier_ligne)
  {
      /* Pointeur sur debut du buffer */
      buf_pos = GIVBuffXML;
      /* écriture d'un bloc */
      strcpy(nom_bloc_sup,blocid);

      lg_write = giv_ecrit_noeud_simple(buf_pos, "OPERATION");
      buf_pos = buf_pos + lg_write;

      lg_write = giv_ecrit_balise(buf_pos, "delete", "TYPE_OPERATION");
      buf_pos = buf_pos + lg_write;

      lg_write = giv_ecrit_balise(buf_pos, nom_bloc_sup, "NAME");
      buf_pos = buf_pos + lg_write;

      lg_write = giv_ecrit_fin_noeud(&buf_pos,"OPERATION");
      buf_pos = buf_pos + lg_write;

      /* Calcul du numero d'identifiant parution_id */
      num_id = num_id + 1;

      iIntRet = giv_fichier_sortie (&buf_pos, &GIVfDescFicMCD);
      if ((int4)GWCCodeOK != iIntRet)
      {
        /* Erreur sur ecriture fin document */
        GWTTrace (GWT_NIV_GRAVE,
                  ("Erreur sur ecriture fin document dans partie_3 ...\n"));
        iCodRet = (int4)GWCCodeKO;
      }

      pcVersion = strchr(pcVersionInsFour[0], (char)'.');
      pcVersion++;

      /* fermeture du fichier */
      iIntRet = (int4)giv_fermeture_fichier_sortie ( &buf_pos, nom_bloc_sup );
      GIVBuffXML[0] = '\0';

    /* suppressions de lignes du blocid */
    (void)strcpy(vErreurSQL.acOrdre_sql,"Suppression anciens blocs GYTtabIeBloc");
    (void)strcpy((char *)cDepart,(const char *)GIXcDepartement);
    (void)strcpy(cBlocid,blocid);
    GWTTrace (GWT_NIV_FONCT,
              ("blocid  : %s\n",cBlocid));
    EXEC SQL
      execute rqtDelIeBloc
      using
      :cDepart,
      :cBlocid;

    iCodRet = GIVBlocErreur (&vErreurSQL);
    /* Analyse du code resultat SQL */
    if (((int4)GWCCodeOK != iCodRet) && ((int4)GYBnodata != iCodRet))
    {
      GWTTrace (GWT_NIV_BIZAR,
                ( "Erreur : [COD=%d TXT=%s]\n",
                  iCodRet,
                  vErreurSQL.acOrdre_sql));
    }

    if (0 == strcmp ("OUI",givtcGeneIeBlocCRC))
    {
      /* suppression sur blocid dans GYTtabIeBlocCRC */
      iIntRet = givDelIeBlocCRC(blocid);
    }
  }


  if ((1 == dernier_ligne) && (NULL == GIVfDescFicMCD) && (0 == obtention_iden))
  {
    /* Pointeur sur debut du buffer */
    buf_pos = GIVBuffXML;
    GIVBuffXML[0] = '\0';
    iIntRet = giv_fichier_sortie (&buf_pos, &GIVfDescFicMCD);
    if ((int4)GWCCodeOK != iIntRet)
    {
      /* Erreur sur ecriture fin document */
      GWTTrace (GWT_NIV_GRAVE,
                ("Erreur sur ecriture fin document dans partie_3 ...\n"));
      iCodRet = (int4)GWCCodeKO;
    }
  }

  if ((1 == dernier_ligne) && (NULL != GIVfDescFicMCD))
  {
    /* Initialisation pointeur */
    buf_pos = GIVBuffXML;
    /* Calcul de la longueur a ecrire */
    lg_a_ecrire = giv_ecrit_fin_noeud(&buf_pos,"documents");

    /* ecriture de l'enregistrement dans le fichier de sortie */
    GWTTrace (GWT_NIV_FONCT, ("Taille du buff a ecrire dans le fic XML : %d\n", lg_a_ecrire));
    GWTTrace (GWT_NIV_FONCT, ("Buff a ecrire dans le fic XML : %s\n",GIVBuffXML));

    /* Ecriture dans le fichier de sortie */
    iIntRet = (int4)fwrite ( GIVBuffXML, lg_a_ecrire, 1, GIVfDescFicMCD);
    if ( 1 != iIntRet )
    {
      /* probleme d'écriture de fichier */
      GWTTrace(GWT_NIV_GRAVE,
               ("Probleme d'écriture de fichier EPJ : %d\n",iIntRet));
      iCodRet = GIXCodeKO;
    }

    /* fichier rempli */
    iIntRet = fclose (GIVfDescFicMCD);
    if ( iIntRet != (int4)GWCCodeOK )
    {
      /* probleme de fermeture de fichier */
      GWTTrace(GWT_NIV_GRAVE,
               ("Probleme de fermeture de fichier EPJ : %d\n",iIntRet));
      iCodRet = GIXCodeKO;
    }
    GIVfDescFicMCD = NULL;

    if (NULL != GIVfDescFicCFLT)
    {
      iIntRet = fclose (GIVfDescFicCFLT);
      if ( iIntRet != (int4)GWCCodeOK )
      {
        /* probleme de fermeture de fichier */
        GWTTrace(GWT_NIV_GRAVE,
                 ("Probleme de fermeture de fichier CFLT"));
        iCodRet = GIXCodeKO;
      }
    }

    GIVfDescFicCFLT = NULL;
    giviClose = (int4)GIXCodeKO;
  }


  /* Pour ne plus recaluler au prochain passage */
  obtention_iden = 1;
  /* Sortie de la fonction */
  return(iCodRet);

}


/*----Fonction----------------------------------------------------------------*/
/*                                                                            */
/* Fonction  : GIVMiseEnFormeEPJ ()                                         */
/*                                                                            */
/* But       : Remplissage du buffer d'ecriture avec uniquement les champs    */
/*             renseignes (variables indicatrices nulles) pour création       */
/*             de blocs EPJ                                                      */
/* Entree(s) :                                                                */
/*                                                                            */
/* Sortie(s) :                                                                */
/*                                                                            */
/* Portable  : Surement portable                                              */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*---------------------------------Historique----------------------------------
 *
 * Création :
 *
 * Modification	(Dec/13/2001 - mb) : différenciation MOG/MOI
 *
 * Modification	(Jui/20/2006 - mb) : création de plusieurs fichiers de sortie
 *
 *---------------------------Fin de l'en-tête fonction------------------------*/

int4 GIVMiseEnFormeEPJ (GYBrMouvementsBlocT *prMouvement,
                             char *pcCodope, int4 dernier_ligne)

{
  int4		iCodRet = GWCCodeOK;		/* Code retour de la fonction */
  int4		iIntRet = GWCCodeOK;		/* Code retour interne */
  int2         sSaveNogrouI = -1;
  int2         sSaveNoseloI = -1;
  int2         sSaveNoselsI = -1;
  struct timeval sDate;
  int4           jncompteur;
  int4 lg_a_ecrire;                              /* Longueur du contenu de buffer : a ecrire */
  int4 lg_IG;                               /* longueur du champ nogrou_courant */
  int4 i,j,k;
  int4 iRes, iAcc;
  char cInscSante;
  char cPrtSante;
  GYBrIapartT rPart;
  char *buf_pos;
  char    cChemin[128] = "";               /* Pathname des fichiers utilises */
  char    cNomFichier[128] = "";           /* Pathname des fichiers utilises */
  time_t date;
  date=time(NULL);

  /* Pointeur sur debut du buffer */
  buf_pos = GIVBuffXML;
  /* pas de bloc écrit */
  iMaxBlocEcritAvant = (int4)-1;
  /* pas de commit */
  GIViCommit = (int4)GIXCodeKO;
  /* écriture bloc dans buffer */
  giviCodRetEcr = (int4)GIXCodeOK;
  /* récupération des paramètres d'appel */
  /* pour les rendre visibles des sous-programmes sans etre obligé de les repasser à chaque fois */
  strcpy(cCodope,pcCodope);
  strcpy(cNumlot, prMouvement->acNumlot);
  strcpy(cNummvt, prMouvement->acNummvt);
  strcpy(cNumnat, prMouvement->acNumnat);
  strcpy(cNumlo, prMouvement->acNumlo);
  strcpy(cNumls, prMouvement->acNumls);
  strcpy(cBlocidPrec, prMouvement->acBlocid);

  /* Initialisation structure du bloc */
  iCodRet = givInitBlocParution(&doc);

      if  (dernier_ligne == 0)
    {
    	/* analyse MC */
          iCodRet = givMefEnsemble(&doc, nb_inscription);
            memcpy(&(doc2[nb_inscription]), &doc, sizeof(GYBrDOCUMENT));
            nb_inscription++;
   }
   else
      {
    	/* analyse Etab */
    	iCodRet = GIVLectureTabPeEtab (doc2->value.a_classer.etab);
        if ((int4)GIXCodeKO == iCodRet)
        {
        	for (i = 0 ; (i < nb_inscription && givcParuSSAdr == doc2[i].value.inscription[0].adresse.parution[givcIndParuAdr]); i++);
          if (nb_inscription == i)
          {
            memcpy( &doc, &(doc2[0]), sizeof(GYBrDOCUMENT));
          }
          else
          {
            memcpy( &doc, &(doc2[i]), sizeof(GYBrDOCUMENT));
          }
        }
        else
        {
          iCodRet = givMefDonneesParution(&doc, nb_inscription);
          iCodRet = givMefMoyensTelecom(&doc, nb_inscription);
          iCodRet = givMefLieuInstallation(&doc, nb_inscription);
        }

  /* données de partenaire liées à l'établissement */
    iIntRet = GIVLectureTabPartEtab (doc2->value.a_classer.etab, givtcCleNav);

  GWTTrace (GWT_NIV_FONCT,
              ("Nb IaPart : %d\n", GIViNbTupleIapart));

  if (0 != GIViNbTupleIapart)
  {
    iRes = 0;
    iAcc = 0;
    for(i=0; i< GIViNbTupleIapart; i++)
    {
    	if ((0 == strcmp(GIVtrPart[i].acOriPart,giv_RESA)) && (NULL == strstr(givtcFourPart,GIVtrPart[i].acOriPart)))
    	{
        iRes = 1;
    	}
    	else if ((0 == strcmp(GIVtrPart[i].acOriPart,giv_ACCO)) && (NULL == strstr(givtcFourPart,GIVtrPart[i].acOriPart)))
    	{
        iAcc = 1;
        break;
    	}
    }
        /* analyse type d'inscription */
    cInscSante = givcParuSante;
  	for(i=0; (i< nb_inscription && giv_orPJDC != doc2[i].value.intitule.parution[0]); i++);
  	if (nb_inscription == i)
  	{
  	  for(i=0; (i< nb_inscription && giv_svPJDC != doc2[i].value.intitule.parution[0]); i++);
  	}
  	if (nb_inscription == i)
  	{
  	  for(i=0; (i< nb_inscription && giv_cPJDC != doc2[i].value.intitule.parution[0]); i++);
  	}
   	if (nb_inscription == i)
  	{
  	  for(i=0; (i< nb_inscription && giv_prPJDC != doc2[i].value.intitule.parution[0]); i++);
    }
  	if (nb_inscription != i)
  	{
      cInscSante = doc2[i].value.intitule.parution[0];
    }
    /* analyse type de partenaire */
    cPrtSante = givcParuSante;
    for(i=0; (i< GIViNbTupleIapart
       && ((giv_orPJDC != GIVtrPart[i].acTypeRefPart[0]) || (0 != strcmp(GIVtrPart[i].acOriPart,giv_PJDC)))); i++);
  	if (GIViNbTupleIapart == i)
    {
      for(i=0; (i< GIViNbTupleIapart
       && ((giv_svPJDC != GIVtrPart[i].acTypeRefPart[0]) || (0 != strcmp(GIVtrPart[i].acOriPart,giv_PJDC)))); i++);
    }
  	if (GIViNbTupleIapart == i)
    {
      for(i=0; (i< GIViNbTupleIapart
       && ((giv_cPJDC != GIVtrPart[i].acTypeRefPart[0]) || (0 != strcmp(GIVtrPart[i].acOriPart,giv_PJDC)))); i++);
    }
  	if (GIViNbTupleIapart == i)
    {
      for(i=0; (i< GIViNbTupleIapart
       && ((giv_prPJDC != GIVtrPart[i].acTypeRefPart[0]) || (0 != strcmp(GIVtrPart[i].acOriPart,giv_PJDC)))); i++);
    }
  	if (GIViNbTupleIapart != i)
    {
    	cPrtSante = GIVtrPart[i].acTypeRefPart[0];
    }
    j = doc2->value.a_classer.iNbPart;
    giviNbIapartPJDC = 0;
    giviNbTupleIapart = j;
    strcpy(rPart.acOriPart, "    ");
    for(i=0; i< GIViNbTupleIapart; i++)
    {
      if ((NULL == strstr(givtcFourPart,GIVtrPart[i].acOriPart)) || ('0' != GIVvInscrip.acIndPart[0]))
      {
      	if ((1 == iAcc) && ((0 == strcmp(GIVtrPart[i].acOriPart,giv_RESA))
      		|| (0 == strcmp(GIVtrPart[i].acOriPart,giv_EXPD))))
      	{
          GWTTrace (GWT_NIV_FONCT,
          ("Part resa/expd non prioritaire : %s, %s\n", GIVtrPart[i].acRefPart,doc2->value.a_classer.etab));
      		continue;
      	}
      	else if ((1 == iRes) && (0 == strcmp(GIVtrPart[i].acOriPart,giv_EXPD)))
      	{
          GWTTrace (GWT_NIV_FONCT,
          ("Part expd non prioritaire : %s, %s\n", GIVtrPart[i].acRefPart,doc2->value.a_classer.etab));
      		continue;
      	}
      	else if ((0 == strcmp(GIVtrPart[i].acOriPart,rPart.acOriPart))
      		&& (0 != strcmp(GIVtrPart[i].acOriPart,giv_PJDC)))
      	{
          GWTTrace (GWT_NIV_FONCT,
          ("Part expd (hors pjdc) double non prioritaire : %s, %s\n", GIVtrPart[i].acRefPart,doc2->value.a_classer.etab));
      		continue;
      	}

        /* Analyse santé PJDOC */
      	if ((cInscSante != GIVtrPart[i].acTypeRefPart[0]) && (0 == strcmp(GIVtrPart[i].acOriPart,giv_PJDC))
      		&& ((giv_orPJDC == cInscSante) || (giv_cPJDC == cInscSante)))
      	{
          GWTTrace (GWT_NIV_FONCT,
          ("Type santé non retenu : %c, %s, %s, %s\n", cInscSante, GIVtrPart[i].acTypeRefPart,
                                            GIVtrPart[i].acRefPart,doc2->value.a_classer.etab));
      		continue;
      	}
      	if ((cPrtSante != GIVtrPart[i].acTypeRefPart[0]) && (0 == strcmp(GIVtrPart[i].acOriPart,giv_PJDC))
      		&& (giv_prPJDC == cInscSante))
      	{
          GWTTrace (GWT_NIV_FONCT,
          ("Type santé non retenu : %c, %s, %s, %s\n", cInscSante, GIVtrPart[i].acTypeRefPart,
                                            GIVtrPart[i].acRefPart,doc2->value.a_classer.etab));
      		continue;
      	}
      	if ( ((cPrtSante != GIVtrPart[i].acTypeRefPart[0])
      		|| (giv_orPJDC != cPrtSante && giv_svPJDC != cPrtSante))
      		&& (0 == strcmp(GIVtrPart[i].acOriPart,giv_PJDC))
      		&& (giv_svPJDC == cInscSante) )
      	{
          GWTTrace (GWT_NIV_FONCT,
          ("Type santé non retenu : %c, %s, %s, %s\n", cInscSante, GIVtrPart[i].acTypeRefPart,
                                            GIVtrPart[i].acRefPart,doc2->value.a_classer.etab));
      		continue;
      	}

        doc2->value.a_classer.trpart[j].iForPJDC = GIXCodeKO;
        strcpy(doc2->value.a_classer.trpart[j].rpart, GIVtrPart[i].acRefPart);
        strcat(doc2->value.a_classer.trpart[j].rpart, GIVtrPart[i].acOriPart);
        strcpy(doc2->value.a_classer.trpart[j].typepart,GIVtrPart[i].acTypeRefPart);
        strcpy(doc2->value.a_classer.trpart[j].parent, GIVtrPart[i].acParentRefPart);
        strcpy(doc2->value.a_classer.trpart[j].idmed, GIVtrPart[i].acIdMed);
        strcpy(doc2->value.a_classer.trpart[j].isdoc, GIVtrPart[i].acIsDoc);
        for(k=0; (k< givNbPart && (0 != strcmp(GIVtrPart[i].acOriPart,givTabPart[k].tcPart))); k++);
        if (givNbPart == k)
        {
        	doc2->value.a_classer.trpart[j].prod[0] = '\0';
        }
        else
        {
          strcpy(doc2->value.a_classer.trpart[j].prod, givTabPart[k].tcProd);
        }
        strcpy(doc2->value.a_classer.trpart[j].clenav,givtcCleNav[i]);
        GWTTrace (GWT_NIV_FONCT,
                ("Part : %s,%s\n", doc2->value.a_classer.trpart[j].rpart, doc2->value.a_classer.trpart[j].prod));
      	if ((0 == strcmp(GIVtrPart[i].acOriPart,rPart.acOriPart))
      		&& (0 == strcmp(GIVtrPart[i].acOriPart,giv_PJDC)))
      	{
      		/* une seule référence partenaire pour l'origine PJDC */
          GWTTrace (GWT_NIV_FONCT,
          ("Part pjdc double non prioritaire : %s, %s\n", GIVtrPart[i].acRefPart,doc2->value.a_classer.etab));
          giviNbIapartPJDC ++;
  	      doc2->value.a_classer.trpart[j].iRgParent = giviNbParentPart;
  	      doc2->value.a_classer.trpart[j].iNbParent = 1;
          strcpy(givtrPart[giviNbParentPart].acOriPart, GIVtrPart[i].acOriPart);
          strcpy(givtrPart[giviNbParentPart].acRefPart, GIVtrPart[i].acRefPart);
          strcpy(givtrPart[giviNbParentPart].acDenom, GIVtrPart[i].acDenom);
          strcpy(givtrPart[giviNbParentPart].acPrenom, GIVtrPart[i].acPrenom);
          giviNbParentPart++;
          j++;
      	}
      	else
      	{
          j++;
          giviNbTupleIapart = j;
        }

        strcpy(rPart.acOriPart, GIVtrPart[i].acOriPart);
      }
    }
    GIViNbTupleIapart = giviNbTupleIapart;
  }
  doc2->value.a_classer.iNbPart = GIViNbTupleIapart;



        /* génération du bloc EPJ */
        iCodRet = givGroupement(&buf_pos,&doc, &doc2[0], nb_inscription);
        nb_inscription = 0;
        iMaxBlocEcritAvant++;
      }



  /* Sortie de la fonction */
  return(iCodRet);

}
